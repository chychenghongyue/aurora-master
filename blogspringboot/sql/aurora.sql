/*
 Navicat Premium Data Transfer

 Source Server         : 虚拟机MySQL
 Source Server Type    : MySQL
 Source Server Version : 80030 (8.0.30)
 Source Host           : 192.168.188.128:3306
 Source Schema         : aurora

 Target Server Type    : MySQL
 Target Server Version : 80030 (8.0.30)
 File Encoding         : 65001

 Date: 04/11/2023 16:50:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_about
-- ----------------------------
DROP TABLE IF EXISTS `t_about`;
CREATE TABLE `t_about`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '内容',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_about
-- ----------------------------
INSERT INTO `t_about` VALUES (1, '{\"content\":\"this is about\"}', '2022-07-24 17:22:13', '2022-09-23 14:37:34');

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL COMMENT '作者',
  `category_id` int NULL DEFAULT NULL COMMENT '文章分类',
  `article_cover` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章缩略图',
  `article_title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `article_abstract` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章摘要，如果该字段为空，默认取文章的前500个字符作为摘要',
  `article_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '内容',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶 0否 1是',
  `is_featured` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否推荐 0否 1是',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密 3草稿',
  `type` tinyint(1) NOT NULL DEFAULT 1 COMMENT '文章类型 1原创 2转载 3翻译',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '访问密码',
  `original_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '原文链接',
  `create_time` datetime NOT NULL COMMENT '发表时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 139 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (135, 1024, 217, 'http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg', 'Spring Security', '', '## 0. 简介\n\n​	**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n​	一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n​	 一般Web应用的需要进行**认证**和**授权**。\n\n​		**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\n\n​		**授权：经过认证后判断当前用户是否有权限进行某个操作**\n\n​	而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n\n## 1. 快速入门\n\n### 1.1 准备工作\n\n​	我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n\n~~~~xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n~~~~\n\n\n② 创建启动类\n\n~~~~java\n@SpringBootApplication\npublic class SecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SecurityApplication.class,args);\n    }\n}\n\n~~~~\n\n③ 创建Controller\n\n~~~~java\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n\n~~~~\n\n\n\n### 1.2 引入SpringSecurity\n\n​	在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n~~~~xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n~~~~\n\n​	引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n​	必须登陆之后才能对接口进行访问。\n\n\n\n## 2. 认证\n\n### 2.1 登陆校验流程\n\n![image20211215094003288.png](https://static.linhaojun.top/aurora/articles/03fc208b0326f9c76804cbd4a2b8d4b8.png)\n\n### 2.2 原理初探\n\n​	想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\n\n\n\n#### 2.2.1 SpringSecurity完整流程\n\n​	SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\n\n![image20211214144425527.png](https://static.linhaojun.top/aurora/articles/5e68a45696fe867f79e4eb640c941526.png)\n\n​	图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\n\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\n\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\n\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\n\n​	\n\n​	我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\n\n![image20211214145824903.png](https://static.linhaojun.top/aurora/articles/6bda42b10230521701f848266c8fdad4.png)\n\n\n\n\n\n#### 2.2.2 认证流程详解\n\n![image20211214151515385.png](https://static.linhaojun.top/aurora/articles/09386f9d52f0c8c625b5a94884a7178d.png)\n\n概念速查:\n\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\n\nAuthenticationManager接口：定义了认证Authentication的方法 \n\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\n\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\n\n\n\n\n\n### 2.3 解决问题\n\n#### 2.3.1 思路分析\n\n登录\n\n​	①自定义登录接口  \n\n​				调用ProviderManager的方法进行认证 如果认证通过生成jwt\n\n​				把用户信息存入redis中\n\n​	②自定义UserDetailsService \n\n​				在这个实现类中去查询数据库\n\n校验：\n\n​	①定义Jwt认证过滤器\n\n​				获取token\n\n​				解析token获取其中的userid\n\n​				从redis中获取用户信息\n\n​				存入SecurityContextHolder\n\n#### 2.3.2 准备工作\n\n①添加依赖\n\n~~~~xml\n        <!--redis依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n        <!--fastjson依赖-->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.33</version>\n        </dependency>\n        <!--jwt依赖-->\n        <dependency>\n            <groupId>io.jsonwebtoken</groupId>\n            <artifactId>jjwt</artifactId>\n            <version>0.9.0</version>\n        </dependency>\n~~~~\n\n② 添加Redis相关配置\n\n~~~~java\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport org.springframework.util.Assert;\nimport java.nio.charset.Charset;\n\n/**\n * Redis使用FastJson序列化\n * \n * @author 三更\n */\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\n{\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n    private Class<T> clazz;\n\n    static\n    {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    }\n\n    public FastJsonRedisSerializer(Class<T> clazz)\n    {\n        super();\n        this.clazz = clazz;\n    }\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    {\n        if (t == null)\n        {\n            return new byte[0];\n        }\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    }\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    {\n        if (bytes == null || bytes.length <= 0)\n        {\n            return null;\n        }\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    }\n\n\n    protected JavaType getJavaType(Class<?> clazz)\n    {\n        return TypeFactory.defaultInstance().constructType(clazz);\n    }\n}\n~~~~\n\n~~~~java\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    @SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\n    {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n~~~~\n\n③ 响应类\n\n~~~~java\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n/**\n * @Author 三更\n */\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult<T> {\n    /**\n     * 状态码\n     */\n    private Integer code;\n    /**\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\n     */\n    private String msg;\n    /**\n     * 查询到的结果数据，\n     */\n    private T data;\n\n    public ResponseResult(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public ResponseResult(Integer code, T data) {\n        this.code = code;\n        this.data = data;\n    }\n\n    public Integer getCode() {\n        return code;\n    }\n\n    public void setCode(Integer code) {\n        this.code = code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    public void setData(T data) {\n        this.data = data;\n    }\n\n    public ResponseResult(Integer code, String msg, T data) {\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    }\n}\n~~~~\n\n④工具类\n\n~~~~java\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.UUID;\n\n/**\n * JWT工具类\n */\npublic class JwtUtil {\n\n    //有效期为\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = \"sangeng\";\n\n    public static String getUUID(){\n        String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        return token;\n    }\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) {\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    }\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) {\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    }\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null){\n            ttlMillis=JwtUtil.JWT_TTL;\n        }\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(\"sg\")     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    }\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) {\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\";\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    }\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() {\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\");\n        return key;\n    }\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception {\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    }\n\n\n}\n~~~~\n\n~~~~java\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\n@Component\npublic class RedisCache\n{\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public <T> void setCacheObject(final String key, final T value)\n    {\n        redisTemplate.opsForValue().set(key, value);\n    }\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    {\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    }\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    {\n        return expire(key, timeout, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    {\n        return redisTemplate.expire(key, timeout, unit);\n    }\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public <T> T getCacheObject(final String key)\n    {\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    }\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    {\n        return redisTemplate.delete(key);\n    }\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    {\n        return redisTemplate.delete(collection);\n    }\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public <T> long setCacheList(final String key, final List<T> dataList)\n    {\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    }\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public <T> List<T> getCacheList(final String key)\n    {\n        return redisTemplate.opsForList().range(key, 0, -1);\n    }\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\n    {\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\n        Iterator<T> it = dataSet.iterator();\n        while (it.hasNext())\n        {\n            setOperation.add(it.next());\n        }\n        return setOperation;\n    }\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public <T> Set<T> getCacheSet(final String key)\n    {\n        return redisTemplate.opsForSet().members(key);\n    }\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\n    {\n        if (dataMap != null) {\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        }\n    }\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public <T> Map<String, T> getCacheMap(final String key)\n    {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\n    {\n        redisTemplate.opsForHash().put(key, hKey, value);\n    }\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public <T> T getCacheMapValue(final String key, final String hKey)\n    {\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    }\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    {\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    }\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\n    {\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    }\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection<String> keys(final String pattern)\n    {\n        return redisTemplate.keys(pattern);\n    }\n}\n~~~~\n\n~~~~java\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class WebUtils\n{\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static String renderString(HttpServletResponse response, String string) {\n        try\n        {\n            response.setStatus(200);\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            response.getWriter().print(string);\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n~~~~\n\n⑤实体类\n\n~~~~java\nimport java.io.Serializable;\nimport java.util.Date;\n\n\n/**\n * 用户表(User)实体类\n *\n * @author 三更\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable {\n    private static final long serialVersionUID = -40356785423868312L;\n    \n    /**\n    * 主键\n    */\n    private Long id;\n    /**\n    * 用户名\n    */\n    private String userName;\n    /**\n    * 昵称\n    */\n    private String nickName;\n    /**\n    * 密码\n    */\n    private String password;\n    /**\n    * 账号状态（0正常 1停用）\n    */\n    private String status;\n    /**\n    * 邮箱\n    */\n    private String email;\n    /**\n    * 手机号\n    */\n    private String phonenumber;\n    /**\n    * 用户性别（0男，1女，2未知）\n    */\n    private String sex;\n    /**\n    * 头像\n    */\n    private String avatar;\n    /**\n    * 用户类型（0管理员，1普通用户）\n    */\n    private String userType;\n    /**\n    * 创建人的用户id\n    */\n    private Long createBy;\n    /**\n    * 创建时间\n    */\n    private Date createTime;\n    /**\n    * 更新人\n    */\n    private Long updateBy;\n    /**\n    * 更新时间\n    */\n    private Date updateTime;\n    /**\n    * 删除标志（0代表未删除，1代表已删除）\n    */\n    private Integer delFlag;\n}\n~~~~\n\n\n\n#### 2.3.3 实现\n\n##### 2.3.3.1 数据库校验用户\n\n​	从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\n\n###### 准备工作\n\n​	我们先创建一个用户表， 建表语句如下：\n\n~~~~mysql\nCREATE TABLE `sys_user` (\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\n~~~~\n\n​		引入MybatisPuls和mysql驱动的依赖\n\n~~~~xml\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n            <version>3.4.3</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n~~~~\n\n​		配置数据库信息\n\n~~~~yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n~~~~\n\n​		定义Mapper接口\n\n~~~~java\npublic interface UserMapper extends BaseMapper<User> {\n}\n~~~~\n\n​		修改User实体类\n\n~~~~java\n类名上加@TableName(value = \"sys_user\") ,id字段上加 @TableId\n~~~~\n\n​		配置Mapper扫描\n\n~~~~java\n@SpringBootApplication\n@MapperScan(\"com.sangeng.mapper\")\npublic class SimpleSecurityApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\n        System.out.println(run);\n    }\n}\n~~~~\n\n​		添加junit依赖\n\n~~~~java\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n        </dependency>\n~~~~\n\n​	   测试MP是否能正常使用\n\n~~~~java\n/**\n * @Author 三更\n */\n@SpringBootTest\npublic class MapperTest {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void testUserMapper(){\n        List<User> users = userMapper.selectList(null);\n        System.out.println(users);\n    }\n}\n~~~~\n\n\n\n###### 核心代码实现\n\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\n\n~~~~java\n/**\n * @Author 三更\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        //根据用户名查询用户信息\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        //如果查询不到数据就通过抛出异常来给出提示\n        if(Objects.isNull(user)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //TODO 根据用户查询权限信息 添加到LoginUser中\n        \n        //封装成UserDetails对象返回 \n        return new LoginUser(user);\n    }\n}\n~~~~\n\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\n\n```java\n/**\n * @Author 三更\n */\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private User user;\n\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUserName();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n```\n\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\n\n##### 2.3.3.2 密码加密存储\n\n​	实际项目中我们不会把密码明文存储在数据库中。\n\n​	默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\n\n​	我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\n\n​	我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\n\n​	我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\n\n~~~~java\n/**\n * @Author 三更\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n}\n~~~~\n\n##### 2.3.3.3 登陆接口\n\n​	接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\n\n​	在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\n\n​	认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\n\n~~~~java\n@RestController\npublic class LoginController {\n\n    @Autowired\n    private LoginServcie loginServcie;\n\n    @PostMapping(\"/user/login\")\n    public ResponseResult login(@RequestBody User user){\n        return loginServcie.login(user);\n    }\n}\n\n~~~~\n\n~~~~java\n/**\n * @Author 三更\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n}\n~~~~\n\n​	\n\n~~~~java\n@Service\npublic class LoginServiceImpl implements LoginServcie {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public ResponseResult login(User user) {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //使用userid生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(userId);\n        //authenticate存入redis\n        redisCache.setCacheObject(\"login:\"+userId,loginUser);\n        //把token响应给前端\n        HashMap<String,String> map = new HashMap<>();\n        map.put(\"token\",jwt);\n        return new ResponseResult(200,\"登陆成功\",map);\n    }\n}\n\n~~~~\n\n\n\n##### 2.3.3.4 认证过滤器\n\n​	我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\n\n​	使用userid去redis中获取对应的LoginUser对象。\n\n​	然后封装Authentication对象存入SecurityContextHolder\n\n\n\n~~~~java\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        //获取token\n        String token = request.getHeader(\"token\");\n        if (!StringUtils.hasText(token)) {\n            //放行\n            filterChain.doFilter(request, response);\n            return;\n        }\n        //解析token\n        String userid;\n        try {\n            Claims claims = JwtUtil.parseJWT(token);\n            userid = claims.getSubject();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"token非法\");\n        }\n        //从redis中获取用户信息\n        String redisKey = \"login:\" + userid;\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\n        if(Objects.isNull(loginUser)){\n            throw new RuntimeException(\"用户未登录\");\n        }\n        //存入SecurityContextHolder\n        //TODO 获取权限信息封装到Authentication中\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(request, response);\n    }\n}\n~~~~\n\n~~~~java\n/**\n * @Author 三更\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n\n\n    @Autowired\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //把token校验过滤器添加到过滤器链中\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n}\n\n~~~~\n\n\n\n##### 2.3.3.5 退出登陆\n\n​	我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\n\n~~~~java\n/**\n * @Author 三更  \n */\n@Service\npublic class LoginServiceImpl implements LoginServcie {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public ResponseResult login(User user) {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //使用userid生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(userId);\n        //authenticate存入redis\n        redisCache.setCacheObject(\"login:\"+userId,loginUser);\n        //把token响应给前端\n        HashMap<String,String> map = new HashMap<>();\n        map.put(\"token\",jwt);\n        return new ResponseResult(200,\"登陆成功\",map);\n    }\n\n    @Override\n    public ResponseResult logout() {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        Long userid = loginUser.getUser().getId();\n        redisCache.deleteObject(\"login:\"+userid);\n        return new ResponseResult(200,\"退出成功\");\n    }\n}\n\n~~~~\n\n\n\n\n\n## 3. 授权\n\n### 3.0 权限系统的作用\n\n​	例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\n\n​	总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\n\n​	我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\n\n​	所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\n\n​	\n\n### 3.1 授权基本流程\n\n​	在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\n\n​	所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\n\n​	然后设置我们的资源所需要的权限即可。\n\n### 3.2 授权实现\n\n#### 3.2.1 限制访问资源所需权限\n\n​	SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\n\n​	但是要使用它我们需要先开启相关配置。\n\n~~~~java\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n~~~~\n\n​	然后就可以使用对应的注解。@PreAuthorize\n\n~~~~java\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    @PreAuthorize(\"hasAuthority(\'test\')\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n~~~~\n\n#### 3.2.2 封装权限信息\n\n​	我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\n\n​	我们先直接把权限信息写死封装到UserDetails中进行测试。\n\n​	我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\n\n~~~~java\npackage com.sangeng.domain;\n\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @Author 三更  \n */\n@Data\n@NoArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private User user;\n        \n    //存储权限信息\n    private List<String> permissions;\n    \n    \n    public LoginUser(User user,List<String> permissions) {\n        this.user = user;\n        this.permissions = permissions;\n    }\n\n\n    //存储SpringSecurity所需要的权限信息的集合\n    @JSONField(serialize = false)\n    private List<GrantedAuthority> authorities;\n\n    @Override\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\n        if(authorities!=null){\n            return authorities;\n        }\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\n        authorities = permissions.stream().\n                map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUserName();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n~~~~\n\n​		LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\n\n~~~~java\npackage com.sangeng.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\nimport com.sangeng.domain.LoginUser;\nimport com.sangeng.domain.User;\nimport com.sangeng.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * @Author 三更  \n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        if(Objects.isNull(user)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        //TODO 根据用户查询权限信息 添加到LoginUser中\n        List<String> list = new ArrayList<>(Arrays.asList(\"test\"));\n        return new LoginUser(user,list);\n    }\n}\n\n~~~~\n\n\n\n#### 3.2.3 从数据库查询权限信息\n\n##### 3.2.3.1 RBAC权限模型\n\n​	RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\n\n![image20211222110249727.png](https://static.linhaojun.top/aurora/articles/87839cfbe9dfb7c8ecfd20303ce3d401.png)\n\n##### 3.2.3.2 准备工作\n\n~~~~sql\n\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\n\nUSE `sg_security`;\n\n/*Table structure for table `sys_menu` */\n\nDROP TABLE IF EXISTS `sys_menu`;\n\nCREATE TABLE `sys_menu` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\n  `create_by` bigint(20) DEFAULT NULL,\n  `create_time` datetime DEFAULT NULL,\n  `update_by` bigint(20) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\n\n/*Table structure for table `sys_role` */\n\nDROP TABLE IF EXISTS `sys_role`;\n\nCREATE TABLE `sys_role` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) DEFAULT NULL,\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\n  `create_by` bigint(200) DEFAULT NULL,\n  `create_time` datetime DEFAULT NULL,\n  `update_by` bigint(200) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\n\n/*Table structure for table `sys_role_menu` */\n\nDROP TABLE IF EXISTS `sys_role_menu`;\n\nCREATE TABLE `sys_role_menu` (\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\n  PRIMARY KEY (`role_id`,`menu_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n/*Table structure for table `sys_user` */\n\nDROP TABLE IF EXISTS `sys_user`;\n\nCREATE TABLE `sys_user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\n\n/*Table structure for table `sys_user_role` */\n\nDROP TABLE IF EXISTS `sys_user_role`;\n\nCREATE TABLE `sys_user_role` (\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\n  PRIMARY KEY (`user_id`,`role_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n~~~~\n\n~~~~mysql\nSELECT \n	DISTINCT m.`perms`\nFROM\n	sys_user_role ur\n	LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\n	LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\n	LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\nWHERE\n	user_id = 2\n	AND r.`status` = 0\n	AND m.`status` = 0\n~~~~\n\n\n\n\n\n\n\n~~~~java\npackage com.sangeng.domain;\n\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * 菜单表(Menu)实体类\n *\n * @author 三更\n * @since 2021-11-24 15:30:08\n */\n@TableName(value=\"sys_menu\")\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class Menu implements Serializable {\n    private static final long serialVersionUID = -54979041104113736L;\n    \n        @TableId\n    private Long id;\n    /**\n    * 菜单名\n    */\n    private String menuName;\n    /**\n    * 路由地址\n    */\n    private String path;\n    /**\n    * 组件路径\n    */\n    private String component;\n    /**\n    * 菜单状态（0显示 1隐藏）\n    */\n    private String visible;\n    /**\n    * 菜单状态（0正常 1停用）\n    */\n    private String status;\n    /**\n    * 权限标识\n    */\n    private String perms;\n    /**\n    * 菜单图标\n    */\n    private String icon;\n    \n    private Long createBy;\n    \n    private Date createTime;\n    \n    private Long updateBy;\n    \n    private Date updateTime;\n    /**\n    * 是否删除（0未删除 1已删除）\n    */\n    private Integer delFlag;\n    /**\n    * 备注\n    */\n    private String remark;\n}\n~~~~\n\n\n\n##### 3.2.3.3 代码实现\n\n​	我们只需要根据用户id去查询到其所对应的权限信息即可。\n\n​	所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\n\n~~~~java\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.sangeng.domain.Menu;\n\nimport java.util.List;\n\n/**\n * @Author 三更  \n */\npublic interface MenuMapper extends BaseMapper<Menu> {\n    List<String> selectPermsByUserId(Long id);\n}\n~~~~\n\n​	尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\n\n~~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.sangeng.mapper.MenuMapper\">\n\n\n    <select id=\"selectPermsByUserId\" resultType=\"java.lang.String\">\n        SELECT\n            DISTINCT m.`perms`\n        FROM\n            sys_user_role ur\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\n        WHERE\n            user_id = #{userid}\n            AND r.`status` = 0\n            AND m.`status` = 0\n    </select>\n</mapper>\n~~~~\n\n​	在application.yml中配置mapperXML文件的位置\n\n~~~~yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  redis:\n    host: localhost\n    port: 6379\nmybatis-plus:\n  mapper-locations: classpath*:/mapper/**/*.xml \n\n~~~~\n\n\n\n​	然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\n\n~~~~java\n/**\n * @Author 三更 \n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private MenuMapper menuMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        if(Objects.isNull(user)){\n            throw new RuntimeException(\"用户名或密码错误\");\n        }\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\n//        //测试写法\n//        List<String> list = new ArrayList<>(Arrays.asList(\"test\"));\n        return new LoginUser(user,permissionKeyList);\n    }\n}\n~~~~\n\n\n\n\n\n## 4. 自定义失败处理\n\n​	我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\n\n​	在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\n\n​	如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\n\n​	如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\n\n​	所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\n\n\n\n①自定义实现类\n\n~~~~java\n@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \"权限不足\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n\n    }\n}\n\n~~~~\n\n~~~~java\n/**\n * @Author 三更  \n */\n@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \"认证失败请重新登录\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    }\n}\n\n~~~~\n\n\n\n\n\n②配置给SpringSecurity\n\n​	\n\n​	先注入对应的处理器\n\n~~~~java\n    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n~~~~\n\n​	然后我们可以使用HttpSecurity对象的方法去配置。\n\n~~~~java\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\n                accessDeniedHandler(accessDeniedHandler);\n~~~~\n\n\n\n## 5. 跨域\n\n​	浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \n\n​	前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\n\n​	所以我们就要处理一下，让前端能进行跨域请求。\n\n①先对SpringBoot配置，运行跨域请求\n\n~~~~java\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n      // 设置允许跨域的路径\n        registry.addMapping(\"/**\")\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(\"*\")\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                // 设置允许的header属性\n                .allowedHeaders(\"*\")\n                // 跨域允许时间\n                .maxAge(3600);\n    }\n}\n~~~~\n\n②开启SpringSecurity的跨域访问\n\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\n\n~~~~java\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //添加过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        //配置异常处理器\n        http.exceptionHandling()\n                //配置认证失败处理器\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n\n        //允许跨域\n        http.cors();\n    }\n\n~~~~\n\n\n\n\n\n## 6. 遗留小问题\n\n### 其它权限校验方法\n\n​	我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\n\n​    \n\n​	这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\n\n​	hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\n\n​	它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\n\n\n\n​	hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\n\n~~~~java\n    @PreAuthorize(\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n​	hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\n\n~~~~java\n    @PreAuthorize(\"hasRole(\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n​	hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\n\n~~~~java\n    @PreAuthorize(\"hasAnyRole(\'admin\',\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n\n\n### 自定义权限校验方法\n\n​	我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\n\n~~~~java\n@Component(\"ex\")\npublic class SGExpressionRoot {\n\n    public boolean hasAuthority(String authority){\n        //获取当前用户的权限\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        List<String> permissions = loginUser.getPermissions();\n        //判断用户权限集合中是否存在authority\n        return permissions.contains(authority);\n    }\n}\n~~~~\n\n​	 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\n\n~~~~java\n    @RequestMapping(\"/hello\")\n    @PreAuthorize(\"@ex.hasAuthority(\'system:dept:list\')\")\n    public String hello(){\n        return \"hello\";\n    }\n~~~~\n\n\n\n### 基于配置的权限控制\n\n​	我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\n\n~~~~java\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                .antMatchers(\"/testCors\").hasAuthority(\"system:dept:list222\")\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //添加过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        //配置异常处理器\n        http.exceptionHandling()\n                //配置认证失败处理器\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n\n        //允许跨域\n        http.cors();\n    }\n~~~~\n\n\n\n\n\n\n\n### CSRF\n\n​	[CSRF](https://blog.csdn.net/freeking101/article/details/86537087)是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\n\n​	SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\n\n​	我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\n\n\n\n\n\n### 认证成功处理器\n\n​	实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\n\n​	我们也可以自己去自定义成功处理器进行成功后的相应处理。\n\n~~~~java\n@Component\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        System.out.println(\"认证成功了\");\n    }\n}\n\n~~~~\n\n~~~~java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin().successHandler(successHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    }\n}\n\n~~~~\n\n\n\n### 认证失败处理器\n\n​	实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\n\n​	我们也可以自己去自定义失败处理器进行失败后的相应处理。\n\n~~~~java\n@Component\npublic class SGFailureHandler implements AuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        System.out.println(\"认证失败了\");\n    }\n}\n~~~~\n\n\n\n~~~~java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Autowired\n    private AuthenticationFailureHandler failureHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin()\n//                配置认证成功处理器\n                .successHandler(successHandler)\n//                配置认证失败处理器\n                .failureHandler(failureHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    }\n}\n\n~~~~\n\n\n\n### 登出成功处理器\n\n~~~~java\n@Component\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        System.out.println(\"注销成功\");\n    }\n}\n\n~~~~\n\n~~~~java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Autowired\n    private AuthenticationFailureHandler failureHandler;\n\n    @Autowired\n    private LogoutSuccessHandler logoutSuccessHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.formLogin()\n//                配置认证成功处理器\n                .successHandler(successHandler)\n//                配置认证失败处理器\n                .failureHandler(failureHandler);\n\n        http.logout()\n                //配置注销成功处理器\n                .logoutSuccessHandler(logoutSuccessHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    }\n}\n~~~~\n', 1, 0, 0, 1, 1, NULL, NULL, '2023-11-01 18:00:51', '2023-11-04 15:15:34');
INSERT INTO `t_article` VALUES (136, 1024, 219, 'http://192.168.188.128:9000/aurora/aurora/articles/af392c0c59d6c80294db1f7836a2fbd1.jpg', '滑动窗口算法', '', '# 算法分享：滑动窗口\n## 原题描述：\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n## 思路\n- 定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复\n- 我们定义不重复子串的开始位置为 start，结束位置为 end\n- 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符\n- 无论是否更新 start，都会更新其 map 数据结构和结果 ans。\n- 时间复杂度：O(n)\n## 代码实现\n```java\nimport java.util.HashMap;\n\n/**\n * 滑动窗口\n */\n@SuppressWarnings(\"all\")\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        int ans = 0;\n        for(int start = 0,end = 0;end < s.length();end++){\n            char charAt = s.charAt(end);\n            if(map.containsKey(charAt)){\n                start = Math.max(map.get(charAt),start);\n            }\n            map.put(charAt,end+1);\n            ans = Math.max(end-start+1,ans);\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Solution test = new Solution();\n        System.out.println(test.lengthOfLongestSubstring(\"dvdf\"));\n    }\n}\n```\n\n\n', 0, 0, 0, 1, 1, NULL, NULL, '2023-11-01 18:08:49', NULL);
INSERT INTO `t_article` VALUES (137, 1024, 221, 'http://192.168.188.128:9000/aurora/aurora/articles/753f1e9dcba4a4e591af2c629cc8e271.jpg', 'linux基本命令', '', '# 1.目录结构\n\n├── bin -> usr/bin # 用于存放二进制命令\n├── boot # 内核及引导系统程序所在的目录\n├── dev # 所有设备文件的目录（如磁盘、光驱等）\n├── etc # 配置文件默认路径、服务启动命令存放目录\n├── home # 用户家目录，root用户为/root\n├── lib -> usr/lib # 32位库文件存放目录\n├── lib64 -> usr/lib64 # 64位库文件存放目录\n├── media # 媒体文件存放目录\n├── mnt # 临时挂载设备目录\n├── opt # 自定义软件安装存放目录\n├── proc # 进程及内核信息存放目录\n├── root # Root用户家目录\n├── run # 系统运行时产生临时文件，存放目录\n├── sbin -> usr/sbin # 系统管理命令存放目录\n├── srv # 服务启动之后需要访问的数据目录\n├── sys # 系统使用目录\n├── tmp # 临时文件目录\n├── usr # 系统命令和帮助文件目录\n└── var # 存放内容易变的文件的目录\n\n# 2. ls命令\n\nls  仅列出当前目录可见文件 \nls -l  列出当前目录可见文件详细信息\nls -h 列出详细信息并以可读大小显示文件大小\nls -a 列出所有文件（包括隐藏）的详细信息 \nls --human-readable --size -1 -S --classify # 按文件大小排序 \ndu -sh * | sort -h # 按文件大小排序(同上)\n\n\n### 通配符	\n\n含义\n*代表任意个数个字符\n?代表任意一个字符，至少 1 个\n[]表示可以匹配字符组中的任一一个\n[abc]匹配 a、b、c 中的任意一个\n[a-f]匹配从 a 到 f 范围内的的任意一个字符\n\n# 3.cd命令\n\ncd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一\n注意：Linux 所有的 目录 和 文件名 都是大小写敏感的\n\n命令	含义\ncd -	可以在最近两次工作目录之间来回切换\n\ncd    # 进入用户主目录；\ncd /  # 进入根目录\ncd ~  # 进入用户主目录；\ncd ..  # 返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..\"为上级目录的意思）；\ncd ../..  # 返回上两级目录；\ncd !$  # 把上个命令的参数作为cd参数使用。\n\n相对路径和绝对路径\n相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置\n绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置\n\n# 4.mv 命令\n\n功能：mv命令是move的缩写，可以用来移动文件或者将文件改名（move(rename)files），是Linux系统下常用的命令，经常用来备份文件或者目录\n\n格式：mv [选项] [路径] [旧文件名] [新路径] [新文件名]\n\n常用选项：\n\n选项	说明\n-f	force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\n-i	若目标文件 (destination) 已经存在时，就会询问是否覆盖\n注意：\n\n如果只移动不改名字，新名字可以不写\n如果移动的同时改名字，新名字一定要写\n\n# 5.cp 命令\n\n功能: 复制文件或目录\n说明：cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息\n\n格式：cp [选项] [路径] [旧文件名] [新路径]\n\n常用选项表：\n\n选项	说明\n-f 或 --force	强行复制文件或目录， 不论目的文件或目录是否已经存在\n-i 或 --interactive	覆盖文件之前先询问用户\n-r	递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理\n-R 或 --recursive	递归处理，将指定目录下的文件及子目录一并处理\n\n\n\n-a：此参数的效果和同时指定\"-dpR\"参数相同；\n-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；\n-f：强行复制文件或目录，不论目标文件或目录是否已存在；\n-i：覆盖既有文件之前先询问用户；\n-l：对源文件建立硬连接，而非复制文件；\n-p：保留源文件或目录的属性；\n-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；\n-s：对源文件建立符号连接，而非复制文件；\n-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；\n-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；\n-b：覆盖已存在的文件目标前将目标文件备份；\n-v：详细显示命令执行的操作。\n\n# 6.mkdir命令\n\n用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 \n\n注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。\n\n在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。\n\n### 语法\n\n```shell\nmkdir (选项)(参数)\n```\n\n### 选项\n\n```shell\n-Z：设置安全上下文，当使用SELinux时有效；\n-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限；\n-p或--parents 递归创建目录，若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\n--version 显示版本信息。\n```\n\n### 权限 \n\n文件或目录的权限又分为3种：只读、只写、可执行。\n\n权限	权限数值	二进制	具体作用\nr	4	00000100	read，读取。当前用户可以读取文件内容，当前用户可以浏览目录。\nw   2	00000010	write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。\nx    1	00000001	execute，执行。当前用户可以执行文件，当前用户可以进入目录。\n依照上面的表格，权限组合就是对应权限值求和，如下：\n7 = 4 + 2 + 1 读写运行权限\n5 = 4 + 1 读和运行权限\n4 = 4 只读权限\n\n顺序为user ,group,other ,**所有者权限**，**同组用户的权限**，**其他用户的权限**\n\n7 = rwx = 可读，可写，可执行\n6 = rw- = 可读，可写，不可执行\n5 = r-x = 可读，不可写，可执行\n4 = r--\n3 = -wx\n2 = -w-\n1 = --x\n0 = ---\n\n​		\n\n在目录`/usr/meng`下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问\n\n```shell\nmkdir -m 700 /usr/meng/test\n```\n\n在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问\n\n```shell\nmkdir -p-m 750 bin/os_1\n```\n\n# 7.touch命令\n\n创建文件或修改文件时间\n如果文件 不存在，可以创建一个空白文件\n如果文件 已经存在，可以修改文件的末次修改日期\n\n**语法：**\n\n```\ntouch [选项] [参数]\n```\n\n-a：或--time=atime或--time=access或--time=use  只更改存取时间；\n-c：或--no-create  不建立任何文件；\n-d：<时间日期> 使用指定的日期时间，而非现在的时间；\n-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；\n-m：或--time=mtime或--time=modify  只更该变动时间；\n-r：<参考文件或目录>  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；\n-t：<日期时间>  使用指定的日期时间，而非现在的时间；\n--help：在线帮助；\n--version：显示版本信息。\n\n# 8.rm命令\n\n- 删除文件或目录\n  使用 rm 命令要小心，因为文件删除后不能恢复\n\n| 选项            |                         含义                          |\n| --------------- | :---------------------------------------------------: |\n| -f              |         强制删除，忽略不存在的文件，无需提示          |\n| -r              | 递归地删除目录下的内容，**删除文件夹 时必须加此参数** |\n| -d              |   直接把欲删除的目录的硬连接数据删除成0，删除该目录   |\n| -v              |                显示指令的详细执行过程                 |\n| -i              |           删除已有文件或目录之前先询问用户            |\n| -v              |                显示指令的详细执行过程                 |\n| --preserve-root |                不对根目录进行递归操作                 |\n\n\n\n# 9.ln命令\n\n**ln命令** 用来为文件创建链接，链接类型分为硬链接和符号链接两种，默认的链接类型是硬链接。如果要创建符号链接必须使用\"-s\"选项。\n\n注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。\n\n### 语法\n\n```shell\nln [参数] [源文件或目录] [目标文件或目录]\nln [选项]... [-T] 目标 链接名	(第一种格式)\n　或：ln [选项]... 目标		(第二种格式)\n　或：ln [选项]... 目标... 目录	(第三种格式)\n　或：ln [选项]... -t 目录 目标...	(第四种格式)\n```\n\n### 选项\n\n```shell\n-s, --symbolic              # 对源文件建立符号链接，而非硬链接\n--backup[=CONTROL]      # 为每个已存在的目标文件创建备份文件\n-b                      # 类似--backup，但不接受任何参数\n-d, -F, --directory         # 创建指向目录的硬链接(只适用于超级用户)\n-f, --force                 # 强行删除任何已存在的目标文件\n-i, --interactive           # 覆盖既有文件之前先询问用户\n-L, --logical               # 取消引用作为符号链接的目标\n-n, --no-dereference        # 把符号链接的目的目录视为一般文件\n-P, --physical              # 直接将硬链接到符号链接\n-r, --relative              # 创建相对于链接位置的符号链接\n-S, --suffix=SUFFIX         # 用\"-b\"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它\n-t, --target-directory=DIRECTORY # 指定要在其中创建链接的DIRECTORY\n-T, --no-target-directory   # 将“LINK_NAME”视为常规文件\n-v, --verbose               # 打印每个链接文件的名称\n--help      # 显示此帮助信息并退出\n--version   # 显示版本信息并退出\n```\n\n### 参数\n\n- 源文件：指定链接的源文件。如果使用`-s`选项创建符号链接，则“源文件”可以是文件或者目录。创建硬链接时，则“源文件”参数只能是文件。\n- 目标文件：指定源文件的目标链接文件。\n\n```shell\nnone, off       # 不进行备份(即使使用了--backup 选项)\nnumbered, t     # 备份文件加上数字进行排序\nexisting, nil   # 若有数字的备份文件已经存在则使用数字，否则使用普通方式备份\nsimple, never   # 永远使用普通方式备份\n```\n\n### **实例**\n\n将目录`/usr/mengqc/mub1` 下的文件 m2.c 链接到目录 `/usr/liu` 下的文件 a2.c\n\n```shell\ncd /usr/mengqc\nln /mub1/m2.c /usr/liu/a2.c\n```\n\n在执行ln命令之前，目录`/usr/liu`中不存在a2.c文件。执行ln之后，在`/usr/liu`目录中才有a2.c这一项，表明m2.c和a2.c链接起来（注意，二者在物理上是同一文件），利用`ls -l`命令可以看到链接数的变化。\n\n**创建软链接**\n\n在目录`/usr/liu`下建立一个符号链接文件abc，使它指向目录`/usr/mengqc/mub1`\n\n```shell\nln -s /usr/mengqc/mub1 /usr/liu/abc\n```\n\n执行该命令后，`/usr/mengqc/mub1`代表的路径将存放在名为`/usr/liu/abc`的文件中。\n\n**创建硬链接**\n\n给文件创建硬链接，为 `log2022.log` 创建硬链接 `ln2022`，`log2022.log` 与 `ln2022` 的各项属性相同\n\n```shell\nln log2022.log ln2022\n```\n\n输出：\n\n```\n[root@localhost test]# ll\nlrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -> log2022.log\n-rw-r--r-- 1 root bin      61 11-13 06:03 log2022.log\n[root@localhost test]# ln log2022.log ln2022\n[root@localhost test]# ll\nlrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -> log2022.log\n-rw-r--r-- 2 root bin      61 11-13 06:03 ln2022\n-rw-r--r-- 2 root bin      61 11-13 06:03 log2022.log\n```\n\n## 扩展知识\n\nLinux具有为一个文件起多个名字的功能，称为链接。被链接的文件可以存放在相同的目录下，但是必须有不同的文件名，而不用在硬盘上为同样的数据重复备份。另外，被链接的文件也可以有相同的文件名，但是存放在不同的目录下，这样只要对一个目录下的该文件进行修改，就可以完成对所有目录下同名链接文件的修改。对于某个文件的各链接文件，我们可以给它们指定不同的存取权限，以控制对信息的共享和增强安全性。\n\n文件链接有两种形式，即硬链接和符号链接。\n\nln功能说明：是为某一个文件在另外一个位置建立一个同步的链接，当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。\n\n> ⚠️ ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化。\n\n### 符号链接(软连接)\n\n符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如下所示的abc文件），其中包含它提供链接的另一个文件的路径名，如虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。\n\n```shell\n$ ls -il\ntotal 0\n922736 lrwxrwxrwx 1 root root 5 Jun 17 11:27 abc -> a.txt\n922735 -rw-r--r-- 1 root root 0 Jun 17 11:27 a.txt\n```\n\n1. 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\n2. 软链接可以 跨文件系统 ，硬链接不可以\n3. 软链接可以对一个不存在的文件名进行链接\n4. 软链接可以对目录进行链接\n\n与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的索引节点号；而硬链接并没有建立新文件。\n\n符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。\n\n用`ln -s`命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。\n\n符号链接保持了链接与源文件或目录之间的区别：\n\n- 删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据。\n- 在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是l。\n- 符号链接的大小是其链接文件的路径名中的字节数。\n- 当用`ls -l`命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如`lrwxrwxrwx … 14 jun 20 10:20 /etc/motd->/original_file`其中，表示“文件大小”的数字“14”恰好说明源文件名`original_file`由14个字符构成。\n\n### 硬链接\n\n建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如下所示的m2.c文件就在目录mub1和liu中都建立了目录项。\n\n1. 硬链接，以文件副本的形式存在。但不占用实际空间。\n\n2. 不允许给目录创建硬链接\n\n3. 硬链接只有在同一个文件系统中才能创建\n\n4. 创建硬链接后，己经存在的文件的索引节点号（inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为1。\n\n   在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。\n\n   对硬链接有如下限制：\n\n   - 不能对目录文件做硬链接。\n   - 不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统中。\n\n# 10.find 命令\n\n功能：用来在指定目录下查找文件\n\n格式：find [路径] [选项] [操作]\n\n### 常用选项\n\n-a             									and 必须满足两个条件才显示\n-o            									 or 只要满足一个条件就显示\n-name     									 按照文件名查找文件\n-iname     									按照文件名查找文件(忽略大小写)\n\n-size 											按照文件大小来查找\n\n-type        									根据文件类型进行搜索\n-perm      									 按照文件权限来查找文件\n-user       									 按照文件属主来查找文件。\n-group    									  按照文件所属的组来查找文件。\n-fprint      									 文件名：将匹配的文件输出到文件。\n-newer file1 ! newer file2             查找更改时间比文件file1新但比文件file2旧的文件\n\n### 常用动作\n\n-print                                            默认动作，将匹配的文件输出到标准输出\n-exec   										对匹配的文件执行该参数所给出的命令。相应命令的形式为 \'command\' { } \\;，注意{ }和\\；之间的空格。\n-ok     										  和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\n-delete 										将匹配到的文件删除\n\n### 实例\n\n根据文件名进行匹配\n1.列出当前目录及子目录下所有文件和文件夹\n命令：find .\n\n2.在/home目录下查找以.txt结尾的文件名\nfind /home/ -name \"*.txt\" \n3.同上，但忽略大小写\nfind /home -iname \"*.txt\"\n\n4.查找 /home/ 下所有以.txt或.pdf结尾的文件\n find /home/ -name \"*.txt\" -o -name \"*.pdf\"\n\n5.查找 /home/ 下所有以a开头和以.txt结尾的文件\n find /home/ -name \"*.txt\" -a -name \"a*\"\n\n6.搜索/home目录下txt结尾的文件，并将输出到指定文件中(re.txt)\n[root@localhost home]# find /home/ -type f -name \"*.txt\" -fprint /tmp/re.txt \n\n7.根据文件类型进行搜索\n\n[root@host-136 ~]# find /home/ -type f\n\n### 类型参数列\n\n​    f 普通文件\n​    l 符号连接（软连接）\n​    d 目录\n​    b 块设备\n​    s 套接字\n\n\n\n# 11.grep 命令\n\n功能：用于查找文件里符合条件的字符串\n\n### 格式\n\ngrep [选项] \'查找字符串\' 文件名\n\n**grep命令里的匹配模式就是你想要找的东西，可以是普通的文字符号，也可以是正则表达式**\n\n### 常用选项\n\n-i：在搜索的时候忽略大小写\n\n-n：显示结果所在行号\n\n-c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数\n\n-o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行\n\n-v：输出不带关键字的行（反向查询，反向匹配）\n\n-w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配\n\n-Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after\n\n-Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before\n\n-Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context\n\n-e：实现多个选项的匹配，逻辑or关系\n\n-q：静默模式，不输出任何信息，当我们只关心有没有匹配到，却不关心匹配到什么内容时，我们可以使用此命令，然后，使用”echo $?”查看是否匹配到，0表示匹配到，1表示没有匹配到。\n\n-P：表示使用兼容perl的正则引擎。\n\n-E：使用扩展正则表达式，而不是基本正则表达式，在使用”-E”选项时，相当于使用egrep。\n\n\n\n# 12.less命令\n\n分屏上下翻页浏览文件内容\n\n**less命令** 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。\n\n### 语法\n\n```shell\nless(选项)(参数)\n```\n\n### 选项\n\n```shell\n-e：文件内容显示完毕后，自动退出；\n-f：强制显示文件；\n-g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；\n-l：搜索时忽略大小写的差异；\n-N：每一行行首显示行号；\n-s：将连续多个空行压缩成一行显示；\n-S：在单行显示较长的内容，而不换行显示；\n-x<数字>：将TAB字符显示为指定个数的空格字符。\n```\n\n### 参数\n\n文件：指定要分屏显示内容的文件。\n\n\n\n# 13.cat 命令\n\n> **功能**： 查看目标文件的内容\n\n**格式**：`cat [选项] 文件名`\n\n**常用选项**：\n\n| 选项 | 说明               |\n| ---- | ------------------ |\n| -b   | 对非空输出行编号   |\n| -n   | 对输出的所有行编号 |\n| -s   | 不输出多行空行     |\n\ncat (全称 concatenate) 命令是 Linux/类 Unix 操作系统中最常用的命令之一。cat 命令允许我们创建单个或多个文件、查看文件内容、连接文件和重定向终端或文件中的输出。\n\n在本文中，我们将了解如何方便地使用 cat 命令及其在 Linux 中的示例。\n\n### 1.显示文件内容\n\n下面的例子将显示 /etc/passwd 文件。\n\n​		cat /etc/passwd\n\n### 2.终端查看多个文件的内容\n\n在下面的示例中，它将显示 rumenz 和 rumenz1 终端中的文件。\n\ncat rumenz rumenz1\n\n入门小站\nrumenz.com\n\n### 3.用cat命令创建文件\n\n我们将创建一个名为 rumenz2 使用以下命令创建文件。\n\ncat > rumenz2\n\n### 4.等待用户输入，键入所需文本\n\n然后按 CTRL+D （按住 Ctrl key 并输入d） 退出。正文将写在rumenz2文件。你可以使用以下命令查看文件的内容cat 命令。\n\ncat rumenz2\n\nrumenz.com\n\n### 5.使用more和less参数的Cat命令\n\n如果有大量的内容，屏幕滚动起来非常快，我们可以使用参数more和less\n\ncat song.txt | more\n\ncat song.txt | less\n\n### 6.在文件中显示行号\n\n随着 -n 选项你可以看到一个文件的行号 song.txt 在输出端。\n\ncat -n song.txt\n\n### 7.一次显示多个文件\n\n在下面的例子中，我们有三个文件 rumenz, rumenz1, 和 rumenz2,并能够查看这些文件的内容，如上所示。我们需要将每个文件分开;。\n\ncat rumenz; cat rumenz1; cat rumenz2\n\nThis is a rumenz file\nThis is the rumenz1 file.\nThis is rumenz2 file.\n\n### 8.使用标准输出和重定向操作符\n\n我们可以将文件的标准输出重定向到一个新文件中，否则现有文件中带有 >（大于）符号。仔细，现有的内容rumenz1 将被内容覆盖 rumenz 文件。\n\ncat rumenz > rumenz1\n\n### 9.使用重定向运算符附加标准输出\n\n在现有文件中附加 >>（双大于）符号。这里的内容rumenz 文件将附加在文件的末尾 rumenz1 文件。\n\ncat rumenz >> rumenz1\n\n### 10.使用重定向运算符重定向标准输入\n\n当你将重定向与标准输入一起使用时<（小于符号），它使用文件名 rumenz2 作为命令的输入和输出将显示在终端中。\n\ncat < rumenz2\n\nThis is rumenz2 file.\n\n### 11.重定向包含在单个文件中的多个文件\n\n这将创建一个名为 rumenz3 并且所有输出都将重定向到新创建的文件中。\n\ncat rumenz rumenz1 rumenz2 > rumenz3\n\n### 12.在单个文件中对多个文件的内容进行排序\n\n这将创建一个文件 rumenz4 和输出 cat 命令通过管道进行排序，结果将被重定向到新创建的文件。\n\n# 14.echo命令\n\n 用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。\n\n### 语法\n\n```shell\necho(选项)(参数)\n```\n\n### 选项\n\n```shell\n-e：激活转义字符。\n```\n\n使用`-e`选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：\n\n- `\\a` 发出警告声；\n- `\\b` 删除前一个字符；\n- `\\c` 不产生进一步输出 (\\c 后面的字符不会输出)；\n- `\\f` 换行但光标仍旧停留在原来的位置；\n- `\\n` 换行且光标移至行首；\n- `\\r` 光标移至行首，但不换行；\n- `\\t` 插入tab；\n- `\\v` 与\\f相同；\n- `\\\\` 插入\\字符；\n- `\\nnn` 插入 `nnn`（八进制）所代表的ASCII字符；\n\n# 15.覆盖和追加\n\n### 1.语法\n\n将列表的内容覆盖到文件中:ll >文件\n\n将列表的内容追加到文件尾部:ll >>文件\n\n将文件1的内容覆盖到文件2中:cat 文件1 > 文件2\n\n将文件1的内容追加到文件2的尾部:cat 文件1 >> 文件2\n\n将内容写入覆盖到文件中:echo “内容” > 文件\n\n将内容写入追加到文件的尾部: echo “内容” >> 文件\n\n### 2.功能\n\n  指令 > : 如果文件存在，将原来文件的内容覆盖；原文件不存在则创建文件，再添加信息。\n  指令 >> : 不会覆盖原文件内容，将内容追加到文件的尾部。\n\n### 3.常用范例\n\n例一：将ls查看信息写入到文件中\n\n命令：ll > log.txt\n例二：将log1.txt的内容覆盖到log4.txt中\n\n命令：cat log1.txt > log4.txt\n\n  没有log4.txt文件则会自动创建。\n例三：在log.txt追加内容\n\n命令：echo Hello World2 >> log.txt\n\n# 16.file命令\n\n 用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。\n\n### 语法\n\n```shell\nfile(选项)(参数)\n```\n\n表示要确定类型的文件列表（文件或目录）。多个文件之间使用空格分开，可以使用shell通配符匹配多个文件\n\n### 选项\n\n```shell\n-b：列出辨识结果时，不显示文件名称；\n-c：详细显示指令执行过程，便于排错或分析程序执行的情形；\n-f<名称文件>：指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称；\n-L：直接显示符号连接所指向的文件类别；\n-m<魔法数字文件>：指定魔法数字文件；\n-v：显示版本信息；\n-z：尝试去解读压缩文件的内容。\n\n```\n\n# 17.PS 命令\n\n功能：用来列出系统中当前正在运行的那些进程，类似于 windows 的任务管理器。\n\n格式：ps [选项]\n\n常用选项：\n\n选项	说明\n-A	列出所有的进程 （重要）\n-ef	查看全格式的全部进程 （重要）\n-w	显示加宽可以显示较多的资讯\n-au	显示较详细的资讯\n-aux	显示所有包含其他使用者的行程\n\n# 18.**yum命令** \n\n是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\nyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n### 语法\n\n```shell\nyum(选项)(参数)\n```\n\n### 选项\n\n```shell\n-h：显示帮助信息；\n-y：对所有的提问都回答“yes”；\n-c：指定配置文件；\n-q：安静模式；\n-v：详细模式；\n-d：设置调试等级（0-10）；\n-e：设置错误等级（0-10）；\n-R：设置yum处理一个命令的最大等待时间；\n-C：完全从缓存中运行，而不去下载或者更新任何头文件。\n```\n\n### 参数\n\n```shell\ninstall：安装rpm软件包；\nupdate：更新rpm软件包；\ncheck-update：检查是否有可用的更新rpm软件包；\nremove：删除指定的rpm软件包；\nlist：显示软件包的信息；\nsearch：检查软件包的信息；\ninfo：显示指定的rpm软件包的描述信息和概要信息；\nclean：清理yum过期的缓存；\nshell：进入yum的shell提示符；\nresolvedep：显示rpm软件包的依赖关系；\nlocalinstall：安装本地的rpm软件包；\nlocalupdate：显示本地rpm软件包进行更新；\ndeplist：显示rpm软件包的所有依赖关系。\n```\n\n# 19.tar命令\n\nTar（tape archive）是一种归档文件格式，它通常用于将多个文件打包成一个单一的文件。该文件通常以.tar扩展名结尾。Tar文件没有压缩功能，因此通常与gzip或bzip2等压缩工具一起使用，以创建压缩的归档文件。\n\n### 1、tar命令的打包操作\n\n创建tar文件的命令是tar，可以使用以下命令创建一个名为archive.tar的tar文件，其中包含目录/ home / user /和文件/home/user/file1和/home/user/file2：\n\ntar -cvf archive.tar /home/user/ /home/user/file1 /home/user/file2\n-c：创建新的tar文件(create 表示建包的意思)\n\n-v：显示操作详细信息 （verbose 冗长的，详细，表示命令执行时会显示更多的信息）\n\n-f：指定要创建的tar文件的文件名（file 指定tar包的文件名）\n\ntar -cvf 打包文件的名字.tar 文件名字或路径\n1\n\n### 2、tar命令的解包操作\n\n要将tar文件解压缩到当前目录，可以使用以下命令：\n\n***tar -xvf archive.tar***\n\n-x：提取文件（extract 提取 取出 表示解包的意思）\n\n-v：显示操作详细信息\n\n-f：指定要提取的tar文件的文件名\n\ntar -xvf 需要解包文件的名字.tar\n1\n\n### 3、tar命令的建立压缩包操作\n\n***tar -czvf archive.tar.gz /home/user/ /home/user/file1 /home/user/file2***\n-c：创建新的tar文件\n\n-z：使用gzip压缩工具进行压缩 （表示使用命令gzip进行压缩 扩展名.tar.gz或者.tgz）\n\n-v：显示操作详细信息\n\n-f：指定要创建的tar文件的文件名\n\n### 4、tar命令解压缩包操作\n\n要解压缩gzip压缩的tar文件，可以使用以下命令：\n\n***tar -xzvf archive.tar.gz***\n-x：提取文件\n\n-z：使用gzip解压缩工具进行解压缩\n\n-v：显示操作详细信息\n\n-f：指定要提取的tar文件的文件名\n\ntar zxvf 解压文件.tar.gz [-C 指定解压到哪个目录]\n\n\n要将tar文件与bzip2压缩工具一起使用，可以使用以下命令将tar文件压缩为bzip2压缩的tar文件：\n\n***tar -cjvf archive.tar.bz2 /home/user/ /home/user/file1 /home/user/file2***\n\n-c：创建新的tar文件\n\n-j：使用bzip2压缩工具进行压缩 （表示使用命令bzip2进行压缩 扩展名.tar.bz2.gz或者.tbz2）\n\n-v：显示操作详细信息\n\n-f：指定要创建的tar文件的文件名\n\n要解压缩gzip压缩的tar文件，可以使用以下命令：\n\n***tar -xjvf archive.tar.bz2***-x：提取文件\n\n-j：使用bzip2解压缩工具进行解压缩\n\n-v：显示操作详细信息\n\n-f：指定要提取的tar文件的文件名\n\ntar zxvf 解压文件.tar.gz [-C 指定解压到哪个目录]\n\n\n\n# 20.su命令\n\n su是swith user的缩写,在Linux中 su 命令可让用户暂时变更登入的身份,除 root 外变更时须输入所要变更的用户帐号与密码。\n\n### 1.语法：\n\nsu [参数] [-] [用户帐号]\n\n### 2.功能：\n\n  变更用户身份，若不指定用户帐号，则预设变更为root。\n\n### 3.参数：\n\n-c<指令>或--command=<指令> 　						执行完指定的指令后，即恢复原来的身份。 \n-f或--fast 　														   适用于csh与tsch，使shell不用去读取启动文件。 \n--l或--login 　														改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更PATH变量。  \n-m,-p或--preserve-environment 　						变更身份时，不要变更环境变量。 \n-s<shell>或--shell=<shell> 　						指定要执行的shell（bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell。\n\n### 4.常用范例：\n\n例一：变更帐号为 root 并在执行 ls 指令后退出变回原使用者\n\n命令：su -c ls root\n例二：切换用户\n\n命令： su root\n\n  testuser切换成root，相当于用户改成root但是操作的是testuser环境\n  小权限切换大权限要求输入密码;大权限切换小权限不需要输入密码。\n  切换用户，只能获得用户的执行权限，不能获得环境变量。\n例三：切换用户，改变环境变量\n\n命令：su - root\n\n  testuser切换成root，相当于用户改成root，操作的是root环境。即变更帐号为 root 并改变工作目录至 root 的家目录。\n  切换到用户并获得该用户的环境变量及执行权限。\n\n\n\n# 21.vim\n\n### 1.vim编辑器的四种模式\n\n☆ 命令模式\n使用VIM编辑器时，默认处于命令模式。在该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作。\n\n☆ 编辑模式或输入模式\n在命令模式下输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑\n\n☆ 末行模式\n在命令模式下输入冒号:即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存、退出等操作\n\n☆ 可视化模式\n可以做一些列选操作（通过方向键选择某些列的内容,类似于Windows鼠标刷黑）\n可视化模式\n\n### 2.VIM四种模式的关系\n\n 编辑模式------------字母   i   或   o   或   a   ----------->命令模式\n\n可视化模式-----------------字母    v     ----------------->命令模式\n\n命令模式----------------输入    ：   或     /    ----------->末行模式\n\n末行模式-------输入    ：q！   或      ：wq      --------->退出vim\n\n### 3.VIM编辑器的使用\n\n1.使用vim打开文件\n基本语法：\n\nvim  文件名称\n① 如果文件已存在，则直接打开\n\n② 如果文件不存在，则vim编辑器会自动在内存中创建一个新文件\n\n案例：使用vim命令打开readme.txt文件\n\nvim readme.txt\n\n\n\n2.vim编辑器保存文件\n在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号:，进入到末行模式，输入wq，代表保存并退出。\n\n3.vim编辑器强制退出（不保存）\n在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号：，进入到末行模式，输入q!，代表强制退出但是不保存文件。\n\n##### 1.命令模式下的相关操作\n\n☆ 如何进入命令模式\n答：在Linux操作系统中，当我们使用vim命令直接打开某个文件时，默认进入的就是命令模式。如果我们处于其他模式（编辑模式、可视化模式以及末行模式）可以连续按两次Esc键也可以返回命令模式\n\n☆ 命令模式下我们能做什么\n① 移动光标 ② 复制 粘贴 ③ 剪切 粘贴 删除 ④ 撤销与恢复\n\n☆ 移动光标到首行或末行（!）\n移动光标到首行 => gg\n\n移动光标到末行 => G\n\n☆ 翻屏\n向上 翻屏，按键：ctrl + b （before） 或 PgUp\n\n向下 翻屏，按键：ctrl + f （after） 或 PgDn\n\n向上翻半屏，按键：ctrl + u （up）\n\n向下翻半屏，按键：ctrl + d （down）\n\n☆ 快速定位光标到指定行（!）\n行号 + G，如150G代表快速移动光标到第150行。\n\n☆ 复制/粘贴（!）\n① 复制当前行（光标所在那一行）\n\n按键：yy\n\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\n\n② 从当前行开始复制指定的行数，如复制5行，5yy\n\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\n\n☆ 剪切/删除（!）\n在VIM编辑器中，剪切与删除都是dd\n\n如果剪切了文件，但是没有使用p进行粘贴，就是删除操作\n\n如果剪切了文件，然后使用p进行粘贴，这就是剪切操作\n\n① 剪切/删除当前光标所在行\n\n按键：dd （删除之后下一行上移）\n\n粘贴：p\n\n注意：dd 严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。\n\n② 剪切/删除多行（从当前光标所在行开始计算）\n\n按键：数字dd\n\n粘贴：p\n\n特殊用法：\n\n③ 剪切/删除光标所在的当前行（光标所在位置）之后的内容，但是删除之后下一行不上移\n\n按键：D （删除之后当前行会变成空白行）\n\n☆ 撤销/恢复（!）\n撤销：u（undo）\n\n恢复：ctrl + r 恢复（取消）之前的撤销操作【重做，redo】\n\n总结\n① 怎么进入命令模式（vim 文件名称，在任意模式下，可以连续按两次Esc键即可返回命令模式）\n\n② 命令模式能做什么？移动光标、复制/粘贴、剪切/删除、撤销与恢复\n\n首行 => gg，末行 => G 翻屏（了解） 快速定位 行号G，如150G\n\nyy p 5yy p\n\ndd p 5dd p\n\nu\n\nctrl + r\n\n##### 2.末行模式下的相关操作\n\n☆ 如何进入末行模式\n进入末行模式的方法只有一个，在命令模式下使用冒号：的方式进入。\n\n☆ 末行模式下我们能做什么\n文件保存、退出、查找与替换、显示行号、paste模式等等\n\n☆ 保存/退出（!）\n:w => 代表对当前文件进行保存操作，但是其保存完成后，并没有退出这个文件\n\n:q => 代表退出当前正在编辑的文件，但是一定要注意，文件必须先保存，然后才能退出\n\n:wq => 代表文件先保存后退出（保存并退出）\n\n如果一个文件在编辑时没有名字，则可以使用:wq 文件名称，代表把当前正在编辑的文件保存到指定的名称中，然后退出\n\n:q! => 代表强制退出但是文件未保存（不建议使用）\n\n###### ☆ 查找/搜索（!）\n\n切换到命令模式，然后输入斜杠/（也是进入末行模式的方式之一）\n\n进入到末行模式后，输入要查找或搜索的关键词，然后回车\n\n如果在一个文件中，存在多个满足条件的结果。在搜索结果中切换上/下一个结果：N/n （大写N代表上一个结果，小写n代表next）\n\n如果需要取消高亮，则需要在末行模式中输入:noh【no highlight】\n\n☆ 文件内容的替换（!）\n第一步：首先要进入末行模式（在命令模式下输入冒号:）\n\n第二步：根据需求替换内容\n\n① 只替换光标所在这一行的第一个满足条件的结果（只能替换1次）\n\n:s/要替换的关键词/替换后的关键词   +  回车\n案例：把hello rhel中的 rhel替换为 rhel8\n\n切换光标到hello  rhel这一行\n:s/rhel/rhel8\n② 替换光标所在这一行中的所有满足条件的结果（替换多次，只能替换一行）\n\n:s/要替换的关键词/替换后的关键词/g		g=global全局替换\n案例：把hello rhel中的所有rhel都替换为rhel8\n\n切换光标到hello rhel这一行\n:s/rhel/rhel8/g\n③ 针对整个文档中的所有行进行替换，只替换每一行中满足条件的第一个结果\n\n:%s/要替换的关键词/替换后的关键词\n案例：把每一行中的第一个hello关键词都替换为hi\n\n:%s/hello/hi\n④ 针对整个文档中的所有关键词进行替换（只要满足条件就进行替换操作）\n\n:%s/要替换的关键词/替换后的关键词/g\n案例：替换整个文档中的hello关键词为hi\n\n:%s/hello/hi/g\n☆ 显示行号\n基本语法：\n\n:set nu\n【nu = number】，行号\n取消行号 => :set nonu\n\n☆ set paste模式\n为什么要使用paste模式？\n\n问题：在终端Vim中粘贴代码时，发现插入的代码会有多余的缩进，而且会逐行累加。原因是终端把粘贴的文本存入键盘缓存（Keyboard Buffer）中，Vim则把这些内容作为用户的键盘输入来处理。导致在遇到换行符的时候，如果Vim开启了自动缩进，就会默认的把上一行缩进插入到下一行的开头，最终使代码变乱。\n\n在粘贴数据之前，输入下面命令开启paste模式\n:set paste\n\n粘贴完毕后，输入下面命令关闭paste模式\n:set nopaste\n\n总结\n① 如何进入末行模式，必须从命令模式中使用冒号进行切换\n\n② 末行模式下能做什么？保存、退出、查找、替换、显示行号以及paste模式\n\n③ 保存 => :w\n\n④ 退出 => :q，先保存后退出。:wq :wq 文件名称 :q!\n\n⑤ 查找功能 => 命令模式输入/斜杠 + 关键词（高亮显示）=> :noh\n\n⑥ 替换功能\n\n:s/要替换的关键词/替换后的关键词\n\n:s/要替换的关键词/替换后的关键词/g\n\n:%s/要替换的关键词/替换后的关键词\n\n:%s/要替换的关键词/替换后的关键词/g\n\n⑦ 显示行号 => :set nu 取消行号 => :set nonu\n\n⑧ paste模式 => 将来在粘贴代码的时候为了保存原格式 => 粘贴之前 => :set paste\n\n##### 3.编辑模式\n\n1）编辑模式的作用\n编辑模式的作用比较简单，主要是实现对文件的内容进行编辑模式。\n\n2）如何进入编辑模式\n首先你需要进入到命令模式，然后使用小写字母a或小写字母i，进入编辑模式。\n\n命令模式 + i ： insert缩写，代表在光标之前插入内容\n\n命令模式 + a ： append缩写，代表在光标之后插入内容\n\n3）退出编辑模式\n在编辑模式中，直接按Esc，即可从编辑模式退出到命令模式。\n\n##### 4.可视化模式\n\n1）如何进入到可视化模式\n在命令模式中，直接按ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ← →方向键来选中需要复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴\n\n退出可视模式按下Esc\n\n2）可视化模式复制操作\n第一步：在命令模式下，直接按小v，进入可视化模式\n\n第二步：使用方向键↑ ↓ ← →选择要复制的内容，然后按y键\n\n第三步：移动光标，停在需要粘贴的位置，按p键进行粘贴操作\n\n3）为配置文件添加#多行注释（!）\n第一步：按Esc退出到命令模式，按gg切换到第1行\n\n第二步：然后按Ctrl+v进入到可视化区块模式（列模式）\n\n第三步：在行首使用上下键选择需要注释的多行\n\n第四步：按下键盘（大写）“I”键，进入插入模式（Shift + i）\n\n第五步：输入#号注释符\n\n第六步：输入完成后，连续按两次Esc即可完成添加多行注释的过程\n\n4）为配置文件去除#多行注释（!）\n第一步：按Esc退出到命令模式，按gg切换到第1行\n\n第二步：然后按Ctrl+v进入可视化区块模式（列模式）\n\n第三步：使用键盘上的方向键的上下选中需要移除的#号注释\n\n第四步：直接按Delete键即可完成删除注释的操作\n\n# 22.chmod命令\n\nchmod命令由于修改文件或者目录的权限\n\n\n\n##  选项\n\n```shell\n-c, --changes：当文件的权限更改时输出操作信息。\n--no-preserve-root：不将\'/\'特殊化处理，默认选项。\n--preserve-root：不能在根目录下递归操作。\n-f, --silent, --quiet：抑制多数错误消息的输出。\n-v, --verbose：无论文件是否更改了权限，一律输出操作信息。\n--reference=RFILE：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。\n-R, --recursive：对目录以及目录下的文件递归执行更改权限操作。\n--help：显示帮助信息并退出。\n--version：显示版本信息并退出。\n```\n\n### 1、字母法：\n\nchmod  (u g o a)   (+ - =)   (r w x)   (文件名)\n\n以上是chmod的用法，每个括号是一个参数， 前三个括号主要放在一起使用即 chmod + 设置模式 + 文件名；下面先介绍这些参数的意义：\n\n[u g o a]    含义\nu    user 表示该文件的所有者\ng    group 表示与该文件的所有者属于同一组( group )者，即用户组\no    other 表示其它用户组\na    all 表示这三者皆是\n\n[+  -  =]    含义\n\n+    增加权限\n\n-    撤销权限\n-    =    设定权限\n\n[r   w   x]    含义\nr    read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。\nw    write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。\nx    excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。\n\n用法：chmod + 设置模式 + 文件名\n中间的设置模式，要分别对u(user), g(group), o(other)设置权限。\n\nchmod u+rwx, g+rwx, o+rwx filename 改命令说明对filename文件， 赋予user、group、other均有read、write、excute的权限\n\n## 例子\n\n> 参考`man chmod`文档的`DESCRIPTION`段落得知：\n>\n> - `u`符号代表当前用户。\n> - `g`符号代表和当前用户在同一个组的用户，以下简称组用户。\n> - `o`符号代表其他用户。\n> - `a`符号代表所有用户。\n> - `r`符号代表读权限以及八进制数`4`。\n> - `w`符号代表写权限以及八进制数`2`。\n> - `x`符号代表执行权限以及八进制数`1`。\n> - `X`符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限。\n> - `s`符号代表设置权限suid和sgid，使用权限组合`u+s`设定文件的用户的ID位，`g+s`设置组用户ID位。\n> - `t`符号代表只有目录或文件的所有者才可以删除目录下的文件。\n> - `+`符号代表添加目标用户相应的权限。\n> - `-`符号代表删除目标用户相应的权限。\n> - `=`符号代表添加目标用户相应的权限，删除未提到的权限。\n\n```shell\nlinux文件的用户权限说明：\n\n# 查看当前目录（包含隐藏文件）的长格式。\nls -la\n  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules\n\n# 第1位如果是d则代表目录，是-则代表普通文件。\n# 更多详情请参阅info coreutils \'ls invocation\'（ls命令的info文档）的\'-l\'选项部分。\n# 第2到4位代表当前用户的权限。\n# 第5到7位代表组用户的权限。\n# 第8到10位代表其他用户的权限。\n\n# 添加组用户的写权限。\nchmod g+w ./test.log\n# 删除其他用户的所有权限。\nchmod o= ./test.log\n# 使得所有用户都没有写权限。\nchmod a-w ./test.log\n# 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。\nchmod u=rwx, g=rw, o=r ./test.log\n# 等价的八进制数表示：\nchmod 764 ./test.log\n# 将目录以及目录下的文件都设置为所有用户拥有读写权限。\n# 注意，使用\'-R\'选项一定要保留当前用户的执行和读取权限，否则会报错！\nchmod -R a=rw ./testdir/\n# 根据其他文件的权限设置文件权限。\nchmod --reference=./1.log  ./test.log\n```\n\n\n\n### 2、数字法\n\n数字法是基于字母法的表示，如果字母法懂了，数字法就好懂，并且易于使用。\n\n用法：chmod + 数字组合 + 文件名\n数字组合一般包含三个数字：\n\nr  (read)     ---------------->   4\n\nw (write)    ---------------->   2\n\nx (excute)  ---------------->   1\n\n详解：\n\n第一个数字7：代表用户 u 的权限 rwx， 4 (r) + 2 (w) + 1 (x) =  7\n\n第二个数字7：代表用户 g 的权限 rwx,    4 (r) + 2 (w) + 1 (x) =  7\n\n第三个数字7：代表用户 o 的权限 rwx,    4 (r) + 2 (w) + 1 (x) =  7\n\n### 举例说明：\n\n数字法：chmod  755 filename    对应    字母法： chmod u+rwx, g+rx, o+rx filename\n数字法：chmod  751 filename    对应    字母法： chmod u+rwx, g+rx, o+x  filename\n\n## 补充\n\ndrwxr-xr-x. 	2	 			root				 root	   98	   				May 1 09:57 	Documents\n\n-rw-------. 	1	 				root	 			root 	1720 					Apr 6 01:38 	anaconda-ks.cfg\n\n文件权限     硬链接个数  创建者     创建者所在的组   字节数    最后修改日期      文件名称\n\n第一位 为  ‘-’ 表示为文件       \n\n第一位 为  ‘d’ 表示为文件夹\n\n第一位 为  ‘l’ 表示为链接文件       \n\n# 23.chown命令\n\n用来变更文件或目录的拥有者或所属群组\n\n## 补充说明\n\n**chown命令** 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。\n\n只有文件主和超级用户才可以便用该命令。\n\n### 语法\n\n```shell\nchown(选项)(参数)\n```\n\n### 选项\n\n```shell\n-c或——changes：效果类似“-v”参数，但仅回报更改的部分；\n-f或--quite或——silent：不显示错误信息；\n-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；\n-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\n-v或——version：显示指令执行过程；\n--dereference：效果和“-h”参数相同；\n--help：在线帮助；\n--reference=<参考文件或目录>：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；\n--version：显示版本信息。\n```\n\n### 参数\n\n用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者；\n文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。\n\n### 实例\n\n将目录`name.txt`文件的文件主改成 CHY：\n\n```shell\nchown CHY name.txt \n```\n\n\n\n将目录`/usr/meng`及其下面的所有文件、子目录的文件主改成 liu：\n\n```shell\nchown -R liu /usr/meng\n```\n\n# 24.shell编程\n\n## 两种方式执行shell脚本\n\n第一种：给文件增加执行权限\n\n[root@localhost ~]$ chmod u+x test.sh\n[root@localhost ~]$ ./test.sh  #绝对路径或相对路径执行\n第二种（了解）：通过Bash调用执行脚本\n\n[root@localhost ~]$ bash test.sh\n\n## 变量的命名规则\n\n在定义变量时，有一些规则需要遵守:\n\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n等号左右两侧不能有空格，可以使用下划线“_”，变量的值如果有空格，需要使用单引号或双引号包括。如:“test=“hello world!””。其中双引号括起来的内容“$”，“(”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。\n不能使用标点符号，不能使用bash里的关键字（可用help命令查看保留关键字）。\n环境变量建议大写，便于区分\n如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含\"$变量名\"或用${变量名}包含变量名。\n[root@localhost ~]$ test=123\n[root@localhost ~]$ test=\"$test\"456\n[root@localhost ~]$ echo $test\n123456\n#叠加变量test，变量值变成了123456\n[root@localhost ~]$ test=${test}789\n[root@localhost ~]$ echo $test\n123456789\n#再叠加变量test，变量值编程了123456789\n关于单双引号的问题：\n双引号能够识别变量，双引号能够实现转义（类似于“\\*”）\n单引号是不能识别变量，只会原样输出，单引号是不能转义的\n\n## shell中特殊符号\n\n符号	作用\n’ ’	单引号。在单引号中所有的特殊符号，如“$”和”(反引号)都没有特殊含义。单引号括起来的都是普通字符，***会原样输出***\n“ ”	双引号。在双引号中特殊符号都没有特殊含义，但是“$”，“`”（esc键下面）和“\\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。\n· ·	反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和( ) 作 用 一 样 ， 不过推荐使用()，因为反引号非常容易看错。\n$()	和反引号作用一样，用来引用系统命令。(推荐使用)\n()	用于一串命令执行时，()中的命令会在子Shell中运行\n{}	用于一串命令执行时，{ }中的命令会在当前Shell中执行。也可以用于变量变形与替换。\n[ ]	用于变量的测试。\n\n在Shell脚本中，#开头的行代表注释。\n\n$	用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。\n\\	转义符，跟在\\之后的特殊符号将失去特殊含义，变为普通字符。如$将输出“$”符号，而不当做是变量引用。\n\n## 单引号和双引号\n\n[root@localhost ~]$ name=sc\n#定义变量name 的值是sc\n[root@localhost ~]$ echo \'$name\'\n$name\n#如果输出时使用单引号，则$name原封不动的输出\n[root@localhost ~]$ echo \"$name\"\nsc\n#如果输出时使用双引号，则会输出变量name的值 sc\n\n[root@localhost ~]$ echo `date`\n2018年10月21日星期一18:16:33 CST\n#反引号括起来的命令会正常执行\n[root@localhost ~]$ echo \'`date`\'\n`date`\n#但是如果反引号命令被单引号括起来，那么这个命令不会执行，―date`会被当成普通字符输出\n[root@localhost ~]$ echo \"`date\'\"\n2018年10月21日星期一18:14:21 CST\n#如果是双引号括起来，那么这个命令又会正常执行\n反引号\n\n[root@localhost ~]$ echo ls\nls\n#如果命令不用反引号包含，命令不会执行，而是直接输出\n[root@localhost ~]$ echo `ls`\nanaconda-ks.cfginstall.loginstall.log.syslog sh test testfile\n#只有用反引号包括命令，这个命令才会执行\n[root@localhost ~]$ echo $(date)\n2018年10月21日星期一18:25:09 CST\n#使用$(命令)的方式也是可以的\n\n## 变量操作\n\n创建普通变量：name=“test”，组要注意的是等号两边不能有空格。\n创建局部变量：local name=“test”，使用local修饰的变量在函数体外无法访问，只能在函数体中使用。\n创建只读变量：name=“only_read” -> readonly name，这种变量不可以被修改。\n使用变量：echo $name或者echo ${name}\n删除变量：unset name，删除之后的变量无法被访问，需要注意无法删除只读变量。\n3.1.3 字符串变量\n3.1.3.1 字符串变量的创建\n使用单引号创建：var=\'test\'。\n这种方式创建的变量只能原样输出，变量无效，我们可以借用c中的“字符串常量”的定义理解这种特性。除此以外，单引号中不能出现单独的单引号，转义也是不可以的。\n使用双引号创建：var=\"my name is ${name}\"，这种方式创建的字符串变量有效，也可以出现转义符。\n3.1.3.2 拼接字符串\n字面量拼接\nstr01=\"1\"\"2\"或者str01=\"1\"\'2\'，这样就将1和2两个字符拼接在了一起。需要注意的是两个串之间不可以有空格。\n变量拼接\nstr03=${part01}${part02}或str04=${part01}\"end\"或str05=\"${part01} ${part02}\"这三种方式都可以拼接字符串变量。\n命令拼接\nstr02= date“end”，这里的date是一个shell命令，需要使用引用，具体如下 \n\n# 25.wc命令\n\n统计文件的字节数、字数、行数\n\n## 补充说明\n\n**wc命令** 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。\n\n### 语法\n\n```shell\nwc(选项)(参数)\nwc [选项]... [文件]...\nwc [选项]... --files0-from=F\n```\n\n### 选项\n\n```shell\n-c # 统计字节数，或--bytes：显示Bytes数。\n-l # 统计行数，或--lines：显示列数。\n-m # 统计字符数，或--chars：显示字符数。\n-w # 统计字数，或--words：显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。\n-L # 打印最长行的长度，或--max-line-length。\n-help     # 显示帮助信息。\n--version # 显示版本信息。\n```\n\n### 参数\n\n文件：需要统计的文件列表。\n\n## 例子\n\n```shell\nwc -l *       # 统计当前目录下的所有文件行数及总计行数。\nwc -l *.js    # 统计当前目录下的所有 .js 后缀的文件行数及总计行数。\nfind  . * | xargs wc -l # 当前目录以及子目录的所有文件行数及总计行数。\n```\n\n查看文件的行数、单词数、字节数\n\n```shell\nwc test.txt\n# 输出结果\n7     8     70     test.txt\n# 行数 单词数 字节数 文件名\n```\n\n用wc命令怎么做到只打印统计数字不打印文件名\n\n```shell\nwc -l < test.txt\n# 输出结果\n7\n```\n\n用来统计当前目录下的文件数(不包含隐藏文件)\n\n```shell\n# 要去除TOTAL行\nexpr $(ls -l | wc -l) - 1\n# 输出结果\n```\n\n# 26.groupadd命令\n\n用于创建一个新的工作组\n\n## 补充说明\n\n**groupadd命令** 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。\n\n### 语法\n\n```shell\ngroupadd(选项)(参数)\n```\n\n### 选项\n\n```shell\n-g：指定新建工作组的id；\n-r：创建系统工作组，系统工作组的组ID小于500；\n-K：覆盖配置文件“/ect/login.defs”；\n-o：允许添加组ID号不唯一的工作组。\n```\n\n### 参数\n\n组名：指定新建工作组的组名。\n\n### 实例\n\n建立一个新组，并设置组ID加入系统：\n\n```shell\ngroupadd -g 344 jsdigname\n```\n\n此时在`/etc/passwd`文件中产生一个组ID（GID）是344的项目。\n\n# 27.groupdel命令\n\n用于删除指定的工作组\n\n## 补充说明\n\n**groupdel命令** 用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。\n\n### 语法\n\n```shell\ngroupdel(参数)\n```\n\n### 参数\n\n组：要删除的工作组名。\n\n### 实例\n\n```shell\ngroupadd damon  //创建damon工作组\ngroupdel damon  //删除这个工作组\n```\n\n# 28.useradd命令\n\n创建的新的系统用户\n\n## 补充说明\n\n**useradd命令** 用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在`/etc/passwd`文本文件中。\n\n在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd命令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中， **adduser命令** 则是useradd命令的符号连接，两者实际上是同一个指令。\n\n### 语法\n\n```shell\nuseradd(选项)(参数)\n```\n\n### 选项\n\n```shell\n-c<备注>：加上备注文字。备注文字会保存在passwd的备注栏位中；\n-d<登入目录>：指定用户登入时的启始目录；\n-D：变更预设值；\n-e<有效期限>：指定帐号的有效期限；\n-f<缓冲天数>：指定在密码过期后多少天即关闭该帐号；\n-g<群组>：指定用户所属的群组；\n-G<群组>：指定用户所属的附加群组；\n-m：自动建立用户的登入目录；\n-M：不要自动建立用户的登入目录；\n-n：取消建立以用户名称为名的群组；\n-r：建立系统帐号；\n-s<shell>：指定用户登入后所使用的shell；\n-u<uid>：指定用户id。\n```\n\n### 参数\n\n用户名：要创建的用户名。\n\n### 实例\n\n新建用户加入组：\n\n```shell\nuseradd –g sales jack –G company,employees    //-g：加入主要组、-G：加入次要组\n```\n\n建立一个新用户账户，并设置ID：\n\n```shell\nuseradd caojh -u 544\n```\n\n需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。\n\n# 29.userdel命令\n\n用于删除给定的用户以及与用户相关的文件\n\n## 补充说明\n\n**userdel命令** 用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。\n\n### 语法\n\n```shell\nuserdel(选项)(参数)\n```\n\n### 选项\n\n```shell\n-f：强制删除用户，即使用户当前已登录；\n-r：删除用户的同时，删除与用户相关的所有文件。\n```\n\n### 参数\n\n用户名：要删除的用户名。\n\n### 实例\n\nuserdel命令很简单，比如我们现在有个用户linuxde，其家目录位于`/var`目录中，现在我们来删除这个用户：\n\n```shell\nuserdel linuxde       # 删除用户linuxde，但不删除其家目录及文件；\nuserdel -r linuxde    # 删除用户linuxde，其家目录及文件一并删除；\n```\n\n请不要轻易用`-r`选项；他会删除用户的同时删除用户所有的文件和目录，切记如果用户目录下有重要的文件，在删除前请备份。\n\n其实也有最简单的办法，但这种办法有点不安全，也就是直接在`/etc/passwd`中删除您想要删除用户的记录；但最好不要这样做，`/etc/passwd`是极为重要的文件，可能您一不小心会操作失误。\n\n# 30.usermod命令\n\n用于修改用户的基本信息\n\n## 补充说明\n\n**usermod命令** 用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在server上更动相关的NIS设定。\n\n### 语法\n\n```shell\nusermod(选项)(参数)\n```\n\n### 选项\n\n```shell\n-c<备注>：修改用户帐号的备注文字；\n-d<登入目录>：修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用；\n-m<移动用户家目录>:移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。\n-e<有效期限>：修改帐号的有效期限；\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\n-g<群组>：修改用户所属的群组；\n-G<群组>；修改用户所属的附加群组；\n-l<帐号名称>：修改用户帐号名称；\n-L：锁定用户密码，使密码无效；\n-s<shell>：修改用户登入后所使用的shell；\n-u<uid>：修改用户ID；\n-U:解除密码锁定。\n```\n\n### 参数\n\n登录名：指定要修改信息的用户登录名。\n\n### 实例\n\n将 newuser2 添加到组 staff 中：\n\n```shell\nusermod -G staff newuser2\n```\n\n修改newuser的用户名为newuser1：\n\n```shell\nusermod -l newuser1 newuser\n```\n\n锁定账号newuser1：\n\n```shell\nusermod -L newuser1\n```\n\n解除对newuser1的锁定：\n\n```shell\nusermod -U newuser1\n```\n\n增加用户到用户组中:\n\n```shell\napk add shadow # 安装 shadow 包, usermod 命令包含在 usermod 中\nusermod -aG group user # 添加用户到用户组中\n```\n\n`-a` 参数表示附加，只和 `-G` 参数一同使用，表示将用户增加到组中。\n\n修改用户家目录：\n\n```\n[root@node-1 ~]# useradd lutixiaya\n[root@node-1 ~]# ls /home\nlutixiaya\n[root@node-1 ~]# usermod -md /data/new_home lutixiaya\n[root@node-1 ~]# ls /home/\n[root@node-1 ~]# ls /data/\nnew_home\n```\n\n# 31.getent命令\n\ngetent   passwd   查看系统中的用户    和   cat /etc/passwd  效果一样\n\n用户名：密码（X）：用户ID： 组ID：描述信息（无用）：Home目录：执行终端（默认为bash）\n\ngetent group   查询 系统中的组信息    和   cat /etc/group  效果一样\n\n组名称：组的认证（X）：组ID\n\n\n\n# 32.条件判断\n\n## 整数判断\n\n常用参数：\n判断参数	含义\n-eq ==	相等\n-ne <> !=	不等\n-gt	大于\n-lt	小于\n-ge	大于等于\n-le	小于等于\n\n## 字符串判断\n\n常用参数：\n判断参数	含义\n-z	判断是否为空字符串，字符串长度为0则成立\n-n	判断是否为非空字符串，字符串长度不为0则成立\nstring1 = string2	判断字符串是否相等\nstring1 != string2	判断字符串是否相不等\n\n## 文件类型判断\n\n常用参数：\n判断参数	含义	说明\n-e	判断文件是否存在（link文件指向的也必须存在）	exists\n-f	判断文件是否存在并且是一个普通文件	file\n-d	判断文件是否存在并且是一个目录	directory\n-L	判断文件是否存在并且是一个软连接文件	soft link\n-b	判断文件是否存在并且是一个块设备文件	block\n-S	判断文件是否存在并且是一个套接字文件	socket\n-c	判断文件是否存在并且是一个字符设备文件	char\n-p	判断文件是否存在并且是一个命名管道文件	pipe\n\n###### ***-s	判断文件是否存在并且是一个非空文件（有内容）	is not empty***\n\n文件内容是否为空的判断\n\n## 文件权限判断\n\n常用参数：\n判断参数	含义\n-r	当前用户对其是否可读\n-w	当前用户对其是否可写\n-x	当前用户对其是否可执行\n-u	是否有suid，高级权限冒险位\n-g	是否sgid，高级权限强制位\n-k	是否有t位，高级权限粘滞位 (创建者/root才能删除)\n\n## 文件新旧判断\n\n常用参数：\n说明：这里的新旧指的是文件的修改时间。\n判断参数	含义\nfile1 -nt file2	比较file1是否比file2新\nfile1 -ot file2	比较file1是否比file2旧\nfile1 -ef file2	比较是否为同一个文件，或者用于判断硬连接，是否指向同一个inode', 0, 0, 0, 1, 1, NULL, NULL, '2023-11-01 18:14:42', '2023-11-01 19:17:03');
INSERT INTO `t_article` VALUES (138, 1024, 222, 'http://192.168.188.128:9000/aurora/aurora/articles/4183a275d4e77860cc96a2ac14b2a03f.jpg', 'redis常用命令', '', '# **redis 常用命令**\n\n### **服务器相关命令**\n\nping ： 检测连接是否存活\necho： 在命令行打印一些内容\nquit、exit： 退出客户端\nshutdown： 退出服务器端\ninfo： 返回redis相关信息\nconfig get dir/* 实时传递接收的请求\nshowlog： 显示慢查询\nselect n： 切换到数据库n，redis默认有16个数据库（DB 0~DB 15），默认使用的第0个\ndbsize： 查看当前数据库大小\nmove key n： 不同数据库之间数据是不能互通的，move移动键到指定数据库\nflushdb： 清空当前数据库中的键值对。\nflushall： 清空所有数据库的键值对。\n\n### **key相关命令**\n\n在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。\n\n常用命令：\n\nkeys * ：查看当前数据库中所有的key\ndbsize： 键总数\nexists key： 检查键是否存在\ndel key [key …]： 删除键\nexpire key seconds： 键过期\nttl key： 获取键的有效时长\npersist key： 移除键的过期时间\ntype key： 键的数据结构类型\nrandomkey： 随机返回数据库中一个键\nrename key1 key2 ： 重命名\nrenamex key1 key2 ： 当key2不存在时，key1重命名\n\n### **五大数据类型**\n\nRedis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。其通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：\n\n字符串类型： string\n哈希类型： hash\n列表类型： list\n集合类型： set\n有序集合类型： sortedset（zset）\n\n### **String(字符串)**\n\n字符串类型是Redis最基础的数据结构，其它的几种数据结构都是在字符串类型基础上构建的，字符串的值可以是：字符串、数字、二进制，但其值最大不能超过512M。\n\n使用场景： 缓存、计数器、对象存储缓存（共享session）、限速\n\n常用命令：\n\nset key value： 设置一个key的value值\nsetnx key value： 仅当key不存在时进行set\nsetex key seconds value： set 键值对并设置过期时间\nmset key value [key value …]： 设置多个key value\nmsetnx key1 value1 [key2 value2…]： 批量设置键值对，仅当参数中所有的key都不存在时执行，原子性操作，一起成功，一起失败\nget key： 返回key的value\nmget key [key …] ： 批量获取多个key保存的值\nexists key [key …]： 查询一个key是否存在\ndecr/incr key： 将指定key的value数值进行+1/-1(仅对于数字)\nincrby/decrbyB key n： 按指定的步长对数值进行加减\nincrbyfloat key n： 为数值加上浮点型数值\nappend key value： 向指定的key的value后追加字符串\nstrlen key： 返回key的string类型value的长度。\ngetset key value： 设置一个key的value，并获取设置前的值，如果不存在则返回null\nsetrange key offset value： 设置指定位置的字符\ngetrange key start end： 获取存储在key上的值的一个子字符串\n\n### **Hash（哈希）**\n\n几乎所有的编程语言都提供了哈希（hash）结构，Redis中 hash 是一个string类型的field和value的映射表value={{field1,value1},{field2,value2}…}，可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。\n\n应用场景： 用户信息缓存\n\n常用命令：\n\nhset key field value： 将哈希表 key 中的字段 field 的值设为 value。重复设置同一个field会覆盖,返回0\nhmset key field1 value1 [field2 value2…]： 同时将多个 field-value (域-值)对设置到哈希表 key 中。\nhsetnx key field value： 只有在字段 field不存在时，设置哈希表字段的值。\nhget key field value： 获取存储在哈希表中指定字段的值\nhmget key field1 [field2…]： 获取所有给定字段的值\nhexists key field： 查看哈希表 key 中，指定的字段是否存在。\nhdel key field1 [field2…]： 删除哈希表key中一个/多个field字段\nhlen key： 获取哈希表中字段的数量\nhkeys key： 获取所有字段field\nhvals key： 获取哈希表中所有值value\nhgetall key： 获取在哈希表key 的所有字段和值\nhincrby key field n： 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段\nhincrbyfloat key field n： 为哈希表 key 中的指定字段的浮点数值加上增量 n。\nhscan key cursor [MATCH pattern] [COUNT count]： 迭代哈希表中的键值对。\n\n### **List(列表)**\n\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），也可以获取指定范围指定下标的元素等。一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\n\n两个特点：\n1.列表中的元素是有序的，可以通过索引下标获取某个元素霍某个某个范围内的元素列表\n2.列表中的元素可以是重复的\n\n使用场景： 消息队列、栈、文章列表等。\n\n常用指令：\n\n添加操作\nlpush/rpush key value1[value2…]： 从左边/右边向列表中PUSH值(一个或者多个)\nlpushx/rpushx key value： 向已存在的列名中push值（一个或者多个），list不存在 lpushx失败\nlinsert key before|after pivot value： 在指定列表元素的前/后 插入value\n查找操作\nlindex key index： 通过索引获取列表元素\nlrange key start end： 获取list 起止元素 （索引从左往右 递增）\nllen key： 查看列表长度\n删除操作\nlpop/rpop key： 从最左边/最右边移除值 并返回\nlrem key count value： count >0：从头部开始搜索 然后删除指定的value 至多删除count个 count < 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。\nltrim key start end： 通过下标截取指定范围内的列表\nrpoplpush source destination： 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部\n修改操作\nlset key index value： 通过索引为元素设值\n阻塞操作\nblpop/brpop key1[key2] timout： 移出并获取列表的第一个/最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nbrpoplpush source destination timeout： 和rpoplpush功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n### **Set(集合）**\n\nRedis的Set是string类型的无序集合，我们不能通过索引获取元素。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n\n应用场景： 标签（tag）\n\n常用命令：\n\n集合内操作\nsadd key member1[member2…]： 向集合中无序增加一个/多个成员\nsrem key member1[member2…]： 移除集合中一个/多个成员\nscard key： 获取集合的成员数\nsmembers key： 返回集合中所有的成员\nsismember key member： 查询member元素是否是集合的成员，若存在返回1，不存在返回0\nsrandmember key [count]： 随机返回集合中count个成员，count缺省值为1\nspop key [count]： 随机移除并返回集合中count个成员，count缺省值为1\n集合间操作\nsinter key1 [key2…]： 返回所有集合的交集\nsinterstore destination key1[key2…]： 在SINTER的基础上，存储结果到集合中。覆盖\nsunion key1 [key2…]： 返回所有集合的并集\nsunionstore destination key1 [key2…]： 在SUNION的基础上，存储结果到及和张。覆盖\nsdiff key1[key2…]： 返回所有集合的差集 key1- key2 - …\nsdiffstore destination key1[key2…]： 在SDIFF的基础上，将结果保存到集合中。覆盖\nsmove source destination member： 将source集合的成员member移动到destination集合\nsscan key [MATCH pattern] [COUNT count]： 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分\n\n\n\n### **Zset（有序集合）**\n\n在有序集合中保留了不能有重复成员的特性，但其中的成员是可以排序的，每一个元素都会关联一个double类型的分数（score）作为排序依据，score相同时按字典顺序排序。redis正是通过分数来为集合中的成员进行从小到大的排序。\n\n应用场景： 排行榜系统，成绩单，工资表\n\n常用命令：\n\n集合内\nzadd key score member1 [score2 member2]： 向有序集合添加一个或多个成员，或者更新已存在成员的分数\nzcard key： 获取有序集合的成员数\nzscore key member： 返回有序集中，成员的分数值\nzcount key min max： 计算在有序集合中指定区间score的成员数\nzlexcount key min max： 在有序集合中计算指定字典区间内成员数量\nzincrby key n member： 有序集合中对指定成员的分数加上增量 n\nzscan key cursor [MATCH pattern] [COUNT count]： 迭代有序集合中的元素（包括元素成员和元素分值）\n范围查询\nzrank key member： 返回有序集合中指定成员的索引\nzrevrank key member： 返回有序集合中指定成员的索引，从大到小排序\nzrange key start end： 通过索引区间返回有序集合成指定区间内的成员\nzrevrange key start end： 通过索引区间返回有序集合成指定区间内的成员，分数从高到底\nzrangebylex key min max： 通过字典区间返回有序集合的成员\nzrevrangebylex key max min： 按字典顺序倒序返回有序集合的成员\nzrangebyscore key min max： 返回有序集中指定分数区间内的成员 -inf 和 +inf分别表示最小最大值，只支持开区间\nzrevrangebyscore key max min： 返回有序集中指定分数区间内的成员，分数从高到低排序\n删除操作\nzrem key member1 [member2…]： 移除有序集合中一个/多个成员\nzremrangebylex key min max： 移除有序集合中给定的字典区间的所有成员\nzremrangebyrank key start stop： 移除有序集合中给定的排名区间的所有成员\nzremrangebyscore key min max： 移除有序集合中给定的分数区间的所有成员\n集合间操作\nzinterstore destination numkeyskey1 [key2 …]： 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score\nzunionstore destination numkeys key1 [key2…]： 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中', 0, 0, 0, 1, 1, NULL, NULL, '2023-11-01 18:22:53', NULL);

-- ----------------------------
-- Table structure for t_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag`;
CREATE TABLE `t_article_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `article_id` int NOT NULL COMMENT '文章id',
  `tag_id` int NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_article_tag_1`(`article_id` ASC) USING BTREE,
  INDEX `fk_article_tag_2`(`tag_id` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 95 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_tag
-- ----------------------------
INSERT INTO `t_article_tag` VALUES (88, 136, 41);
INSERT INTO `t_article_tag` VALUES (90, 138, 41);
INSERT INTO `t_article_tag` VALUES (91, 137, 42);
INSERT INTO `t_article_tag` VALUES (94, 135, 41);

-- ----------------------------
-- Table structure for t_category
-- ----------------------------
DROP TABLE IF EXISTS `t_category`;
CREATE TABLE `t_category`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `category_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '分类名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 223 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_category
-- ----------------------------
INSERT INTO `t_category` VALUES (217, 'spring', '2023-11-01 17:59:43', NULL);
INSERT INTO `t_category` VALUES (218, 'rabbitMQ', '2023-11-01 18:00:01', NULL);
INSERT INTO `t_category` VALUES (219, '算法', '2023-11-01 18:07:16', NULL);
INSERT INTO `t_category` VALUES (220, 'docker', '2023-11-01 18:07:27', NULL);
INSERT INTO `t_category` VALUES (221, 'linux', '2023-11-01 18:12:58', NULL);
INSERT INTO `t_category` VALUES (222, 'redis', '2023-11-01 18:21:54', NULL);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` int NOT NULL COMMENT '评论用户Id',
  `topic_id` int NULL DEFAULT NULL COMMENT '评论主题id',
  `comment_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  `reply_user_id` int NULL DEFAULT NULL COMMENT '回复用户id',
  `parent_id` int NULL DEFAULT NULL COMMENT '父评论id',
  `type` tinyint NOT NULL COMMENT '评论类型 1.文章 2.留言 3.关于我 4.友链 5.说说',
  `is_delete` tinyint NOT NULL DEFAULT 0 COMMENT '是否删除  0否 1是',
  `is_review` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否审核',
  `create_time` datetime NOT NULL COMMENT '评论时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_comment_user`(`user_id` ASC) USING BTREE,
  INDEX `fk_comment_parent`(`parent_id` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1033 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (1032, 1024, NULL, '测试', NULL, NULL, 3, 0, 1, '2023-11-01 17:03:53', NULL);

-- ----------------------------
-- Table structure for t_exception_log
-- ----------------------------
DROP TABLE IF EXISTS `t_exception_log`;
CREATE TABLE `t_exception_log`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `opt_uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求接口',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求方式',
  `request_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求方式',
  `request_param` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求参数',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作描述',
  `exception_info` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '异常信息',
  `ip_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime NOT NULL COMMENT '操作时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_exception_log
-- ----------------------------
INSERT INTO `t_exception_log` VALUES (1, '/users/register', 'com.blog.controller.UserAuthController.register', 'POST', '[{\"code\":\"124699 \",\"password\":\"chy211985\",\"username\":\"3319023171@qq.com\"}]', '用户注册', 'com.blog.exception.BizException: 验证码错误！\r\n	at com.blog.service.impl.UserAuthServiceImpl.checkUser(UserAuthServiceImpl.java:198)\r\n	at com.blog.service.impl.UserAuthServiceImpl.register(UserAuthServiceImpl.java:124)\r\n	at com.blog.service.impl.UserAuthServiceImpl$$FastClassBySpringCGLIB$$be1c91ee.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:367)\r\n	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.service.impl.UserAuthServiceImpl$$EnhancerBySpringCGLIB$$1436cfa5.register(<generated>)\r\n	at com.blog.controller.UserAuthController.register(UserAuthController.java:51)\r\n	at com.blog.controller.UserAuthController$$FastClassBySpringCGLIB$$e98e9e00.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserAuthController$$EnhancerBySpringCGLIB$$70e157b0.register(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-10-24 20:08:59');
INSERT INTO `t_exception_log` VALUES (2, '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', 'POST', 'file', '更新用户头像', 'com.blog.exception.BizException: 文件上传失败\r\n	at com.blog.strategy.impl.AbstractUploadStrategyImpl.uploadFile(AbstractUploadStrategyImpl.java:26)\r\n	at com.blog.strategy.context.UploadStrategyContext.executeUploadStrategy(UploadStrategyContext.java:24)\r\n	at com.blog.service.impl.UserInfoServiceImpl.updateUserAvatar(UserInfoServiceImpl.java:74)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$FastClassBySpringCGLIB$$8a988b28.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$EnhancerBySpringCGLIB$$c33c322a.updateUserAvatar(<generated>)\r\n	at com.blog.controller.UserInfoController.updateUserAvatar(UserInfoController.java:46)\r\n	at com.blog.controller.UserInfoController$$FastClassBySpringCGLIB$$19719586.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserInfoController$$EnhancerBySpringCGLIB$$8abd5581.updateUserAvatar(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 13:54:12');
INSERT INTO `t_exception_log` VALUES (3, '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', 'POST', 'file', '更新用户头像', 'com.blog.exception.BizException: 文件上传失败\r\n	at com.blog.strategy.impl.AbstractUploadStrategyImpl.uploadFile(AbstractUploadStrategyImpl.java:26)\r\n	at com.blog.strategy.context.UploadStrategyContext.executeUploadStrategy(UploadStrategyContext.java:24)\r\n	at com.blog.service.impl.UserInfoServiceImpl.updateUserAvatar(UserInfoServiceImpl.java:74)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$FastClassBySpringCGLIB$$8a988b28.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$EnhancerBySpringCGLIB$$57ab4f93.updateUserAvatar(<generated>)\r\n	at com.blog.controller.UserInfoController.updateUserAvatar(UserInfoController.java:46)\r\n	at com.blog.controller.UserInfoController$$FastClassBySpringCGLIB$$19719586.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserInfoController$$EnhancerBySpringCGLIB$$76d8de8e.updateUserAvatar(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 13:56:20');
INSERT INTO `t_exception_log` VALUES (4, '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', 'POST', 'file', '更新用户头像', 'com.blog.exception.BizException: 文件上传失败\r\n	at com.blog.strategy.impl.AbstractUploadStrategyImpl.uploadFile(AbstractUploadStrategyImpl.java:26)\r\n	at com.blog.strategy.context.UploadStrategyContext.executeUploadStrategy(UploadStrategyContext.java:24)\r\n	at com.blog.service.impl.UserInfoServiceImpl.updateUserAvatar(UserInfoServiceImpl.java:74)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$FastClassBySpringCGLIB$$8a988b28.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$EnhancerBySpringCGLIB$$57ab4f93.updateUserAvatar(<generated>)\r\n	at com.blog.controller.UserInfoController.updateUserAvatar(UserInfoController.java:46)\r\n	at com.blog.controller.UserInfoController$$FastClassBySpringCGLIB$$19719586.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserInfoController$$EnhancerBySpringCGLIB$$57e0d628.updateUserAvatar(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:05:29');
INSERT INTO `t_exception_log` VALUES (5, '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', 'POST', 'file', '更新用户头像', 'com.blog.exception.BizException: 文件上传失败\r\n	at com.blog.strategy.impl.AbstractUploadStrategyImpl.uploadFile(AbstractUploadStrategyImpl.java:26)\r\n	at com.blog.strategy.context.UploadStrategyContext.executeUploadStrategy(UploadStrategyContext.java:24)\r\n	at com.blog.service.impl.UserInfoServiceImpl.updateUserAvatar(UserInfoServiceImpl.java:74)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$FastClassBySpringCGLIB$$8a988b28.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$EnhancerBySpringCGLIB$$b2cdccf0.updateUserAvatar(<generated>)\r\n	at com.blog.controller.UserInfoController.updateUserAvatar(UserInfoController.java:46)\r\n	at com.blog.controller.UserInfoController$$FastClassBySpringCGLIB$$19719586.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserInfoController$$EnhancerBySpringCGLIB$$3a05703e.updateUserAvatar(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:14:42');
INSERT INTO `t_exception_log` VALUES (6, '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', 'POST', 'file', '更新用户头像', 'com.blog.exception.BizException: 文件上传失败\r\n	at com.blog.strategy.impl.AbstractUploadStrategyImpl.uploadFile(AbstractUploadStrategyImpl.java:26)\r\n	at com.blog.strategy.context.UploadStrategyContext.executeUploadStrategy(UploadStrategyContext.java:24)\r\n	at com.blog.service.impl.UserInfoServiceImpl.updateUserAvatar(UserInfoServiceImpl.java:74)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$FastClassBySpringCGLIB$$8a988b28.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$EnhancerBySpringCGLIB$$96927d06.updateUserAvatar(<generated>)\r\n	at com.blog.controller.UserInfoController.updateUserAvatar(UserInfoController.java:46)\r\n	at com.blog.controller.UserInfoController$$FastClassBySpringCGLIB$$19719586.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserInfoController$$EnhancerBySpringCGLIB$$57e0d628.updateUserAvatar(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:21:17');
INSERT INTO `t_exception_log` VALUES (7, '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', 'POST', 'file', '更新用户头像', 'com.blog.exception.BizException: 文件上传失败\r\n	at com.blog.strategy.impl.AbstractUploadStrategyImpl.uploadFile(AbstractUploadStrategyImpl.java:26)\r\n	at com.blog.strategy.context.UploadStrategyContext.executeUploadStrategy(UploadStrategyContext.java:24)\r\n	at com.blog.service.impl.UserInfoServiceImpl.updateUserAvatar(UserInfoServiceImpl.java:74)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$FastClassBySpringCGLIB$$8a988b28.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.UserInfoServiceImpl$$EnhancerBySpringCGLIB$$96927d06.updateUserAvatar(<generated>)\r\n	at com.blog.controller.UserInfoController.updateUserAvatar(UserInfoController.java:46)\r\n	at com.blog.controller.UserInfoController$$FastClassBySpringCGLIB$$19719586.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserInfoController$$EnhancerBySpringCGLIB$$57e0d628.updateUserAvatar(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:22:21');
INSERT INTO `t_exception_log` VALUES (8, '/users/register', 'com.blog.controller.UserAuthController.register', 'POST', '[{\"code\":\"505937\",\"password\":\"123456\",\"username\":\"test@163.com\"}]', '用户注册', 'com.blog.exception.BizException: 验证码错误！\r\n	at com.blog.service.impl.UserAuthServiceImpl.checkUser(UserAuthServiceImpl.java:198)\r\n	at com.blog.service.impl.UserAuthServiceImpl.register(UserAuthServiceImpl.java:124)\r\n	at com.blog.service.impl.UserAuthServiceImpl$$FastClassBySpringCGLIB$$be1c91ee.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:367)\r\n	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.service.impl.UserAuthServiceImpl$$EnhancerBySpringCGLIB$$aca6b10d.register(<generated>)\r\n	at com.blog.controller.UserAuthController.register(UserAuthController.java:51)\r\n	at com.blog.controller.UserAuthController$$FastClassBySpringCGLIB$$e98e9e00.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserAuthController$$EnhancerBySpringCGLIB$$95b4143c.register(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:26:23');
INSERT INTO `t_exception_log` VALUES (9, '/users/register', 'com.blog.controller.UserAuthController.register', 'POST', '[{\"code\":\"505937\",\"password\":\"123456\",\"username\":\"test@163.com\"}]', '用户注册', 'com.blog.exception.BizException: 验证码错误！\r\n	at com.blog.service.impl.UserAuthServiceImpl.checkUser(UserAuthServiceImpl.java:198)\r\n	at com.blog.service.impl.UserAuthServiceImpl.register(UserAuthServiceImpl.java:124)\r\n	at com.blog.service.impl.UserAuthServiceImpl$$FastClassBySpringCGLIB$$be1c91ee.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:367)\r\n	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.service.impl.UserAuthServiceImpl$$EnhancerBySpringCGLIB$$aca6b10d.register(<generated>)\r\n	at com.blog.controller.UserAuthController.register(UserAuthController.java:51)\r\n	at com.blog.controller.UserAuthController$$FastClassBySpringCGLIB$$e98e9e00.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.UserAuthController$$EnhancerBySpringCGLIB$$95b4143c.register(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:26:32');
INSERT INTO `t_exception_log` VALUES (10, '/admin/roles', 'com.blog.controller.RoleController.deleteRoles', 'DELETE', '[[2]]', '删除角色', 'com.blog.exception.BizException: 该角色下存在用户\r\n	at com.blog.service.impl.RoleServiceImpl.deleteRoles(RoleServiceImpl.java:118)\r\n	at com.blog.service.impl.RoleServiceImpl$$FastClassBySpringCGLIB$$8ef60bab.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.RoleServiceImpl$$EnhancerBySpringCGLIB$$cde430c5.deleteRoles(<generated>)\r\n	at com.blog.controller.RoleController.deleteRoles(RoleController.java:53)\r\n	at com.blog.controller.RoleController$$FastClassBySpringCGLIB$$97fc7f23.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.RoleController$$EnhancerBySpringCGLIB$$9f5b6075.deleteRoles(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doDelete(FrameworkServlet.java:931)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:658)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:54:04');
INSERT INTO `t_exception_log` VALUES (11, '/admin/roles', 'com.blog.controller.RoleController.deleteRoles', 'DELETE', '[[1]]', '删除角色', 'com.blog.exception.BizException: 该角色下存在用户\r\n	at com.blog.service.impl.RoleServiceImpl.deleteRoles(RoleServiceImpl.java:118)\r\n	at com.blog.service.impl.RoleServiceImpl$$FastClassBySpringCGLIB$$8ef60bab.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at com.blog.service.impl.RoleServiceImpl$$EnhancerBySpringCGLIB$$cde430c5.deleteRoles(<generated>)\r\n	at com.blog.controller.RoleController.deleteRoles(RoleController.java:53)\r\n	at com.blog.controller.RoleController$$FastClassBySpringCGLIB$$97fc7f23.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at com.blog.controller.RoleController$$EnhancerBySpringCGLIB$$9f5b6075.deleteRoles(<generated>)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:498)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doDelete(FrameworkServlet.java:931)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:658)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at com.blog.filter.JwtAuthenticationTokenFilter.doFilterInternal(JwtAuthenticationTokenFilter.java:39)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.lang.Thread.run(Thread.java:750)\r\n', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:54:17');

-- ----------------------------
-- Table structure for t_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `t_friend_link`;
CREATE TABLE `t_friend_link`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `link_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接名',
  `link_avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接头像',
  `link_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接地址',
  `link_intro` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '链接介绍',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_friend_link_user`(`link_name` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 47 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_friend_link
-- ----------------------------

-- ----------------------------
-- Table structure for t_job
-- ----------------------------
DROP TABLE IF EXISTS `t_job`;
CREATE TABLE `t_job`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '任务ID',
  `job_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '任务名称',
  `job_group` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'DEFAULT' COMMENT '任务组名',
  `invoke_target` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '调用目标字符串',
  `cron_expression` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT 'cron执行表达式',
  `misfire_policy` tinyint(1) NULL DEFAULT 3 COMMENT '计划执行错误策略（1立即执行 2执行一次 3放弃执行）',
  `concurrent` tinyint(1) NULL DEFAULT 1 COMMENT '是否并发执行（0禁止 1允许）',
  `status` tinyint(1) NULL DEFAULT 0 COMMENT '状态（0暂停 1正常）',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '备注信息',
  PRIMARY KEY (`id`, `job_name`, `job_group`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 86 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '定时任务调度表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_job
-- ----------------------------
INSERT INTO `t_job` VALUES (81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '0 0,30 * * * ?', 3, 1, 1, '2022-08-11 21:49:27', '2022-08-13 08:49:47', '统计用户的地域分布');
INSERT INTO `t_job` VALUES (82, '统计访问量', '默认', 'auroraQuartz.saveUniqueView', '0 0 0 * * ?', 3, 1, 1, '2022-08-12 16:35:11', NULL, '向数据库中写入每天的访问量');
INSERT INTO `t_job` VALUES (83, '清空redis访客记录', '默认', 'auroraQuartz.clear', '0 0 1 * * ?', 3, 1, 1, '2022-08-12 16:36:30', '2022-08-13 08:47:48', '清空redis访客记录');
INSERT INTO `t_job` VALUES (84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '0 0/10 * * * ?', 3, 1, 1, '2022-08-13 21:19:08', '2022-08-19 14:13:52', '百度SEO');
INSERT INTO `t_job` VALUES (85, '清理定时任务日志', '默认', 'auroraQuartz.clearJobLogs', '0 0 0 * * ?', 3, 1, 1, '2022-08-13 21:26:21', NULL, '清理定时任务日志');

-- ----------------------------
-- Table structure for t_job_log
-- ----------------------------
DROP TABLE IF EXISTS `t_job_log`;
CREATE TABLE `t_job_log`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '任务日志ID',
  `job_id` int NOT NULL COMMENT '任务ID',
  `job_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '任务名称',
  `job_group` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '任务组名',
  `invoke_target` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '调用目标字符串',
  `job_message` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '日志信息',
  `status` tinyint(1) NULL DEFAULT 0 COMMENT '执行状态（0正常 1失败）',
  `exception_info` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '异常信息',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `start_time` datetime NULL DEFAULT NULL COMMENT '开始时间',
  `end_time` datetime NULL DEFAULT NULL COMMENT '结束时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6295 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '定时任务调度日志表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_job_log
-- ----------------------------
INSERT INTO `t_job_log` VALUES (6175, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：22毫秒', 1, '', '2023-10-24 19:50:00', '2023-10-24 19:50:00', '2023-10-24 19:50:00');
INSERT INTO `t_job_log` VALUES (6176, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：20毫秒', 1, '', '2023-10-24 20:00:00', '2023-10-24 20:00:00', '2023-10-24 20:00:00');
INSERT INTO `t_job_log` VALUES (6177, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：29毫秒', 1, '', '2023-10-24 20:00:00', '2023-10-24 20:00:00', '2023-10-24 20:00:00');
INSERT INTO `t_job_log` VALUES (6178, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：6毫秒', 1, '', '2023-10-24 20:10:00', '2023-10-24 20:10:00', '2023-10-24 20:10:00');
INSERT INTO `t_job_log` VALUES (6179, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：25毫秒', 1, '', '2023-10-24 21:10:00', '2023-10-24 21:10:00', '2023-10-24 21:10:00');
INSERT INTO `t_job_log` VALUES (6180, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：91毫秒', 1, '', '2023-10-24 21:20:00', '2023-10-24 21:20:00', '2023-10-24 21:20:00');
INSERT INTO `t_job_log` VALUES (6181, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：12毫秒', 1, '', '2023-10-24 21:30:00', '2023-10-24 21:30:00', '2023-10-24 21:30:00');
INSERT INTO `t_job_log` VALUES (6182, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：114毫秒', 1, '', '2023-10-24 21:30:00', '2023-10-24 21:30:00', '2023-10-24 21:30:00');
INSERT INTO `t_job_log` VALUES (6183, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：13毫秒', 1, '', '2023-10-24 21:40:00', '2023-10-24 21:40:00', '2023-10-24 21:40:00');
INSERT INTO `t_job_log` VALUES (6184, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：17毫秒', 1, '', '2023-10-25 10:10:00', '2023-10-25 10:10:00', '2023-10-25 10:10:00');
INSERT INTO `t_job_log` VALUES (6185, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：33毫秒', 1, '', '2023-10-25 10:20:00', '2023-10-25 10:20:00', '2023-10-25 10:20:00');
INSERT INTO `t_job_log` VALUES (6186, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：24毫秒', 1, '', '2023-10-25 10:30:00', '2023-10-25 10:30:00', '2023-10-25 10:30:00');
INSERT INTO `t_job_log` VALUES (6187, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：68毫秒', 1, '', '2023-10-25 10:30:00', '2023-10-25 10:30:00', '2023-10-25 10:30:00');
INSERT INTO `t_job_log` VALUES (6188, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：12毫秒', 1, '', '2023-10-25 10:40:00', '2023-10-25 10:40:00', '2023-10-25 10:40:00');
INSERT INTO `t_job_log` VALUES (6189, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：45毫秒', 1, '', '2023-10-25 11:00:00', '2023-10-25 11:00:00', '2023-10-25 11:00:00');
INSERT INTO `t_job_log` VALUES (6190, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：900毫秒', 1, '', '2023-10-25 11:00:01', '2023-10-25 11:00:00', '2023-10-25 11:00:01');
INSERT INTO `t_job_log` VALUES (6191, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：16毫秒', 1, '', '2023-10-25 15:10:00', '2023-10-25 15:10:00', '2023-10-25 15:10:00');
INSERT INTO `t_job_log` VALUES (6192, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：10毫秒', 1, '', '2023-10-25 15:20:00', '2023-10-25 15:20:00', '2023-10-25 15:20:00');
INSERT INTO `t_job_log` VALUES (6193, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：14毫秒', 1, '', '2023-10-25 15:30:00', '2023-10-25 15:30:00', '2023-10-25 15:30:00');
INSERT INTO `t_job_log` VALUES (6194, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：49毫秒', 1, '', '2023-10-25 15:30:00', '2023-10-25 15:30:00', '2023-10-25 15:30:00');
INSERT INTO `t_job_log` VALUES (6195, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-10-25 15:40:00', '2023-10-25 15:40:00', '2023-10-25 15:40:00');
INSERT INTO `t_job_log` VALUES (6196, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：5毫秒', 1, '', '2023-10-25 15:50:00', '2023-10-25 15:50:00', '2023-10-25 15:50:00');
INSERT INTO `t_job_log` VALUES (6197, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：12毫秒', 1, '', '2023-10-25 17:00:00', '2023-10-25 17:00:00', '2023-10-25 17:00:00');
INSERT INTO `t_job_log` VALUES (6198, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：18毫秒', 1, '', '2023-10-25 17:00:00', '2023-10-25 17:00:00', '2023-10-25 17:00:00');
INSERT INTO `t_job_log` VALUES (6199, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：4毫秒', 1, '', '2023-10-25 17:10:00', '2023-10-25 17:10:00', '2023-10-25 17:10:00');
INSERT INTO `t_job_log` VALUES (6200, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：19毫秒', 1, '', '2023-10-25 18:20:00', '2023-10-25 18:20:00', '2023-10-25 18:20:00');
INSERT INTO `t_job_log` VALUES (6201, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：5毫秒', 1, '', '2023-10-25 18:30:00', '2023-10-25 18:30:00', '2023-10-25 18:30:00');
INSERT INTO `t_job_log` VALUES (6202, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：15毫秒', 1, '', '2023-10-25 18:30:00', '2023-10-25 18:30:00', '2023-10-25 18:30:00');
INSERT INTO `t_job_log` VALUES (6203, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：10毫秒', 1, '', '2023-10-31 14:50:00', '2023-10-31 14:50:00', '2023-10-31 14:50:00');
INSERT INTO `t_job_log` VALUES (6204, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-10-31 15:00:00', '2023-10-31 15:00:00', '2023-10-31 15:00:00');
INSERT INTO `t_job_log` VALUES (6205, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：27毫秒', 1, '', '2023-10-31 15:00:00', '2023-10-31 15:00:00', '2023-10-31 15:00:00');
INSERT INTO `t_job_log` VALUES (6206, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-10-31 15:10:00', '2023-10-31 15:10:00', '2023-10-31 15:10:00');
INSERT INTO `t_job_log` VALUES (6207, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：22毫秒', 1, '', '2023-10-31 15:30:00', '2023-10-31 15:30:00', '2023-10-31 15:30:00');
INSERT INTO `t_job_log` VALUES (6208, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：25毫秒', 1, '', '2023-10-31 15:30:00', '2023-10-31 15:30:00', '2023-10-31 15:30:00');
INSERT INTO `t_job_log` VALUES (6209, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：4毫秒', 1, '', '2023-10-31 15:40:00', '2023-10-31 15:40:00', '2023-10-31 15:40:00');
INSERT INTO `t_job_log` VALUES (6210, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-10-31 15:50:00', '2023-10-31 15:50:00', '2023-10-31 15:50:00');
INSERT INTO `t_job_log` VALUES (6211, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：4毫秒', 1, '', '2023-10-31 16:00:00', '2023-10-31 16:00:00', '2023-10-31 16:00:00');
INSERT INTO `t_job_log` VALUES (6212, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：6毫秒', 1, '', '2023-10-31 16:00:00', '2023-10-31 16:00:00', '2023-10-31 16:00:00');
INSERT INTO `t_job_log` VALUES (6213, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：15毫秒', 1, '', '2023-11-01 09:10:00', '2023-11-01 09:10:00', '2023-11-01 09:10:00');
INSERT INTO `t_job_log` VALUES (6214, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：13毫秒', 1, '', '2023-11-01 09:20:00', '2023-11-01 09:20:00', '2023-11-01 09:20:00');
INSERT INTO `t_job_log` VALUES (6215, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：17毫秒', 1, '', '2023-11-01 10:10:00', '2023-11-01 10:10:00', '2023-11-01 10:10:00');
INSERT INTO `t_job_log` VALUES (6216, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：6毫秒', 1, '', '2023-11-01 10:20:00', '2023-11-01 10:20:00', '2023-11-01 10:20:00');
INSERT INTO `t_job_log` VALUES (6217, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：10毫秒', 1, '', '2023-11-01 11:10:00', '2023-11-01 11:10:00', '2023-11-01 11:10:00');
INSERT INTO `t_job_log` VALUES (6218, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3983毫秒', 1, '', '2023-11-01 11:20:08', '2023-11-01 11:20:03', '2023-11-01 11:20:07');
INSERT INTO `t_job_log` VALUES (6219, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：10毫秒', 1, '', '2023-11-01 13:40:00', '2023-11-01 13:40:00', '2023-11-01 13:40:00');
INSERT INTO `t_job_log` VALUES (6220, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：6毫秒', 1, '', '2023-11-01 13:50:00', '2023-11-01 13:50:00', '2023-11-01 13:50:00');
INSERT INTO `t_job_log` VALUES (6221, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：12毫秒', 1, '', '2023-11-01 14:00:00', '2023-11-01 14:00:00', '2023-11-01 14:00:00');
INSERT INTO `t_job_log` VALUES (6222, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：28毫秒', 1, '', '2023-11-01 14:00:00', '2023-11-01 14:00:00', '2023-11-01 14:00:00');
INSERT INTO `t_job_log` VALUES (6223, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：35毫秒', 1, '', '2023-11-01 14:10:00', '2023-11-01 14:10:00', '2023-11-01 14:10:00');
INSERT INTO `t_job_log` VALUES (6224, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：1156毫秒', 1, '', '2023-11-01 15:21:01', '2023-11-01 15:21:00', '2023-11-01 15:21:01');
INSERT INTO `t_job_log` VALUES (6225, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：10毫秒', 1, '', '2023-11-01 15:50:00', '2023-11-01 15:50:00', '2023-11-01 15:50:00');
INSERT INTO `t_job_log` VALUES (6226, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-11-01 16:00:00', '2023-11-01 16:00:00', '2023-11-01 16:00:00');
INSERT INTO `t_job_log` VALUES (6227, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：20毫秒', 1, '', '2023-11-01 16:00:00', '2023-11-01 16:00:00', '2023-11-01 16:00:00');
INSERT INTO `t_job_log` VALUES (6228, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：32毫秒', 1, '', '2023-11-01 16:10:00', '2023-11-01 16:10:00', '2023-11-01 16:10:00');
INSERT INTO `t_job_log` VALUES (6229, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：4毫秒', 1, '', '2023-11-01 16:20:00', '2023-11-01 16:20:00', '2023-11-01 16:20:00');
INSERT INTO `t_job_log` VALUES (6230, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：4毫秒', 1, '', '2023-11-01 16:30:00', '2023-11-01 16:30:00', '2023-11-01 16:30:00');
INSERT INTO `t_job_log` VALUES (6231, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：24毫秒', 1, '', '2023-11-01 16:30:00', '2023-11-01 16:30:00', '2023-11-01 16:30:00');
INSERT INTO `t_job_log` VALUES (6232, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：12毫秒', 1, '', '2023-11-01 16:40:00', '2023-11-01 16:40:00', '2023-11-01 16:40:00');
INSERT INTO `t_job_log` VALUES (6233, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：6毫秒', 1, '', '2023-11-01 16:50:00', '2023-11-01 16:50:00', '2023-11-01 16:50:00');
INSERT INTO `t_job_log` VALUES (6234, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：13毫秒', 1, '', '2023-11-01 17:00:00', '2023-11-01 17:00:00', '2023-11-01 17:00:00');
INSERT INTO `t_job_log` VALUES (6235, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：26毫秒', 1, '', '2023-11-01 17:00:00', '2023-11-01 17:00:00', '2023-11-01 17:00:00');
INSERT INTO `t_job_log` VALUES (6236, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：18毫秒', 1, '', '2023-11-01 17:10:00', '2023-11-01 17:10:00', '2023-11-01 17:10:00');
INSERT INTO `t_job_log` VALUES (6237, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：6毫秒', 1, '', '2023-11-01 17:20:00', '2023-11-01 17:20:00', '2023-11-01 17:20:00');
INSERT INTO `t_job_log` VALUES (6238, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：5毫秒', 1, '', '2023-11-01 17:30:00', '2023-11-01 17:30:00', '2023-11-01 17:30:00');
INSERT INTO `t_job_log` VALUES (6239, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：20毫秒', 1, '', '2023-11-01 17:30:00', '2023-11-01 17:30:00', '2023-11-01 17:30:00');
INSERT INTO `t_job_log` VALUES (6240, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：13毫秒', 1, '', '2023-11-01 17:40:00', '2023-11-01 17:40:00', '2023-11-01 17:40:00');
INSERT INTO `t_job_log` VALUES (6241, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-11-01 17:50:00', '2023-11-01 17:50:00', '2023-11-01 17:50:00');
INSERT INTO `t_job_log` VALUES (6242, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：3毫秒', 1, '', '2023-11-01 18:00:00', '2023-11-01 18:00:00', '2023-11-01 18:00:00');
INSERT INTO `t_job_log` VALUES (6243, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：12毫秒', 1, '', '2023-11-01 18:00:00', '2023-11-01 18:00:00', '2023-11-01 18:00:00');
INSERT INTO `t_job_log` VALUES (6244, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：595毫秒', 1, '', '2023-11-01 18:10:01', '2023-11-01 18:10:00', '2023-11-01 18:10:01');
INSERT INTO `t_job_log` VALUES (6245, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：454毫秒', 1, '', '2023-11-01 18:20:00', '2023-11-01 18:20:00', '2023-11-01 18:20:00');
INSERT INTO `t_job_log` VALUES (6246, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：9毫秒', 1, '', '2023-11-01 19:00:00', '2023-11-01 19:00:00', '2023-11-01 19:00:00');
INSERT INTO `t_job_log` VALUES (6247, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：557毫秒', 1, '', '2023-11-01 19:00:01', '2023-11-01 19:00:00', '2023-11-01 19:00:01');
INSERT INTO `t_job_log` VALUES (6248, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：535毫秒', 1, '', '2023-11-01 19:10:01', '2023-11-01 19:10:00', '2023-11-01 19:10:01');
INSERT INTO `t_job_log` VALUES (6249, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：543毫秒', 1, '', '2023-11-01 19:20:01', '2023-11-01 19:20:00', '2023-11-01 19:20:01');
INSERT INTO `t_job_log` VALUES (6250, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：803毫秒', 1, '', '2023-11-01 20:30:01', '2023-11-01 20:30:00', '2023-11-01 20:30:01');
INSERT INTO `t_job_log` VALUES (6251, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：1355毫秒', 1, '', '2023-11-01 20:30:01', '2023-11-01 20:30:00', '2023-11-01 20:30:01');
INSERT INTO `t_job_log` VALUES (6252, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：533毫秒', 1, '', '2023-11-01 20:40:01', '2023-11-01 20:40:00', '2023-11-01 20:40:01');
INSERT INTO `t_job_log` VALUES (6253, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：559毫秒', 1, '', '2023-11-01 20:50:01', '2023-11-01 20:50:00', '2023-11-01 20:50:01');
INSERT INTO `t_job_log` VALUES (6254, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：514毫秒', 1, '', '2023-11-02 10:10:01', '2023-11-02 10:10:00', '2023-11-02 10:10:01');
INSERT INTO `t_job_log` VALUES (6255, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：492毫秒', 1, '', '2023-11-02 10:20:01', '2023-11-02 10:20:00', '2023-11-02 10:20:01');
INSERT INTO `t_job_log` VALUES (6256, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：22毫秒', 1, '', '2023-11-02 10:30:00', '2023-11-02 10:30:00', '2023-11-02 10:30:00');
INSERT INTO `t_job_log` VALUES (6257, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：378毫秒', 1, '', '2023-11-02 10:30:00', '2023-11-02 10:30:00', '2023-11-02 10:30:00');
INSERT INTO `t_job_log` VALUES (6258, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：4452毫秒', 1, '', '2023-11-02 10:40:04', '2023-11-02 10:40:00', '2023-11-02 10:40:04');
INSERT INTO `t_job_log` VALUES (6259, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：283毫秒', 1, '', '2023-11-02 10:50:00', '2023-11-02 10:50:00', '2023-11-02 10:50:00');
INSERT INTO `t_job_log` VALUES (6260, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：13毫秒', 1, '', '2023-11-02 11:00:00', '2023-11-02 11:00:00', '2023-11-02 11:00:00');
INSERT INTO `t_job_log` VALUES (6261, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：497毫秒', 1, '', '2023-11-02 11:00:01', '2023-11-02 11:00:00', '2023-11-02 11:00:01');
INSERT INTO `t_job_log` VALUES (6262, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：339毫秒', 1, '', '2023-11-02 11:10:00', '2023-11-02 11:10:00', '2023-11-02 11:10:00');
INSERT INTO `t_job_log` VALUES (6263, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：574毫秒', 1, '', '2023-11-02 21:10:01', '2023-11-02 21:10:00', '2023-11-02 21:10:01');
INSERT INTO `t_job_log` VALUES (6264, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：300毫秒', 1, '', '2023-11-02 21:20:00', '2023-11-02 21:20:00', '2023-11-02 21:20:00');
INSERT INTO `t_job_log` VALUES (6265, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：23毫秒', 1, '', '2023-11-02 21:30:00', '2023-11-02 21:30:00', '2023-11-02 21:30:00');
INSERT INTO `t_job_log` VALUES (6266, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：314毫秒', 1, '', '2023-11-02 21:30:00', '2023-11-02 21:30:00', '2023-11-02 21:30:00');
INSERT INTO `t_job_log` VALUES (6267, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：1390毫秒', 1, '', '2023-11-02 21:40:01', '2023-11-02 21:40:00', '2023-11-02 21:40:01');
INSERT INTO `t_job_log` VALUES (6268, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：315毫秒', 1, '', '2023-11-02 21:50:00', '2023-11-02 21:50:00', '2023-11-02 21:50:00');
INSERT INTO `t_job_log` VALUES (6269, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：18毫秒', 1, '', '2023-11-02 22:00:00', '2023-11-02 22:00:00', '2023-11-02 22:00:00');
INSERT INTO `t_job_log` VALUES (6270, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：313毫秒', 1, '', '2023-11-02 22:00:00', '2023-11-02 22:00:00', '2023-11-02 22:00:00');
INSERT INTO `t_job_log` VALUES (6271, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：334毫秒', 1, '', '2023-11-02 22:10:00', '2023-11-02 22:10:00', '2023-11-02 22:10:00');
INSERT INTO `t_job_log` VALUES (6272, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：464毫秒', 1, '', '2023-11-02 22:20:00', '2023-11-02 22:20:00', '2023-11-02 22:20:00');
INSERT INTO `t_job_log` VALUES (6273, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：14毫秒', 1, '', '2023-11-02 22:30:00', '2023-11-02 22:30:00', '2023-11-02 22:30:00');
INSERT INTO `t_job_log` VALUES (6274, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：343毫秒', 1, '', '2023-11-02 22:30:00', '2023-11-02 22:30:00', '2023-11-02 22:30:00');
INSERT INTO `t_job_log` VALUES (6275, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：315毫秒', 1, '', '2023-11-02 22:40:00', '2023-11-02 22:40:00', '2023-11-02 22:40:00');
INSERT INTO `t_job_log` VALUES (6276, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：334毫秒', 1, '', '2023-11-02 22:50:00', '2023-11-02 22:50:00', '2023-11-02 22:50:00');
INSERT INTO `t_job_log` VALUES (6277, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：4798毫秒', 1, '', '2023-11-02 23:00:05', '2023-11-02 23:00:00', '2023-11-02 23:00:05');
INSERT INTO `t_job_log` VALUES (6278, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：5100毫秒', 1, '', '2023-11-02 23:00:05', '2023-11-02 23:00:00', '2023-11-02 23:00:05');
INSERT INTO `t_job_log` VALUES (6279, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：460毫秒', 1, '', '2023-11-03 16:50:00', '2023-11-03 16:50:00', '2023-11-03 16:50:00');
INSERT INTO `t_job_log` VALUES (6280, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：22毫秒', 1, '', '2023-11-03 17:00:00', '2023-11-03 17:00:00', '2023-11-03 17:00:00');
INSERT INTO `t_job_log` VALUES (6281, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：298毫秒', 1, '', '2023-11-03 17:00:00', '2023-11-03 17:00:00', '2023-11-03 17:00:00');
INSERT INTO `t_job_log` VALUES (6282, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：1106毫秒', 1, '', '2023-11-04 12:40:01', '2023-11-04 12:40:00', '2023-11-04 12:40:01');
INSERT INTO `t_job_log` VALUES (6283, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：670毫秒', 1, '', '2023-11-04 12:50:01', '2023-11-04 12:50:00', '2023-11-04 12:50:01');
INSERT INTO `t_job_log` VALUES (6284, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：586毫秒', 1, '', '2023-11-04 13:00:01', '2023-11-04 13:00:00', '2023-11-04 13:00:01');
INSERT INTO `t_job_log` VALUES (6285, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：1236毫秒', 1, '', '2023-11-04 13:00:01', '2023-11-04 13:00:00', '2023-11-04 13:00:01');
INSERT INTO `t_job_log` VALUES (6286, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：534毫秒', 1, '', '2023-11-04 13:10:01', '2023-11-04 13:10:00', '2023-11-04 13:10:01');
INSERT INTO `t_job_log` VALUES (6287, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：35毫秒', 1, '', '2023-11-04 13:30:00', '2023-11-04 13:30:00', '2023-11-04 13:30:00');
INSERT INTO `t_job_log` VALUES (6288, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：662毫秒', 1, '', '2023-11-04 13:30:01', '2023-11-04 13:30:00', '2023-11-04 13:30:01');
INSERT INTO `t_job_log` VALUES (6289, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：641毫秒', 1, '', '2023-11-04 13:40:01', '2023-11-04 13:40:00', '2023-11-04 13:40:01');
INSERT INTO `t_job_log` VALUES (6290, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：636毫秒', 1, '', '2023-11-04 14:20:01', '2023-11-04 14:20:00', '2023-11-04 14:20:01');
INSERT INTO `t_job_log` VALUES (6291, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：783毫秒', 1, '', '2023-11-04 14:50:01', '2023-11-04 14:50:00', '2023-11-04 14:50:01');
INSERT INTO `t_job_log` VALUES (6292, 81, '统计用户地域分布', '默认', 'auroraQuartz.statisticalUserArea', '统计用户地域分布 总共耗时：30毫秒', 1, '', '2023-11-04 15:00:00', '2023-11-04 15:00:00', '2023-11-04 15:00:00');
INSERT INTO `t_job_log` VALUES (6293, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：507毫秒', 1, '', '2023-11-04 15:00:01', '2023-11-04 15:00:00', '2023-11-04 15:00:01');
INSERT INTO `t_job_log` VALUES (6294, 84, '百度SEO', '默认', 'auroraQuartz.baiduSeo', '百度SEO 总共耗时：755毫秒', 1, '', '2023-11-04 15:10:01', '2023-11-04 15:10:00', '2023-11-04 15:10:01');

-- ----------------------------
-- Table structure for t_menu
-- ----------------------------
DROP TABLE IF EXISTS `t_menu`;
CREATE TABLE `t_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单名',
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单路径',
  `component` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '组件',
  `icon` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '菜单icon',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `order_num` tinyint(1) NOT NULL COMMENT '排序',
  `parent_id` int NULL DEFAULT NULL COMMENT '父id',
  `is_hidden` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否隐藏  0否1是',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 226 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_menu
-- ----------------------------
INSERT INTO `t_menu` VALUES (1, '首页', '/', '/home/Home.vue', 'el-icon-myshouye', '2021-01-26 17:06:51', '2022-07-27 16:33:11', 1, NULL, 0);
INSERT INTO `t_menu` VALUES (2, '文章管理', '/article-submenu', 'Layout', 'el-icon-mywenzhang-copy', '2021-01-25 20:43:07', '2022-07-27 16:32:55', 2, NULL, 0);
INSERT INTO `t_menu` VALUES (3, '消息管理', '/message-submenu', 'Layout', 'el-icon-myxiaoxi', '2021-01-25 20:44:17', '2022-07-27 16:32:57', 3, NULL, 0);
INSERT INTO `t_menu` VALUES (4, '系统管理', '/system-submenu', 'Layout', 'el-icon-myshezhi', '2021-01-25 20:45:57', '2021-01-25 20:45:59', 5, NULL, 0);
INSERT INTO `t_menu` VALUES (5, '个人中心', '/setting', '/setting/Setting.vue', 'el-icon-myuser', '2021-01-26 17:22:38', '2021-01-26 17:22:41', 7, NULL, 0);
INSERT INTO `t_menu` VALUES (6, '发布文章', '/articles', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:30:48', '2021-01-26 14:30:51', 1, 2, 0);
INSERT INTO `t_menu` VALUES (7, '修改文章', '/articles/*', '/article/Article.vue', 'el-icon-myfabiaowenzhang', '2021-01-26 14:31:32', '2022-07-28 16:28:06', 2, 2, 1);
INSERT INTO `t_menu` VALUES (8, '文章列表', '/article-list', '/article/ArticleList.vue', 'el-icon-mywenzhangliebiao', '2021-01-26 14:32:13', '2021-01-26 14:32:16', 3, 2, 0);
INSERT INTO `t_menu` VALUES (9, '分类管理', '/categories', '/category/Category.vue', 'el-icon-myfenlei', '2021-01-26 14:33:42', '2021-01-26 14:33:43', 4, 2, 0);
INSERT INTO `t_menu` VALUES (10, '标签管理', '/tags', '/tag/Tag.vue', 'el-icon-myicontag', '2021-01-26 14:34:33', '2021-01-26 14:34:36', 5, 2, 0);
INSERT INTO `t_menu` VALUES (11, '评论管理', '/comments', '/comment/Comment.vue', 'el-icon-mypinglunzu', '2021-01-26 14:35:31', '2021-01-26 14:35:34', 1, 3, 0);
INSERT INTO `t_menu` VALUES (13, '用户列表', '/users', '/user/User.vue', 'el-icon-myyonghuliebiao', '2021-01-26 14:38:09', '2021-01-26 14:38:12', 1, 202, 0);
INSERT INTO `t_menu` VALUES (14, '角色管理', '/roles', '/role/Role.vue', 'el-icon-myjiaoseliebiao', '2021-01-26 14:39:01', '2021-01-26 14:39:03', 2, 213, 0);
INSERT INTO `t_menu` VALUES (15, '接口管理', '/resources', '/resource/Resource.vue', 'el-icon-myjiekouguanli', '2021-01-26 14:40:14', '2021-08-07 20:00:28', 2, 213, 0);
INSERT INTO `t_menu` VALUES (16, '菜单管理', '/menus', '/menu/Menu.vue', 'el-icon-mycaidan', '2021-01-26 14:40:54', '2021-08-07 10:18:49', 2, 213, 0);
INSERT INTO `t_menu` VALUES (17, '友链管理', '/links', '/friendLink/FriendLink.vue', 'el-icon-mydashujukeshihuaico-', '2021-01-26 14:41:35', '2021-01-26 14:41:37', 3, 4, 0);
INSERT INTO `t_menu` VALUES (18, '关于我', '/about', '/about/About.vue', 'el-icon-myguanyuwo', '2021-01-26 14:42:05', '2021-01-26 14:42:10', 4, 4, 0);
INSERT INTO `t_menu` VALUES (19, '日志管理', '/log-submenu', 'Layout', 'el-icon-myguanyuwo', '2021-01-31 21:33:56', '2021-01-31 21:33:59', 6, NULL, 0);
INSERT INTO `t_menu` VALUES (20, '操作日志', '/operation/log', '/log/OperationLog.vue', 'el-icon-myguanyuwo', '2021-01-31 15:53:21', '2022-07-28 10:51:28', 1, 19, 0);
INSERT INTO `t_menu` VALUES (201, '在线用户', '/online/users', '/user/Online.vue', 'el-icon-myyonghuliebiao', '2021-02-05 14:59:51', '2021-02-05 14:59:53', 7, 202, 0);
INSERT INTO `t_menu` VALUES (202, '用户管理', '/users-submenu', 'Layout', 'el-icon-myyonghuliebiao', '2021-02-06 23:44:59', '2022-07-27 16:32:59', 4, NULL, 0);
INSERT INTO `t_menu` VALUES (205, '相册管理', '/album-submenu', 'Layout', 'el-icon-myimage-fill', '2021-08-03 15:10:54', '2021-08-07 20:02:06', 5, NULL, 0);
INSERT INTO `t_menu` VALUES (206, '相册列表', '/albums', '/album/Album.vue', 'el-icon-myzhaopian', '2021-08-03 20:29:19', '2021-08-04 11:45:47', 1, 205, 0);
INSERT INTO `t_menu` VALUES (208, '照片管理', '/albums/:albumId', '/album/Photo.vue', 'el-icon-myzhaopian', '2021-08-03 21:37:47', '2021-08-05 10:24:08', 1, 205, 1);
INSERT INTO `t_menu` VALUES (209, '定时任务', '/quartz', '/quartz/Quartz.vue', 'el-icon-myyemianpeizhi', '2021-08-04 11:36:27', '2021-08-07 20:01:26', 2, 4, 0);
INSERT INTO `t_menu` VALUES (210, '照片回收站', '/photos/delete', '/album/Delete.vue', 'el-icon-myhuishouzhan', '2021-08-05 13:55:19', NULL, 3, 205, 1);
INSERT INTO `t_menu` VALUES (213, '权限管理', '/permission-submenu', 'Layout', 'el-icon-mydaohanglantubiao_quanxianguanli', '2021-08-07 19:56:55', '2021-08-07 19:59:40', 4, NULL, 0);
INSERT INTO `t_menu` VALUES (214, '网站管理', '/website', '/website/Website.vue', 'el-icon-myxitong', '2021-08-07 20:06:41', NULL, 1, 4, 0);
INSERT INTO `t_menu` VALUES (220, '定时任务日志', '/quartz/log/:quartzId', '/log/QuartzLog.vue', 'el-icon-myguanyuwo', '2022-07-28 10:53:23', '2022-08-05 10:27:47', 2, 19, 1);
INSERT INTO `t_menu` VALUES (221, '说说管理', '/talk-submenu', 'Layout', 'el-icon-mypinglun', '2022-08-15 17:27:10', '2022-08-15 17:27:39', 3, NULL, 0);
INSERT INTO `t_menu` VALUES (222, '说说列表', '/talk-list', '/talk/TalkList.vue', 'el-icon-myiconfontdongtaidianji', '2022-08-15 17:29:05', NULL, 1, 221, 0);
INSERT INTO `t_menu` VALUES (223, '发布说说', '/talks', '/talk/Talk.vue', 'el-icon-myfabusekuai', '2022-08-15 17:34:26', '2022-08-16 16:06:04', 2, 221, 0);
INSERT INTO `t_menu` VALUES (224, '修改说说', '/talks/:talkId', '/talk/Talk.vue', 'el-icon-myfabusekuai', '2022-08-16 16:06:59', '2022-08-16 16:08:21', 3, 221, 1);
INSERT INTO `t_menu` VALUES (225, '异常日志', '/exception/log', '/log/ExceptionLog.vue', 'el-icon-myguanyuwo', '2022-08-25 13:40:08', '2022-08-25 13:40:31', 1, 19, 0);

-- ----------------------------
-- Table structure for t_operation_log
-- ----------------------------
DROP TABLE IF EXISTS `t_operation_log`;
CREATE TABLE `t_operation_log`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `opt_module` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作模块',
  `opt_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作类型',
  `opt_uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作url',
  `opt_method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作方法',
  `opt_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作描述',
  `request_param` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求参数',
  `request_method` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '请求方式',
  `response_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '返回数据',
  `user_id` int NOT NULL COMMENT '用户id',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `ip_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '操作地址',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1753 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_operation_log
-- ----------------------------
INSERT INTO `t_operation_log` VALUES (1671, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-24 21:09:06', NULL);
INSERT INTO `t_operation_log` VALUES (1672, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-24 21:09:08', NULL);
INSERT INTO `t_operation_log` VALUES (1673, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-24 21:23:41', NULL);
INSERT INTO `t_operation_log` VALUES (1674, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-24 21:23:52', NULL);
INSERT INTO `t_operation_log` VALUES (1675, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/09bb3369083ad2d92f53908d16a41b74.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-24 21:26:57', NULL);
INSERT INTO `t_operation_log` VALUES (1676, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-24 21:26:58', NULL);
INSERT INTO `t_operation_log` VALUES (1677, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 16:59:45', NULL);
INSERT INTO `t_operation_log` VALUES (1678, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:00:10', NULL);
INSERT INTO `t_operation_log` VALUES (1679, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:16:34', NULL);
INSERT INTO `t_operation_log` VALUES (1680, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:17:02', NULL);
INSERT INTO `t_operation_log` VALUES (1681, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:18:40', NULL);
INSERT INTO `t_operation_log` VALUES (1682, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:25:30', NULL);
INSERT INTO `t_operation_log` VALUES (1683, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/c2f2d84a23aa567fab69188595629642.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:28:48', NULL);
INSERT INTO `t_operation_log` VALUES (1684, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http:\\\\\\\\192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-25 17:32:44', NULL);
INSERT INTO `t_operation_log` VALUES (1685, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http:\\\\\\\\192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-10-31 15:30:10', NULL);
INSERT INTO `t_operation_log` VALUES (1686, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:06:16', NULL);
INSERT INTO `t_operation_log` VALUES (1687, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:06:18', NULL);
INSERT INTO `t_operation_log` VALUES (1688, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://localhost:8081\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:13:27', NULL);
INSERT INTO `t_operation_log` VALUES (1689, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:13:33', NULL);
INSERT INTO `t_operation_log` VALUES (1690, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://localhost:8081\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:13:34', NULL);
INSERT INTO `t_operation_log` VALUES (1691, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:22:42', NULL);
INSERT INTO `t_operation_log` VALUES (1692, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:29:46', NULL);
INSERT INTO `t_operation_log` VALUES (1693, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:33:51', NULL);
INSERT INTO `t_operation_log` VALUES (1694, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 09:45:59', NULL);
INSERT INTO `t_operation_log` VALUES (1695, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 10:12:53', NULL);
INSERT INTO `t_operation_log` VALUES (1696, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 10:27:11', NULL);
INSERT INTO `t_operation_log` VALUES (1697, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/85228897906003c001a25f14372429da.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 10:30:22', NULL);
INSERT INTO `t_operation_log` VALUES (1698, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 10:30:23', NULL);
INSERT INTO `t_operation_log` VALUES (1699, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:00:58', NULL);
INSERT INTO `t_operation_log` VALUES (1700, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:01:55', NULL);
INSERT INTO `t_operation_log` VALUES (1701, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:01:56', NULL);
INSERT INTO `t_operation_log` VALUES (1702, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:08:30', NULL);
INSERT INTO `t_operation_log` VALUES (1703, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:08:37', NULL);
INSERT INTO `t_operation_log` VALUES (1704, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"nullaurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:24:13', NULL);
INSERT INTO `t_operation_log` VALUES (1705, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 11:24:16', NULL);
INSERT INTO `t_operation_log` VALUES (1706, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000aurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:00:47', NULL);
INSERT INTO `t_operation_log` VALUES (1707, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:00:48', NULL);
INSERT INTO `t_operation_log` VALUES (1708, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:01:53', NULL);
INSERT INTO `t_operation_log` VALUES (1709, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/avatar/40e75b29d3e780696201112b22edde2e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:01:53', NULL);
INSERT INTO `t_operation_log` VALUES (1710, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/avatar/293077077a5f8db6f303056e61694e74.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:10:29', NULL);
INSERT INTO `t_operation_log` VALUES (1711, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:10:31', NULL);
INSERT INTO `t_operation_log` VALUES (1712, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/avatar/28da73db59ee8d68c8520d46d18e13f2.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:23:29', NULL);
INSERT INTO `t_operation_log` VALUES (1713, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 14:23:31', NULL);
INSERT INTO `t_operation_log` VALUES (1714, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/avatar/4a93553e90554c89a3ce6828b9ee359e.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 15:16:15', NULL);
INSERT INTO `t_operation_log` VALUES (1715, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/avatar/3d12c57cbbd689d03f53c2628309ebd9.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 15:41:00', NULL);
INSERT INTO `t_operation_log` VALUES (1716, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"用户1716788911331577858\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 15:41:35', NULL);
INSERT INTO `t_operation_log` VALUES (1717, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 15:41:37', NULL);
INSERT INTO `t_operation_log` VALUES (1718, '评论模块', '新增', '/comments/save', 'com.blog.controller.CommentController.saveComment', '添加评论', '[{\"commentContent\":\"测试\",\"type\":3}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:03:53', NULL);
INSERT INTO `t_operation_log` VALUES (1719, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"nickname\":\"长乐予安\",\"website\":\"http://192.168.188.128:9000\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '用户1716788911331577858', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:04:16', NULL);
INSERT INTO `t_operation_log` VALUES (1720, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b924493f20b1256bf78391110a440bdc.jpeg\",\"flag\":true,\"message\":\"操作成功\"}', 1015, '用户1719647303091990529', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:27:42', NULL);
INSERT INTO `t_operation_log` VALUES (1721, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"intro\":\"测试账号\",\"nickname\":\"测试账号\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1015, '用户1719647303091990529', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:28:07', NULL);
INSERT INTO `t_operation_log` VALUES (1722, '用户信息模块', '修改', '/users/avatar', 'com.blog.controller.UserInfoController.updateUserAvatar', '更新用户头像', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/avatar/34a0eb1ce0b80388d9eed2c476abfd66.webp\",\"flag\":true,\"message\":\"操作成功\"}', 1, '演示账号', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:43:29', NULL);
INSERT INTO `t_operation_log` VALUES (1723, '用户信息模块', '修改', '/users/info', 'com.blog.controller.UserInfoController.updateUserInfo', '更新用户信息', '[{\"intro\":\"演示账号的用户简介\",\"nickname\":\"演示账号\",\"website\":\"https://www.linhaojun.top\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '演示账号', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:43:32', NULL);
INSERT INTO `t_operation_log` VALUES (1724, 'aurora信息', '修改', '/admin/website/config', 'com.blog.controller.AuroraInfoController.updateWebsiteConfig', '更新网站配置', '[{\"alipayQRCode\":\"\",\"author\":\"长乐予安\",\"authorAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"authorIntro\":\"正青春被编程削去了头发\",\"beianNumber\":\"\",\"csdn\":\"\",\"englishName\":\"changleyuan\",\"gitee\":\"\",\"github\":\"\",\"isCommentReview\":0,\"isEmailNotice\":1,\"isReward\":1,\"juejin\":\"\",\"logo\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"multiLanguage\":1,\"name\":\"长乐予安\",\"notice\":\"\",\"qq\":\"3319023171\",\"qqLogin\":0,\"stackoverflow\":\"\",\"touristAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"twitter\":\"\",\"userAvatar\":\"\",\"weChat\":\"\",\"websiteCreateTime\":\"2023-10-20\",\"weiXinQRCode\":\"\",\"weibo\":\"\",\"zhihu\":\"\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '演示账号', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:44:21', NULL);
INSERT INTO `t_operation_log` VALUES (1725, 'aurora信息', '修改', '/admin/website/config', 'com.blog.controller.AuroraInfoController.updateWebsiteConfig', '更新网站配置', '[{\"alipayQRCode\":\"\",\"author\":\"长乐予安\",\"authorAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"authorIntro\":\"正青春被编程削去了头发\",\"beianNumber\":\"\",\"csdn\":\"\",\"englishName\":\"changleyuan\",\"gitee\":\"\",\"github\":\"\",\"isCommentReview\":0,\"isEmailNotice\":1,\"isReward\":1,\"juejin\":\"\",\"logo\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"multiLanguage\":1,\"name\":\"长乐予安\",\"notice\":\"\",\"qq\":\"3319023171\",\"qqLogin\":0,\"stackoverflow\":\"\",\"touristAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"twitter\":\"\",\"userAvatar\":\"\",\"weChat\":\"\",\"websiteCreateTime\":\"2023-10-20\",\"weiXinQRCode\":\"\",\"weibo\":\"\",\"zhihu\":\"\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '演示账号', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:46:03', NULL);
INSERT INTO `t_operation_log` VALUES (1726, 'aurora信息', '上传', '/admin/config/images', 'com.blog.controller.AuroraInfoController.savePhotoAlbumCover', '上传博客配置图片', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/config/dd22a649ac2f2220257f323e58574a9f.webp\",\"flag\":true,\"message\":\"操作成功\"}', 1, '演示账号', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:50:05', NULL);
INSERT INTO `t_operation_log` VALUES (1727, 'aurora信息', '修改', '/admin/website/config', 'com.blog.controller.AuroraInfoController.updateWebsiteConfig', '更新网站配置', '[{\"alipayQRCode\":\"\",\"author\":\"长乐予安\",\"authorAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"authorIntro\":\"正青春被编程削去了头发\",\"beianNumber\":\"\",\"csdn\":\"\",\"englishName\":\"changleyuan\",\"gitee\":\"\",\"github\":\"\",\"isCommentReview\":0,\"isEmailNotice\":1,\"isReward\":1,\"juejin\":\"\",\"logo\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"multiLanguage\":1,\"name\":\"长乐予安\",\"notice\":\"\",\"qq\":\"3319023171\",\"qqLogin\":0,\"stackoverflow\":\"\",\"touristAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"twitter\":\"\",\"userAvatar\":\"http://192.168.188.128:9000/aurora/aurora/config/dd22a649ac2f2220257f323e58574a9f.webp\",\"weChat\":\"\",\"websiteCreateTime\":\"2023-10-20\",\"weiXinQRCode\":\"\",\"weibo\":\"\",\"zhihu\":\"\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1, '演示账号', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:50:09', NULL);
INSERT INTO `t_operation_log` VALUES (1728, '分类模块', '新增或修改', '/admin/categories', 'com.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"spring\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:59:43', NULL);
INSERT INTO `t_operation_log` VALUES (1729, '分类模块', '新增或修改', '/admin/categories', 'com.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"rabbitMQ\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:00:01', NULL);
INSERT INTO `t_operation_log` VALUES (1730, '标签模块', '新增或修改', '/admin/tags', 'com.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"java\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:00:19', NULL);
INSERT INTO `t_operation_log` VALUES (1731, '文章模块', '上传', '/admin/articles/images', 'com.blog.controller.ArticleController.saveArticleImages', '上传文章图片', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:00:45', NULL);
INSERT INTO `t_operation_log` VALUES (1732, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"0. 简介\\n​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​ 一般Web应用的需要进行认证和授权。\\n\\n​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户\\n\\n​ 授权：经过认证后判断当前用户是否有权限进行某个操作\\n\\n​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n1. 快速入门\\n1.1 准备工作\\n​ 我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\nCopy\\n② 创建启动类\\n\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\nCopy\\n③ 创建Controller\\n\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\nCopy\\n1.2 引入SpringSecurity\\n​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\nCopy\\n​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​ 必须登陆之后才能对接口进行访问。\\n\\n2. 认证\\n2.1 登陆校验流程\\n\\n\\n2.2 原理初探\\n​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n2.2.1 SpringSecurity完整流程\\n​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n\\n\\n​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\nUsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\n\\n​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n\\n\\n2.2.2 认证流程详解\\n\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法\\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n2.3 解决问题\\n2.3.1 思路分析\\n登录\\n\\n​ ①自定义登录接口\\n\\n​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​ 把用户信息存入redis中\\n\\n​ ②自定义UserDetailsService\\n\\n​ 在这个实现类中去查询数据库\\n\\n校验：\\n\\n​ ①定义Jwt认证过滤器\\n\\n​ 获取token\\n\\n​ 解析token获取其中的userid\\n\\n​ 从redis中获取用户信息\\n\\n​ 存入SecurityContextHolder\\n\\n2.3.2 准备工作\\n①添加依赖\\n\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\nCopy\\n② 添加Redis相关配置\\n\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author 三更\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\nCopy\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\nCopy\\n③ 响应类\\n\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\nCopy\\n④工具类\\n\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\nCopy\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\nCopy\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\nCopy\\n⑤实体类\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\nCopy\\n2.3.3 实现\\n2.3.3.1 数据库校验用户\\n​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n准备工作\\n​ 我们先创建一个用户表， 建表语句如下：\\n\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\nCopy\\n​ 引入MybatisPuls和mysql驱动的依赖\\n\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\nCopy\\n​ 配置数据库信息\\n\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\nCopy\\n​ 定义Mapper接口\\n\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\nCopy\\n​ 修改User实体类\\n\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\nCopy\\n​ 配置Mapper扫描\\n\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\nCopy\\n​ 添加junit依赖\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\nCopy\\n​ 测试MP是否能正常使用\\n\\n/**\\n * @Author 三更\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\nCopy\\n核心代码实现\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n/**\\n * @Author 三更\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\nCopy\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n/**\\n * @Author 三更\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\nCopy\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\\n\\n2.3.3.2 密码加密存储\\n​ 实际项目中我们不会把密码明文存储在数据库中。\\n\\n​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\nCopy\\n2.3.3.3 登陆接口\\n​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\nCopy\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\nCopy\\n​\\n\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\nCopy\\n2.3.3.4 认证过滤器\\n​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​ 使用userid去redis中获取对应的LoginUser对象。\\n\\n​ 然后封装Authentication对象存入SecurityContextHolder\\n\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\nCopy\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\nCopy\\n2.3.3.5 退出登陆\\n​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\nCopy\\n3. 授权\\n3.0 权限系统的作用\\n​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。\\n\\n​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\n\\n3.1 授权基本流程\\n​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​ 然后设置我们的资源所需要的权限即可。\\n\\n3.2 授权实现\\n3.2.1 限制访问资源所需权限\\n​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​ 但是要使用它我们需要先开启相关配置。\\n\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\nCopy\\n​ 然后就可以使用对应的注解。@PreAuthorize\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\nCopy\\n3.2.2 封装权限信息\\n​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​ 我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  \\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\nCopy\\n​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\nCopy\\n3.2.3 从数据库查询权限信息\\n3.2.3.1 RBAC权限模型\\n​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n\\n\\n3.2.3.2 准备工作\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\nCopy\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\nCopy\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author 三更\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\nCopy\\n3.2.3.3 代码实现\\n​ 我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  \\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\nCopy\\n​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\nCopy\\n​ 在application.yml中配置mapperXML文件的位置\\n\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\nCopy\\n​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n/**\\n * @Author 三更 \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\nCopy\\n4. 自定义失败处理\\n​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。\\n\\n​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。\\n\\n​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n①自定义实现类\\n\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\nCopy\\n/**\\n * @Author 三更  \\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\nCopy\\n②配置给SpringSecurity\\n\\n​\\n\\n​ 先注入对应的处理器\\n\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\nCopy\\n​ 然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\nCopy\\n5. 跨域\\n​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。\\n\\n​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​ 所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\nCopy\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\nCopy\\n6. 遗留小问题\\n其它权限校验方法\\n​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​\\n\\n​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。\\n\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。\\n\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n自定义权限校验方法\\n​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\nCopy\\n​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n基于配置的权限控制\\n​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\nCopy\\nCSRF\\n​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n认证成功处理器\\n​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\nCopy\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\nCopy\\n认证失败处理器\\n​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\nCopy\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\nCopy\\n登出成功处理器\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\nCopy\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"articleTitle\":\"2023-11-01\",\"categoryName\":\"spring\",\"isFeatured\":0,\"isTop\":1,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:00:51', NULL);
INSERT INTO `t_operation_log` VALUES (1733, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"0. 简介\\n​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​ 一般Web应用的需要进行认证和授权。\\n\\n​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户\\n\\n​ 授权：经过认证后判断当前用户是否有权限进行某个操作\\n\\n​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n1. 快速入门\\n1.1 准备工作\\n​ 我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\nCopy\\n② 创建启动类\\n\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\nCopy\\n③ 创建Controller\\n\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\nCopy\\n1.2 引入SpringSecurity\\n​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\nCopy\\n​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​ 必须登陆之后才能对接口进行访问。\\n\\n2. 认证\\n2.1 登陆校验流程\\n\\n\\n2.2 原理初探\\n​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n2.2.1 SpringSecurity完整流程\\n​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n\\n\\n​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\nUsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\n\\n​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n\\n\\n2.2.2 认证流程详解\\n\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法\\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n2.3 解决问题\\n2.3.1 思路分析\\n登录\\n\\n​ ①自定义登录接口\\n\\n​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​ 把用户信息存入redis中\\n\\n​ ②自定义UserDetailsService\\n\\n​ 在这个实现类中去查询数据库\\n\\n校验：\\n\\n​ ①定义Jwt认证过滤器\\n\\n​ 获取token\\n\\n​ 解析token获取其中的userid\\n\\n​ 从redis中获取用户信息\\n\\n​ 存入SecurityContextHolder\\n\\n2.3.2 准备工作\\n①添加依赖\\n\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\nCopy\\n② 添加Redis相关配置\\n\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author 三更\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\nCopy\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\nCopy\\n③ 响应类\\n\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\nCopy\\n④工具类\\n\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\nCopy\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\nCopy\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\nCopy\\n⑤实体类\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\nCopy\\n2.3.3 实现\\n2.3.3.1 数据库校验用户\\n​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n准备工作\\n​ 我们先创建一个用户表， 建表语句如下：\\n\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\nCopy\\n​ 引入MybatisPuls和mysql驱动的依赖\\n\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\nCopy\\n​ 配置数据库信息\\n\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\nCopy\\n​ 定义Mapper接口\\n\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\nCopy\\n​ 修改User实体类\\n\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\nCopy\\n​ 配置Mapper扫描\\n\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\nCopy\\n​ 添加junit依赖\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\nCopy\\n​ 测试MP是否能正常使用\\n\\n/**\\n * @Author 三更\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\nCopy\\n核心代码实现\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n/**\\n * @Author 三更\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\nCopy\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n/**\\n * @Author 三更\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\nCopy\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\\n\\n2.3.3.2 密码加密存储\\n​ 实际项目中我们不会把密码明文存储在数据库中。\\n\\n​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\nCopy\\n2.3.3.3 登陆接口\\n​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\nCopy\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\nCopy\\n​\\n\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\nCopy\\n2.3.3.4 认证过滤器\\n​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​ 使用userid去redis中获取对应的LoginUser对象。\\n\\n​ 然后封装Authentication对象存入SecurityContextHolder\\n\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\nCopy\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\nCopy\\n2.3.3.5 退出登陆\\n​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\nCopy\\n3. 授权\\n3.0 权限系统的作用\\n​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。\\n\\n​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\n\\n3.1 授权基本流程\\n​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​ 然后设置我们的资源所需要的权限即可。\\n\\n3.2 授权实现\\n3.2.1 限制访问资源所需权限\\n​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​ 但是要使用它我们需要先开启相关配置。\\n\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\nCopy\\n​ 然后就可以使用对应的注解。@PreAuthorize\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\nCopy\\n3.2.2 封装权限信息\\n​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​ 我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  \\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\nCopy\\n​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\nCopy\\n3.2.3 从数据库查询权限信息\\n3.2.3.1 RBAC权限模型\\n​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n\\n\\n3.2.3.2 准备工作\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\nCopy\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\nCopy\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author 三更\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\nCopy\\n3.2.3.3 代码实现\\n​ 我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  \\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\nCopy\\n​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\nCopy\\n​ 在application.yml中配置mapperXML文件的位置\\n\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\nCopy\\n​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n/**\\n * @Author 三更 \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\nCopy\\n4. 自定义失败处理\\n​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。\\n\\n​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。\\n\\n​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n①自定义实现类\\n\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\nCopy\\n/**\\n * @Author 三更  \\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\nCopy\\n②配置给SpringSecurity\\n\\n​\\n\\n​ 先注入对应的处理器\\n\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\nCopy\\n​ 然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\nCopy\\n5. 跨域\\n​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。\\n\\n​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​ 所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\nCopy\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\nCopy\\n6. 遗留小问题\\n其它权限校验方法\\n​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​\\n\\n​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。\\n\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。\\n\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n自定义权限校验方法\\n​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\nCopy\\n​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\nCopy\\n基于配置的权限控制\\n​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\nCopy\\nCSRF\\n​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n认证成功处理器\\n​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\nCopy\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\nCopy\\n认证失败处理器\\n​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\nCopy\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\nCopy\\n登出成功处理器\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\nCopy\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"articleTitle\":\"Spring Security\",\"categoryName\":\"spring\",\"id\":135,\"isFeatured\":0,\"isTop\":1,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:01:44', NULL);
INSERT INTO `t_operation_log` VALUES (1734, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"## 0. 简介\\n\\n​\\t**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​\\t一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​\\t 一般Web应用的需要进行**认证**和**授权**。\\n\\n​\\t\\t**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\\n\\n​\\t\\t**授权：经过认证后判断当前用户是否有权限进行某个操作**\\n\\n​\\t而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n\\n\\n## 1. 快速入门\\n\\n### 1.1 准备工作\\n\\n​\\t我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n~~~~xml\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n② 创建启动类\\n\\n~~~~java\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\n~~~~\\n\\n③ 创建Controller\\n\\n~~~~java\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 1.2 引入SpringSecurity\\n\\n​\\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​\\t必须登陆之后才能对接口进行访问。\\n\\n\\n\\n## 2. 认证\\n\\n### 2.1 登陆校验流程\\n\\n![image20211215094003288.png](https://static.linhaojun.top/aurora/articles/03fc208b0326f9c76804cbd4a2b8d4b8.png)\\n\\n### 2.2 原理初探\\n\\n​\\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n\\n\\n#### 2.2.1 SpringSecurity完整流程\\n\\n​\\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n![image20211214144425527.png](https://static.linhaojun.top/aurora/articles/5e68a45696fe867f79e4eb640c941526.png)\\n\\n​\\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\t\\n\\n​\\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n![image20211214145824903.png](https://static.linhaojun.top/aurora/articles/6bda42b10230521701f848266c8fdad4.png)\\n\\n\\n\\n\\n\\n#### 2.2.2 认证流程详解\\n\\n![image20211214151515385.png](https://static.linhaojun.top/aurora/articles/09386f9d52f0c8c625b5a94884a7178d.png)\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法 \\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n\\n\\n\\n\\n### 2.3 解决问题\\n\\n#### 2.3.1 思路分析\\n\\n登录\\n\\n​\\t①自定义登录接口  \\n\\n​\\t\\t\\t\\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​\\t\\t\\t\\t把用户信息存入redis中\\n\\n​\\t②自定义UserDetailsService \\n\\n​\\t\\t\\t\\t在这个实现类中去查询数据库\\n\\n校验：\\n\\n​\\t①定义Jwt认证过滤器\\n\\n​\\t\\t\\t\\t获取token\\n\\n​\\t\\t\\t\\t解析token获取其中的userid\\n\\n​\\t\\t\\t\\t从redis中获取用户信息\\n\\n​\\t\\t\\t\\t存入SecurityContextHolder\\n\\n#### 2.3.2 准备工作\\n\\n①添加依赖\\n\\n~~~~xml\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\n~~~~\\n\\n② 添加Redis相关配置\\n\\n~~~~java\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author 三更\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\n~~~~\\n\\n③ 响应类\\n\\n~~~~java\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\n~~~~\\n\\n④工具类\\n\\n~~~~java\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\n~~~~\\n\\n⑤实体类\\n\\n~~~~java\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\n~~~~\\n\\n\\n\\n#### 2.3.3 实现\\n\\n##### 2.3.3.1 数据库校验用户\\n\\n​\\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n###### 准备工作\\n\\n​\\t我们先创建一个用户表， 建表语句如下：\\n\\n~~~~mysql\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\n~~~~\\n\\n​\\t\\t引入MybatisPuls和mysql驱动的依赖\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t\\t配置数据库信息\\n\\n~~~~yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n~~~~\\n\\n​\\t\\t定义Mapper接口\\n\\n~~~~java\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\n~~~~\\n\\n​\\t\\t修改User实体类\\n\\n~~~~java\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\n~~~~\\n\\n​\\t\\t配置Mapper扫描\\n\\n~~~~java\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\n~~~~\\n\\n​\\t\\t添加junit依赖\\n\\n~~~~java\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t   测试MP是否能正常使用\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\n~~~~\\n\\n\\n\\n###### 核心代码实现\\n\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\n~~~~\\n\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n```java\\n/**\\n * @Author 三更\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n```\\n\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\\n\\n##### 2.3.3.2 密码加密存储\\n\\n​\\t实际项目中我们不会把密码明文存储在数据库中。\\n\\n​\\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​\\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​\\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​\\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\n~~~~\\n\\n##### 2.3.3.3 登陆接口\\n\\n​\\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​\\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​\\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n~~~~java\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n~~~~\\n\\n​\\t\\n\\n~~~~java\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.4 认证过滤器\\n\\n​\\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​\\t使用userid去redis中获取对应的LoginUser对象。\\n\\n​\\t然后封装Authentication对象存入SecurityContextHolder\\n\\n\\n\\n~~~~java\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.5 退出登陆\\n\\n​\\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 3. 授权\\n\\n### 3.0 权限系统的作用\\n\\n​\\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​\\t总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\\n\\n​\\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​\\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\t\\n\\n### 3.1 授权基本流程\\n\\n​\\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​\\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​\\t然后设置我们的资源所需要的权限即可。\\n\\n### 3.2 授权实现\\n\\n#### 3.2.1 限制访问资源所需权限\\n\\n​\\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​\\t但是要使用它我们需要先开启相关配置。\\n\\n~~~~java\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\n~~~~\\n\\n​\\t然后就可以使用对应的注解。@PreAuthorize\\n\\n~~~~java\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n~~~~\\n\\n#### 3.2.2 封装权限信息\\n\\n​\\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​\\t我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​\\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  \\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n~~~~\\n\\n​\\t\\tLoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\n~~~~java\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n#### 3.2.3 从数据库查询权限信息\\n\\n##### 3.2.3.1 RBAC权限模型\\n\\n​\\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n![image20211222110249727.png](https://static.linhaojun.top/aurora/articles/87839cfbe9dfb7c8ecfd20303ce3d401.png)\\n\\n##### 3.2.3.2 准备工作\\n\\n~~~~sql\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\n~~~~\\n\\n~~~~mysql\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author 三更\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\n~~~~\\n\\n\\n\\n##### 3.2.3.3 代码实现\\n\\n​\\t我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​\\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\n~~~~java\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  \\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\n~~~~\\n\\n​\\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n~~~~xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\n~~~~\\n\\n​\\t在application.yml中配置mapperXML文件的位置\\n\\n~~~~yaml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\n~~~~\\n\\n\\n\\n​\\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n~~~~java\\n/**\\n * @Author 三更 \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n## 4. 自定义失败处理\\n\\n​\\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​\\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​\\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\\n\\n​\\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\\n\\n​\\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n\\n\\n①自定义实现类\\n\\n~~~~java\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n②配置给SpringSecurity\\n\\n​\\t\\n\\n​\\t先注入对应的处理器\\n\\n~~~~java\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\n~~~~\\n\\n​\\t然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n~~~~java\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\n~~~~\\n\\n\\n\\n## 5. 跨域\\n\\n​\\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \\n\\n​\\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​\\t所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n~~~~java\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\n~~~~\\n\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 6. 遗留小问题\\n\\n### 其它权限校验方法\\n\\n​\\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​    \\n\\n​\\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​\\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​\\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n\\n\\n​\\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n### 自定义权限校验方法\\n\\n​\\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n~~~~java\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\n~~~~\\n\\n​\\t 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n~~~~java\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n### 基于配置的权限控制\\n\\n​\\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### CSRF\\n\\n​\\t[CSRF](https://blog.csdn.net/freeking101/article/details/86537087)是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​\\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​\\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n\\n\\n\\n\\n### 认证成功处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​\\t我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 认证失败处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​\\t我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\n~~~~\\n\\n\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 登出成功处理器\\n\\n~~~~java\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n~~~~\\n\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"articleTitle\":\"Spring Security\",\"categoryName\":\"spring\",\"id\":135,\"isFeatured\":0,\"isTop\":1,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:05:26', NULL);
INSERT INTO `t_operation_log` VALUES (1735, '分类模块', '新增或修改', '/admin/categories', 'com.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"算法\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:07:16', NULL);
INSERT INTO `t_operation_log` VALUES (1736, '分类模块', '新增或修改', '/admin/categories', 'com.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"docker\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:07:27', NULL);
INSERT INTO `t_operation_log` VALUES (1737, '文章模块', '上传', '/admin/articles/images', 'com.blog.controller.ArticleController.saveArticleImages', '上传文章图片', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/articles/af392c0c59d6c80294db1f7836a2fbd1.jpg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:08:42', NULL);
INSERT INTO `t_operation_log` VALUES (1738, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"# 算法分享：滑动窗口\\n## 原题描述：\\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\\n## 思路\\n- 定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复\\n- 我们定义不重复子串的开始位置为 start，结束位置为 end\\n- 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符\\n- 无论是否更新 start，都会更新其 map 数据结构和结果 ans。\\n- 时间复杂度：O(n)\\n## 代码实现\\n```java\\nimport java.util.HashMap;\\n\\n/**\\n * 滑动窗口\\n */\\n@SuppressWarnings(\\\"all\\\")\\nclass Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for(int start = 0,end = 0;end < s.length();end++){\\n            char charAt = s.charAt(end);\\n            if(map.containsKey(charAt)){\\n                start = Math.max(map.get(charAt),start);\\n            }\\n            map.put(charAt,end+1);\\n            ans = Math.max(end-start+1,ans);\\n        }\\n        return ans;\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution test = new Solution();\\n        System.out.println(test.lengthOfLongestSubstring(\\\"dvdf\\\"));\\n    }\\n}\\n```\\n\\n\\n\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/af392c0c59d6c80294db1f7836a2fbd1.jpg\",\"articleTitle\":\"滑动窗口算法\",\"categoryName\":\"算法\",\"isFeatured\":0,\"isTop\":0,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:08:49', NULL);
INSERT INTO `t_operation_log` VALUES (1739, 'aurora信息', '修改', '/admin/website/config', 'com.blog.controller.AuroraInfoController.updateWebsiteConfig', '更新网站配置', '[{\"alipayQRCode\":\"\",\"author\":\"长乐予安\",\"authorAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"authorIntro\":\"正青春被编程削去了头发\",\"beianNumber\":\"\",\"csdn\":\"\",\"englishName\":\"changleyuan\",\"gitee\":\"\",\"github\":\"\",\"isCommentReview\":0,\"isEmailNotice\":1,\"isReward\":0,\"juejin\":\"\",\"logo\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"multiLanguage\":1,\"name\":\"长乐予安\",\"notice\":\"\",\"qq\":\"3319023171\",\"qqLogin\":0,\"stackoverflow\":\"\",\"touristAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"twitter\":\"\",\"userAvatar\":\"http://192.168.188.128:9000/aurora/aurora/config/dd22a649ac2f2220257f323e58574a9f.webp\",\"weChat\":\"\",\"websiteCreateTime\":\"2023-10-20\",\"weiXinQRCode\":\"\",\"weibo\":\"\",\"zhihu\":\"\"}]', 'PUT', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:10:43', NULL);
INSERT INTO `t_operation_log` VALUES (1740, '标签模块', '新增或修改', '/admin/tags', 'com.blog.controller.TagController.saveOrUpdateTag', '添加或修改标签', '[{\"tagName\":\"linux\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:12:50', NULL);
INSERT INTO `t_operation_log` VALUES (1741, '分类模块', '新增或修改', '/admin/categories', 'com.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"linux\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:12:58', NULL);
INSERT INTO `t_operation_log` VALUES (1742, '文章模块', '上传', '/admin/articles/images', 'com.blog.controller.ArticleController.saveArticleImages', '上传文章图片', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/articles/753f1e9dcba4a4e591af2c629cc8e271.jpg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:14:37', NULL);
INSERT INTO `t_operation_log` VALUES (1743, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"# 1.目录结构\\n\\n├── bin -> usr/bin # 用于存放二进制命令\\n├── boot # 内核及引导系统程序所在的目录\\n├── dev # 所有设备文件的目录（如磁盘、光驱等）\\n├── etc # 配置文件默认路径、服务启动命令存放目录\\n├── home # 用户家目录，root用户为/root\\n├── lib -> usr/lib # 32位库文件存放目录\\n├── lib64 -> usr/lib64 # 64位库文件存放目录\\n├── media # 媒体文件存放目录\\n├── mnt # 临时挂载设备目录\\n├── opt # 自定义软件安装存放目录\\n├── proc # 进程及内核信息存放目录\\n├── root # Root用户家目录\\n├── run # 系统运行时产生临时文件，存放目录\\n├── sbin -> usr/sbin # 系统管理命令存放目录\\n├── srv # 服务启动之后需要访问的数据目录\\n├── sys # 系统使用目录\\n├── tmp # 临时文件目录\\n├── usr # 系统命令和帮助文件目录\\n└── var # 存放内容易变的文件的目录\\n\\n# 2. ls命令\\n\\nls  仅列出当前目录可见文件 \\nls -l  列出当前目录可见文件详细信息\\nls -h 列出详细信息并以可读大小显示文件大小\\nls -a 列出所有文件（包括隐藏）的详细信息 \\nls --human-readable --size -1 -S --classify # 按文件大小排序 \\ndu -sh * | sort -h # 按文件大小排序(同上)\\n\\n\\n### 通配符\\t\\n\\n含义\\n*代表任意个数个字符\\n?代表任意一个字符，至少 1 个\\n[]表示可以匹配字符组中的任一一个\\n[abc]匹配 a、b、c 中的任意一个\\n[a-f]匹配从 a 到 f 范围内的的任意一个字符\\n\\n# 3.cd命令\\n\\ncd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一\\n注意：Linux 所有的 目录 和 文件名 都是大小写敏感的\\n\\n命令\\t含义\\ncd -\\t可以在最近两次工作目录之间来回切换\\n\\ncd    # 进入用户主目录；\\ncd /  # 进入根目录\\ncd ~  # 进入用户主目录；\\ncd ..  # 返回上级目录（若当前目录为“/“，则执行完后还在“/\\\"；\\\"..\\\"为上级目录的意思）；\\ncd ../..  # 返回上两级目录；\\ncd !$  # 把上个命令的参数作为cd参数使用。\\n\\n相对路径和绝对路径\\n相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置\\n绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置\\n\\n# 4.mv 命令\\n\\n功能：mv命令是move的缩写，可以用来移动文件或者将文件改名（move(rename)files），是Linux系统下常用的命令，经常用来备份文件或者目录\\n\\n格式：mv [选项] [路径] [旧文件名] [新路径] [新文件名]\\n\\n常用选项：\\n\\n选项\\t说明\\n-f\\tforce 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\\n-i\\t若目标文件 (destination) 已经存在时，就会询问是否覆盖\\n注意：\\n\\n如果只移动不改名字，新名字可以不写\\n如果移动的同时改名字，新名字一定要写\\n\\n# 5.cp 命令\\n\\n功能: 复制文件或目录\\n说明：cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息\\n\\n格式：cp [选项] [路径] [旧文件名] [新路径]\\n\\n常用选项表：\\n\\n选项\\t说明\\n-f 或 --force\\t强行复制文件或目录， 不论目的文件或目录是否已经存在\\n-i 或 --interactive\\t覆盖文件之前先询问用户\\n-r\\t递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理\\n-R 或 --recursive\\t递归处理，将指定目录下的文件及子目录一并处理\\n\\n\\n\\n-a：此参数的效果和同时指定\\\"-dpR\\\"参数相同；\\n-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；\\n-f：强行复制文件或目录，不论目标文件或目录是否已存在；\\n-i：覆盖既有文件之前先询问用户；\\n-l：对源文件建立硬连接，而非复制文件；\\n-p：保留源文件或目录的属性；\\n-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；\\n-s：对源文件建立符号连接，而非复制文件；\\n-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；\\n-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；\\n-b：覆盖已存在的文件目标前将目标文件备份；\\n-v：详细显示命令执行的操作。\\n\\n# 6.mkdir命令\\n\\n用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 \\n\\n注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。\\n\\n在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。\\n\\n### 语法\\n\\n```shell\\nmkdir (选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-Z：设置安全上下文，当使用SELinux时有效；\\n-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限；\\n-p或--parents 递归创建目录，若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\\n--version 显示版本信息。\\n```\\n\\n### 权限 \\n\\n文件或目录的权限又分为3种：只读、只写、可执行。\\n\\n权限\\t权限数值\\t二进制\\t具体作用\\nr\\t4\\t00000100\\tread，读取。当前用户可以读取文件内容，当前用户可以浏览目录。\\nw   2\\t00000010\\twrite，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。\\nx    1\\t00000001\\texecute，执行。当前用户可以执行文件，当前用户可以进入目录。\\n依照上面的表格，权限组合就是对应权限值求和，如下：\\n7 = 4 + 2 + 1 读写运行权限\\n5 = 4 + 1 读和运行权限\\n4 = 4 只读权限\\n\\n顺序为user ,group,other ,**所有者权限**，**同组用户的权限**，**其他用户的权限**\\n\\n7 = rwx = 可读，可写，可执行\\n6 = rw- = 可读，可写，不可执行\\n5 = r-x = 可读，不可写，可执行\\n4 = r--\\n3 = -wx\\n2 = -w-\\n1 = --x\\n0 = ---\\n\\n​\\t\\t\\n\\n在目录`/usr/meng`下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问\\n\\n```shell\\nmkdir -m 700 /usr/meng/test\\n```\\n\\n在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问\\n\\n```shell\\nmkdir -p-m 750 bin/os_1\\n```\\n\\n# \\n\\n# 7.touch命令\\n\\n创建文件或修改文件时间\\n如果文件 不存在，可以创建一个空白文件\\n如果文件 已经存在，可以修改文件的末次修改日期\\n\\n**语法：**\\n\\n```\\ntouch [选项] [参数]\\n```\\n\\n-a：或--time=atime或--time=access或--time=use  只更改存取时间；\\n-c：或--no-create  不建立任何文件；\\n-d：<时间日期> 使用指定的日期时间，而非现在的时间；\\n-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；\\n-m：或--time=mtime或--time=modify  只更该变动时间；\\n-r：<参考文件或目录>  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；\\n-t：<日期时间>  使用指定的日期时间，而非现在的时间；\\n--help：在线帮助；\\n--version：显示版本信息。\\n\\n# 8.rm命令\\n\\n- 删除文件或目录\\n  使用 rm 命令要小心，因为文件删除后不能恢复\\n\\n| 选项            |                         含义                          |\\n| --------------- | :---------------------------------------------------: |\\n| -f              |         强制删除，忽略不存在的文件，无需提示          |\\n| -r              | 递归地删除目录下的内容，**删除文件夹 时必须加此参数** |\\n| -d              |   直接把欲删除的目录的硬连接数据删除成0，删除该目录   |\\n| -v              |                显示指令的详细执行过程                 |\\n| -i              |           删除已有文件或目录之前先询问用户            |\\n| -v              |                显示指令的详细执行过程                 |\\n| --preserve-root |                不对根目录进行递归操作                 |\\n\\n\\n\\n# 9.ln命令\\n\\n**ln命令** 用来为文件创建链接，链接类型分为硬链接和符号链接两种，默认的链接类型是硬链接。如果要创建符号链接必须使用\\\"-s\\\"选项。\\n\\n注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。\\n\\n### 语法\\n\\n```shell\\nln [参数] [源文件或目录] [目标文件或目录]\\nln [选项]... [-T] 目标 链接名\\t(第一种格式)\\n　或：ln [选项]... 目标\\t\\t(第二种格式)\\n　或：ln [选项]... 目标... 目录\\t(第三种格式)\\n　或：ln [选项]... -t 目录 目标...\\t(第四种格式)\\n```\\n\\n### 选项\\n\\n```shell\\n-s, --symbolic              # 对源文件建立符号链接，而非硬链接\\n--backup[=CONTROL]      # 为每个已存在的目标文件创建备份文件\\n-b                      # 类似--backup，但不接受任何参数\\n-d, -F, --directory         # 创建指向目录的硬链接(只适用于超级用户)\\n-f, --force                 # 强行删除任何已存在的目标文件\\n-i, --interactive           # 覆盖既有文件之前先询问用户\\n-L, --logical               # 取消引用作为符号链接的目标\\n-n, --no-dereference        # 把符号链接的目的目录视为一般文件\\n-P, --physical              # 直接将硬链接到符号链接\\n-r, --relative              # 创建相对于链接位置的符号链接\\n-S, --suffix=SUFFIX         # 用\\\"-b\\\"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它\\n-t, --target-directory=DIRECTORY # 指定要在其中创建链接的DIRECTORY\\n-T, --no-target-directory   # 将“LINK_NAME”视为常规文件\\n-v, --verbose               # 打印每个链接文件的名称\\n--help      # 显示此帮助信息并退出\\n--version   # 显示版本信息并退出\\n```\\n\\n### 参数\\n\\n- 源文件：指定链接的源文件。如果使用`-s`选项创建符号链接，则“源文件”可以是文件或者目录。创建硬链接时，则“源文件”参数只能是文件。\\n- 目标文件：指定源文件的目标链接文件。\\n\\n```shell\\nnone, off       # 不进行备份(即使使用了--backup 选项)\\nnumbered, t     # 备份文件加上数字进行排序\\nexisting, nil   # 若有数字的备份文件已经存在则使用数字，否则使用普通方式备份\\nsimple, never   # 永远使用普通方式备份\\n```\\n\\n### **实例**\\n\\n将目录`/usr/mengqc/mub1` 下的文件 m2.c 链接到目录 `/usr/liu` 下的文件 a2.c\\n\\n```shell\\ncd /usr/mengqc\\nln /mub1/m2.c /usr/liu/a2.c\\n```\\n\\n在执行ln命令之前，目录`/usr/liu`中不存在a2.c文件。执行ln之后，在`/usr/liu`目录中才有a2.c这一项，表明m2.c和a2.c链接起来（注意，二者在物理上是同一文件），利用`ls -l`命令可以看到链接数的变化。\\n\\n**创建软链接**\\n\\n在目录`/usr/liu`下建立一个符号链接文件abc，使它指向目录`/usr/mengqc/mub1`\\n\\n```shell\\nln -s /usr/mengqc/mub1 /usr/liu/abc\\n```\\n\\n执行该命令后，`/usr/mengqc/mub1`代表的路径将存放在名为`/usr/liu/abc`的文件中。\\n\\n**创建硬链接**\\n\\n给文件创建硬链接，为 `log2022.log` 创建硬链接 `ln2022`，`log2022.log` 与 `ln2022` 的各项属性相同\\n\\n```shell\\nln log2022.log ln2022\\n```\\n\\n输出：\\n\\n```\\n[root@localhost test]# ll\\nlrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -> log2022.log\\n-rw-r--r-- 1 root bin      61 11-13 06:03 log2022.log\\n[root@localhost test]# ln log2022.log ln2022\\n[root@localhost test]# ll\\nlrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -> log2022.log\\n-rw-r--r-- 2 root bin      61 11-13 06:03 ln2022\\n-rw-r--r-- 2 root bin      61 11-13 06:03 log2022.log\\n```\\n\\n## 扩展知识\\n\\nLinux具有为一个文件起多个名字的功能，称为链接。被链接的文件可以存放在相同的目录下，但是必须有不同的文件名，而不用在硬盘上为同样的数据重复备份。另外，被链接的文件也可以有相同的文件名，但是存放在不同的目录下，这样只要对一个目录下的该文件进行修改，就可以完成对所有目录下同名链接文件的修改。对于某个文件的各链接文件，我们可以给它们指定不同的存取权限，以控制对信息的共享和增强安全性。\\n\\n文件链接有两种形式，即硬链接和符号链接。\\n\\nln功能说明：是为某一个文件在另外一个位置建立一个同步的链接，当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。\\n\\n> ⚠️ ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化。\\n\\n### 符号链接(软连接)\\n\\n符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如下所示的abc文件），其中包含它提供链接的另一个文件的路径名，如虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。\\n\\n```shell\\n$ ls -il\\ntotal 0\\n922736 lrwxrwxrwx 1 root root 5 Jun 17 11:27 abc -> a.txt\\n922735 -rw-r--r-- 1 root root 0 Jun 17 11:27 a.txt\\n```\\n\\n1. 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\\n2. 软链接可以 跨文件系统 ，硬链接不可以\\n3. 软链接可以对一个不存在的文件名进行链接\\n4. 软链接可以对目录进行链接\\n\\n与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的索引节点号；而硬链接并没有建立新文件。\\n\\n符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。\\n\\n用`ln -s`命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。\\n\\n符号链接保持了链接与源文件或目录之间的区别：\\n\\n- 删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据。\\n- 在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是l。\\n- 符号链接的大小是其链接文件的路径名中的字节数。\\n- 当用`ls -l`命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如`lrwxrwxrwx … 14 jun 20 10:20 /etc/motd->/original_file`其中，表示“文件大小”的数字“14”恰好说明源文件名`original_file`由14个字符构成。\\n\\n### 硬链接\\n\\n建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如下所示的m2.c文件就在目录mub1和liu中都建立了目录项。\\n\\n1. 硬链接，以文件副本的形式存在。但不占用实际空间。\\n\\n2. 不允许给目录创建硬链接\\n\\n3. 硬链接只有在同一个文件系统中才能创建\\n\\n4. 创建硬链接后，己经存在的文件的索引节点号（inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为1。\\n\\n   在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。\\n\\n   对硬链接有如下限制：\\n\\n   - 不能对目录文件做硬链接。\\n   - 不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统中。\\n\\n# 10.find 命令\\n\\n功能：用来在指定目录下查找文件\\n\\n格式：find [路径] [选项] [操作]\\n\\n### 常用选项\\n\\n-a             \\t\\t\\t\\t\\t\\t\\t\\t\\tand 必须满足两个条件才显示\\n-o            \\t\\t\\t\\t\\t\\t\\t\\t\\t or 只要满足一个条件就显示\\n-name     \\t\\t\\t\\t\\t\\t\\t\\t\\t 按照文件名查找文件\\n-iname     \\t\\t\\t\\t\\t\\t\\t\\t\\t按照文件名查找文件(忽略大小写)\\n\\n-size \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t按照文件大小来查找\\n\\n-type        \\t\\t\\t\\t\\t\\t\\t\\t\\t根据文件类型进行搜索\\n-perm      \\t\\t\\t\\t\\t\\t\\t\\t\\t 按照文件权限来查找文件\\n-user       \\t\\t\\t\\t\\t\\t\\t\\t\\t 按照文件属主来查找文件。\\n-group    \\t\\t\\t\\t\\t\\t\\t\\t\\t  按照文件所属的组来查找文件。\\n-fprint      \\t\\t\\t\\t\\t\\t\\t\\t\\t 文件名：将匹配的文件输出到文件。\\n-newer file1 ! newer file2             查找更改时间比文件file1新但比文件file2旧的文件\\n\\n### 常用动作\\n\\n-print                                            默认动作，将匹配的文件输出到标准输出\\n-exec   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t对匹配的文件执行该参数所给出的命令。相应命令的形式为 \'command\' { } \\\\;，注意{ }和\\\\；之间的空格。\\n-ok     \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\\n-delete \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t将匹配到的文件删除\\n\\n### 实例\\n\\n根据文件名进行匹配\\n1.列出当前目录及子目录下所有文件和文件夹\\n命令：find .\\n\\n2.在/home目录下查找以.txt结尾的文件名\\nfind /home/ -name \\\"*.txt\\\" \\n3.同上，但忽略大小写\\nfind /home -iname \\\"*.txt\\\"\\n\\n4.查找 /home/ 下所有以.txt或.pdf结尾的文件\\n find /home/ -name \\\"*.txt\\\" -o -name \\\"*.pdf\\\"\\n\\n5.查找 /home/ 下所有以a开头和以.txt结尾的文件\\n find /home/ -name \\\"*.txt\\\" -a -name \\\"a*\\\"\\n\\n6.搜索/home目录下txt结尾的文件，并将输出到指定文件中(re.txt)\\n[root@localhost home]# find /home/ -type f -name \\\"*.txt\\\" -fprint /tmp/re.txt \\n\\n7.根据文件类型进行搜索\\n\\n[root@host-136 ~]# find /home/ -type f\\n\\n### 类型参数列\\n\\n​    f 普通文件\\n​    l 符号连接（软连接）\\n​    d 目录\\n​    b 块设备\\n​    s 套接字\\n\\n\\n\\n# 11.grep 命令\\n\\n功能：用于查找文件里符合条件的字符串\\n\\n### 格式\\n\\ngrep [选项] \'查找字符串\' 文件名\\n\\n**grep命令里的匹配模式就是你想要找的东西，可以是普通的文字符号，也可以是正则表达式**\\n\\n### 常用选项\\n\\n-i：在搜索的时候忽略大小写\\n\\n-n：显示结果所在行号\\n\\n-c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数\\n\\n-o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行\\n\\n-v：输出不带关键字的行（反向查询，反向匹配）\\n\\n-w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配\\n\\n-Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after\\n\\n-Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before\\n\\n-Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context\\n\\n-e：实现多个选项的匹配，逻辑or关系\\n\\n-q：静默模式，不输出任何信息，当我们只关心有没有匹配到，却不关心匹配到什么内容时，我们可以使用此命令，然后，使用”echo $?”查看是否匹配到，0表示匹配到，1表示没有匹配到。\\n\\n-P：表示使用兼容perl的正则引擎。\\n\\n-E：使用扩展正则表达式，而不是基本正则表达式，在使用”-E”选项时，相当于使用egrep。\\n\\n\\n\\n# 12.less命令\\n\\n分屏上下翻页浏览文件内容\\n\\n**less命令** 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。\\n\\n### 语法\\n\\n```shell\\nless(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-e：文件内容显示完毕后，自动退出；\\n-f：强制显示文件；\\n-g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；\\n-l：搜索时忽略大小写的差异；\\n-N：每一行行首显示行号；\\n-s：将连续多个空行压缩成一行显示；\\n-S：在单行显示较长的内容，而不换行显示；\\n-x<数字>：将TAB字符显示为指定个数的空格字符。\\n```\\n\\n### 参数\\n\\n文件：指定要分屏显示内容的文件。\\n\\n\\n\\n# 13.cat 命令\\n\\n> **功能**： 查看目标文件的内容\\n\\n**格式**：`cat [选项] 文件名`\\n\\n**常用选项**：\\n\\n| 选项 | 说明               |\\n| ---- | ------------------ |\\n| -b   | 对非空输出行编号   |\\n| -n   | 对输出的所有行编号 |\\n| -s   | 不输出多行空行     |\\n\\ncat (全称 concatenate) 命令是 Linux/类 Unix 操作系统中最常用的命令之一。cat 命令允许我们创建单个或多个文件、查看文件内容、连接文件和重定向终端或文件中的输出。\\n\\n在本文中，我们将了解如何方便地使用 cat 命令及其在 Linux 中的示例。\\n\\n### 1.显示文件内容\\n\\n下面的例子将显示 /etc/passwd 文件。\\n\\n​\\t\\tcat /etc/passwd\\n\\n### 2.终端查看多个文件的内容\\n\\n在下面的示例中，它将显示 rumenz 和 rumenz1 终端中的文件。\\n\\ncat rumenz rumenz1\\n\\n入门小站\\nrumenz.com\\n\\n### 3.用cat命令创建文件\\n\\n我们将创建一个名为 rumenz2 使用以下命令创建文件。\\n\\ncat > rumenz2\\n\\n### 4.等待用户输入，键入所需文本\\n\\n然后按 CTRL+D （按住 Ctrl key 并输入d） 退出。正文将写在rumenz2文件。你可以使用以下命令查看文件的内容cat 命令。\\n\\ncat rumenz2\\n\\nrumenz.com\\n\\n### 5.使用more和less参数的Cat命令\\n\\n如果有大量的内容，屏幕滚动起来非常快，我们可以使用参数more和less\\n\\ncat song.txt | more\\n\\ncat song.txt | less\\n\\n### 6.在文件中显示行号\\n\\n随着 -n 选项你可以看到一个文件的行号 song.txt 在输出端。\\n\\ncat -n song.txt\\n\\n### 7.一次显示多个文件\\n\\n在下面的例子中，我们有三个文件 rumenz, rumenz1, 和 rumenz2,并能够查看这些文件的内容，如上所示。我们需要将每个文件分开;。\\n\\ncat rumenz; cat rumenz1; cat rumenz2\\n\\nThis is a rumenz file\\nThis is the rumenz1 file.\\nThis is rumenz2 file.\\n\\n### 8.使用标准输出和重定向操作符\\n\\n我们可以将文件的标准输出重定向到一个新文件中，否则现有文件中带有 >（大于）符号。仔细，现有的内容rumenz1 将被内容覆盖 rumenz 文件。\\n\\ncat rumenz > rumenz1\\n\\n### 9.使用重定向运算符附加标准输出\\n\\n在现有文件中附加 >>（双大于）符号。这里的内容rumenz 文件将附加在文件的末尾 rumenz1 文件。\\n\\ncat rumenz >> rumenz1\\n\\n### 10.使用重定向运算符重定向标准输入\\n\\n当你将重定向与标准输入一起使用时<（小于符号），它使用文件名 rumenz2 作为命令的输入和输出将显示在终端中。\\n\\ncat < rumenz2\\n\\nThis is rumenz2 file.\\n\\n### 11.重定向包含在单个文件中的多个文件\\n\\n这将创建一个名为 rumenz3 并且所有输出都将重定向到新创建的文件中。\\n\\ncat rumenz rumenz1 rumenz2 > rumenz3\\n\\n### 12.在单个文件中对多个文件的内容进行排序\\n\\n这将创建一个文件 rumenz4 和输出 cat 命令通过管道进行排序，结果将被重定向到新创建的文件。\\n\\n# 14.echo命令\\n\\n 用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。\\n\\n### 语法\\n\\n```shell\\necho(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-e：激活转义字符。\\n```\\n\\n使用`-e`选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：\\n\\n- `\\\\a` 发出警告声；\\n- `\\\\b` 删除前一个字符；\\n- `\\\\c` 不产生进一步输出 (\\\\c 后面的字符不会输出)；\\n- `\\\\f` 换行但光标仍旧停留在原来的位置；\\n- `\\\\n` 换行且光标移至行首；\\n- `\\\\r` 光标移至行首，但不换行；\\n- `\\\\t` 插入tab；\\n- `\\\\v` 与\\\\f相同；\\n- `\\\\\\\\` 插入\\\\字符；\\n- `\\\\nnn` 插入 `nnn`（八进制）所代表的ASCII字符；\\n\\n# 15.覆盖和追加\\n\\n### 1.语法\\n\\n将列表的内容覆盖到文件中:ll >文件\\n\\n将列表的内容追加到文件尾部:ll >>文件\\n\\n将文件1的内容覆盖到文件2中:cat 文件1 > 文件2\\n\\n将文件1的内容追加到文件2的尾部:cat 文件1 >> 文件2\\n\\n将内容写入覆盖到文件中:echo “内容” > 文件\\n\\n将内容写入追加到文件的尾部: echo “内容” >> 文件\\n\\n### 2.功能\\n\\n  指令 > : 如果文件存在，将原来文件的内容覆盖；原文件不存在则创建文件，再添加信息。\\n  指令 >> : 不会覆盖原文件内容，将内容追加到文件的尾部。\\n\\n### 3.常用范例\\n\\n例一：将ls查看信息写入到文件中\\n\\n命令：ll > log.txt\\n例二：将log1.txt的内容覆盖到log4.txt中\\n\\n命令：cat log1.txt > log4.txt\\n\\n  没有log4.txt文件则会自动创建。\\n例三：在log.txt追加内容\\n\\n命令：echo Hello World2 >> log.txt\\n\\n# 16.file命令\\n\\n 用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。\\n\\n### 语法\\n\\n```shell\\nfile(选项)(参数)\\n```\\n\\n表示要确定类型的文件列表（文件或目录）。多个文件之间使用空格分开，可以使用shell通配符匹配多个文件\\n\\n### 选项\\n\\n```shell\\n-b：列出辨识结果时，不显示文件名称；\\n-c：详细显示指令执行过程，便于排错或分析程序执行的情形；\\n-f<名称文件>：指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称；\\n-L：直接显示符号连接所指向的文件类别；\\n-m<魔法数字文件>：指定魔法数字文件；\\n-v：显示版本信息；\\n-z：尝试去解读压缩文件的内容。\\n\\n```\\n\\n# 17.PS 命令\\n\\n功能：用来列出系统中当前正在运行的那些进程，类似于 windows 的任务管理器。\\n\\n格式：ps [选项]\\n\\n常用选项：\\n\\n选项\\t说明\\n-A\\t列出所有的进程 （重要）\\n-ef\\t查看全格式的全部进程 （重要）\\n-w\\t显示加宽可以显示较多的资讯\\n-au\\t显示较详细的资讯\\n-aux\\t显示所有包含其他使用者的行程\\n\\n# 18.**yum命令** \\n\\n是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\\n\\nyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\\n\\n### 语法\\n\\n```shell\\nyum(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-h：显示帮助信息；\\n-y：对所有的提问都回答“yes”；\\n-c：指定配置文件；\\n-q：安静模式；\\n-v：详细模式；\\n-d：设置调试等级（0-10）；\\n-e：设置错误等级（0-10）；\\n-R：设置yum处理一个命令的最大等待时间；\\n-C：完全从缓存中运行，而不去下载或者更新任何头文件。\\n```\\n\\n### 参数\\n\\n```shell\\ninstall：安装rpm软件包；\\nupdate：更新rpm软件包；\\ncheck-update：检查是否有可用的更新rpm软件包；\\nremove：删除指定的rpm软件包；\\nlist：显示软件包的信息；\\nsearch：检查软件包的信息；\\ninfo：显示指定的rpm软件包的描述信息和概要信息；\\nclean：清理yum过期的缓存；\\nshell：进入yum的shell提示符；\\nresolvedep：显示rpm软件包的依赖关系；\\nlocalinstall：安装本地的rpm软件包；\\nlocalupdate：显示本地rpm软件包进行更新；\\ndeplist：显示rpm软件包的所有依赖关系。\\n```\\n\\n# 19.tar命令\\n\\nTar（tape archive）是一种归档文件格式，它通常用于将多个文件打包成一个单一的文件。该文件通常以.tar扩展名结尾。Tar文件没有压缩功能，因此通常与gzip或bzip2等压缩工具一起使用，以创建压缩的归档文件。\\n\\n### 1、tar命令的打包操作\\n\\n创建tar文件的命令是tar，可以使用以下命令创建一个名为archive.tar的tar文件，其中包含目录/ home / user /和文件/home/user/file1和/home/user/file2：\\n\\ntar -cvf archive.tar /home/user/ /home/user/file1 /home/user/file2\\n-c：创建新的tar文件(create 表示建包的意思)\\n\\n-v：显示操作详细信息 （verbose 冗长的，详细，表示命令执行时会显示更多的信息）\\n\\n-f：指定要创建的tar文件的文件名（file 指定tar包的文件名）\\n\\ntar -cvf 打包文件的名字.tar 文件名字或路径\\n1\\n\\n### 2、tar命令的解包操作\\n\\n要将tar文件解压缩到当前目录，可以使用以下命令：\\n\\n***tar -xvf archive.tar***\\n\\n-x：提取文件（extract 提取 取出 表示解包的意思）\\n\\n-v：显示操作详细信息\\n\\n-f：指定要提取的tar文件的文件名\\n\\ntar -xvf 需要解包文件的名字.tar\\n1\\n\\n### 3、tar命令的建立压缩包操作\\n\\n***tar -czvf archive.tar.gz /home/user/ /home/user/file1 /home/user/file2***\\n-c：创建新的tar文件\\n\\n-z：使用gzip压缩工具进行压缩 （表示使用命令gzip进行压缩 扩展名.tar.gz或者.tgz）\\n\\n-v：显示操作详细信息\\n\\n-f：指定要创建的tar文件的文件名\\n\\n### 4、tar命令解压缩包操作\\n\\n要解压缩gzip压缩的tar文件，可以使用以下命令：\\n\\n***tar -xzvf archive.tar.gz***\\n-x：提取文件\\n\\n-z：使用gzip解压缩工具进行解压缩\\n\\n-v：显示操作详细信息\\n\\n-f：指定要提取的tar文件的文件名\\n\\ntar zxvf 解压文件.tar.gz [-C 指定解压到哪个目录]\\n\\n\\n要将tar文件与bzip2压缩工具一起使用，可以使用以下命令将tar文件压缩为bzip2压缩的tar文件：\\n\\n***tar -cjvf archive.tar.bz2 /home/user/ /home/user/file1 /home/user/file2***\\n\\n-c：创建新的tar文件\\n\\n-j：使用bzip2压缩工具进行压缩 （表示使用命令bzip2进行压缩 扩展名.tar.bz2.gz或者.tbz2）\\n\\n-v：显示操作详细信息\\n\\n-f：指定要创建的tar文件的文件名\\n\\n要解压缩gzip压缩的tar文件，可以使用以下命令：\\n\\n***tar -xjvf archive.tar.bz2***-x：提取文件\\n\\n-j：使用bzip2解压缩工具进行解压缩\\n\\n-v：显示操作详细信息\\n\\n-f：指定要提取的tar文件的文件名\\n\\ntar zxvf 解压文件.tar.gz [-C 指定解压到哪个目录]\\n\\n\\n\\n# 20.su命令\\n\\n su是swith user的缩写,在Linux中 su 命令可让用户暂时变更登入的身份,除 root 外变更时须输入所要变更的用户帐号与密码。\\n\\n### 1.语法：\\n\\nsu [参数] [-] [用户帐号]\\n\\n### 2.功能：\\n\\n  变更用户身份，若不指定用户帐号，则预设变更为root。\\n\\n### 3.参数：\\n\\n-c<指令>或--command=<指令> 　\\t\\t\\t\\t\\t\\t执行完指定的指令后，即恢复原来的身份。 \\n-f或--fast 　\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   适用于csh与tsch，使shell不用去读取启动文件。 \\n--l或--login 　\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更PATH变量。  \\n-m,-p或--preserve-environment 　\\t\\t\\t\\t\\t\\t变更身份时，不要变更环境变量。 \\n-s<shell>或--shell=<shell> 　\\t\\t\\t\\t\\t\\t指定要执行的shell（bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell。\\n\\n### 4.常用范例：\\n\\n例一：变更帐号为 root 并在执行 ls 指令后退出变回原使用者\\n\\n命令：su -c ls root\\n例二：切换用户\\n\\n命令： su root\\n\\n  testuser切换成root，相当于用户改成root但是操作的是testuser环境\\n  小权限切换大权限要求输入密码;大权限切换小权限不需要输入密码。\\n  切换用户，只能获得用户的执行权限，不能获得环境变量。\\n例三：切换用户，改变环境变量\\n\\n命令：su - root\\n\\n  testuser切换成root，相当于用户改成root，操作的是root环境。即变更帐号为 root 并改变工作目录至 root 的家目录。\\n  切换到用户并获得该用户的环境变量及执行权限。\\n\\n\\n\\n# 21.vim\\n\\n### 1.vim编辑器的四种模式\\n\\n☆ 命令模式\\n使用VIM编辑器时，默认处于命令模式。在该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作。\\n\\n☆ 编辑模式或输入模式\\n在命令模式下输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑\\n\\n☆ 末行模式\\n在命令模式下输入冒号:即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存、退出等操作\\n\\n☆ 可视化模式\\n可以做一些列选操作（通过方向键选择某些列的内容,类似于Windows鼠标刷黑）\\n可视化模式\\n\\n### 2.VIM四种模式的关系\\n\\n 编辑模式------------字母   i   或   o   或   a   ----------->命令模式\\n\\n可视化模式-----------------字母    v     ----------------->命令模式\\n\\n命令模式----------------输入    ：   或     /    ----------->末行模式\\n\\n末行模式-------输入    ：q！   或      ：wq      --------->退出vim\\n\\n### 3.VIM编辑器的使用\\n\\n1.使用vim打开文件\\n基本语法：\\n\\nvim  文件名称\\n① 如果文件已存在，则直接打开\\n\\n② 如果文件不存在，则vim编辑器会自动在内存中创建一个新文件\\n\\n案例：使用vim命令打开readme.txt文件\\n\\nvim readme.txt\\n\\n\\n\\n2.vim编辑器保存文件\\n在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号:，进入到末行模式，输入wq，代表保存并退出。\\n\\n3.vim编辑器强制退出（不保存）\\n在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号：，进入到末行模式，输入q!，代表强制退出但是不保存文件。\\n\\n##### 1.命令模式下的相关操作\\n\\n☆ 如何进入命令模式\\n答：在Linux操作系统中，当我们使用vim命令直接打开某个文件时，默认进入的就是命令模式。如果我们处于其他模式（编辑模式、可视化模式以及末行模式）可以连续按两次Esc键也可以返回命令模式\\n\\n☆ 命令模式下我们能做什么\\n① 移动光标 ② 复制 粘贴 ③ 剪切 粘贴 删除 ④ 撤销与恢复\\n\\n☆ 移动光标到首行或末行（!）\\n移动光标到首行 => gg\\n\\n移动光标到末行 => G\\n\\n☆ 翻屏\\n向上 翻屏，按键：ctrl + b （before） 或 PgUp\\n\\n向下 翻屏，按键：ctrl + f （after） 或 PgDn\\n\\n向上翻半屏，按键：ctrl + u （up）\\n\\n向下翻半屏，按键：ctrl + d （down）\\n\\n☆ 快速定位光标到指定行（!）\\n行号 + G，如150G代表快速移动光标到第150行。\\n\\n☆ 复制/粘贴（!）\\n① 复制当前行（光标所在那一行）\\n\\n按键：yy\\n\\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\\n\\n② 从当前行开始复制指定的行数，如复制5行，5yy\\n\\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\\n\\n☆ 剪切/删除（!）\\n在VIM编辑器中，剪切与删除都是dd\\n\\n如果剪切了文件，但是没有使用p进行粘贴，就是删除操作\\n\\n如果剪切了文件，然后使用p进行粘贴，这就是剪切操作\\n\\n① 剪切/删除当前光标所在行\\n\\n按键：dd （删除之后下一行上移）\\n\\n粘贴：p\\n\\n注意：dd 严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。\\n\\n② 剪切/删除多行（从当前光标所在行开始计算）\\n\\n按键：数字dd\\n\\n粘贴：p\\n\\n特殊用法：\\n\\n③ 剪切/删除光标所在的当前行（光标所在位置）之后的内容，但是删除之后下一行不上移\\n\\n按键：D （删除之后当前行会变成空白行）\\n\\n☆ 撤销/恢复（!）\\n撤销：u（undo）\\n\\n恢复：ctrl + r 恢复（取消）之前的撤销操作【重做，redo】\\n\\n总结\\n① 怎么进入命令模式（vim 文件名称，在任意模式下，可以连续按两次Esc键即可返回命令模式）\\n\\n② 命令模式能做什么？移动光标、复制/粘贴、剪切/删除、撤销与恢复\\n\\n首行 => gg，末行 => G 翻屏（了解） 快速定位 行号G，如150G\\n\\nyy p 5yy p\\n\\ndd p 5dd p\\n\\nu\\n\\nctrl + r\\n\\n##### 2.末行模式下的相关操作\\n\\n☆ 如何进入末行模式\\n进入末行模式的方法只有一个，在命令模式下使用冒号：的方式进入。\\n\\n☆ 末行模式下我们能做什么\\n文件保存、退出、查找与替换、显示行号、paste模式等等\\n\\n☆ 保存/退出（!）\\n:w => 代表对当前文件进行保存操作，但是其保存完成后，并没有退出这个文件\\n\\n:q => 代表退出当前正在编辑的文件，但是一定要注意，文件必须先保存，然后才能退出\\n\\n:wq => 代表文件先保存后退出（保存并退出）\\n\\n如果一个文件在编辑时没有名字，则可以使用:wq 文件名称，代表把当前正在编辑的文件保存到指定的名称中，然后退出\\n\\n:q! => 代表强制退出但是文件未保存（不建议使用）\\n\\n###### ☆ 查找/搜索（!）\\n\\n切换到命令模式，然后输入斜杠/（也是进入末行模式的方式之一）\\n\\n进入到末行模式后，输入要查找或搜索的关键词，然后回车\\n\\n如果在一个文件中，存在多个满足条件的结果。在搜索结果中切换上/下一个结果：N/n （大写N代表上一个结果，小写n代表next）\\n\\n如果需要取消高亮，则需要在末行模式中输入:noh【no highlight】\\n\\n☆ 文件内容的替换（!）\\n第一步：首先要进入末行模式（在命令模式下输入冒号:）\\n\\n第二步：根据需求替换内容\\n\\n① 只替换光标所在这一行的第一个满足条件的结果（只能替换1次）\\n\\n:s/要替换的关键词/替换后的关键词   +  回车\\n案例：把hello rhel中的 rhel替换为 rhel8\\n\\n切换光标到hello  rhel这一行\\n:s/rhel/rhel8\\n② 替换光标所在这一行中的所有满足条件的结果（替换多次，只能替换一行）\\n\\n:s/要替换的关键词/替换后的关键词/g\\t\\tg=global全局替换\\n案例：把hello rhel中的所有rhel都替换为rhel8\\n\\n切换光标到hello rhel这一行\\n:s/rhel/rhel8/g\\n③ 针对整个文档中的所有行进行替换，只替换每一行中满足条件的第一个结果\\n\\n:%s/要替换的关键词/替换后的关键词\\n案例：把每一行中的第一个hello关键词都替换为hi\\n\\n:%s/hello/hi\\n④ 针对整个文档中的所有关键词进行替换（只要满足条件就进行替换操作）\\n\\n:%s/要替换的关键词/替换后的关键词/g\\n案例：替换整个文档中的hello关键词为hi\\n\\n:%s/hello/hi/g\\n☆ 显示行号\\n基本语法：\\n\\n:set nu\\n【nu = number】，行号\\n取消行号 => :set nonu\\n\\n☆ set paste模式\\n为什么要使用paste模式？\\n\\n问题：在终端Vim中粘贴代码时，发现插入的代码会有多余的缩进，而且会逐行累加。原因是终端把粘贴的文本存入键盘缓存（Keyboard Buffer）中，Vim则把这些内容作为用户的键盘输入来处理。导致在遇到换行符的时候，如果Vim开启了自动缩进，就会默认的把上一行缩进插入到下一行的开头，最终使代码变乱。\\n\\n在粘贴数据之前，输入下面命令开启paste模式\\n:set paste\\n\\n粘贴完毕后，输入下面命令关闭paste模式\\n:set nopaste\\n\\n总结\\n① 如何进入末行模式，必须从命令模式中使用冒号进行切换\\n\\n② 末行模式下能做什么？保存、退出、查找、替换、显示行号以及paste模式\\n\\n③ 保存 => :w\\n\\n④ 退出 => :q，先保存后退出。:wq :wq 文件名称 :q!\\n\\n⑤ 查找功能 => 命令模式输入/斜杠 + 关键词（高亮显示）=> :noh\\n\\n⑥ 替换功能\\n\\n:s/要替换的关键词/替换后的关键词\\n\\n:s/要替换的关键词/替换后的关键词/g\\n\\n:%s/要替换的关键词/替换后的关键词\\n\\n:%s/要替换的关键词/替换后的关键词/g\\n\\n⑦ 显示行号 => :set nu 取消行号 => :set nonu\\n\\n⑧ paste模式 => 将来在粘贴代码的时候为了保存原格式 => 粘贴之前 => :set paste\\n\\n##### 3.编辑模式\\n\\n1）编辑模式的作用\\n编辑模式的作用比较简单，主要是实现对文件的内容进行编辑模式。\\n\\n2）如何进入编辑模式\\n首先你需要进入到命令模式，然后使用小写字母a或小写字母i，进入编辑模式。\\n\\n命令模式 + i ： insert缩写，代表在光标之前插入内容\\n\\n命令模式 + a ： append缩写，代表在光标之后插入内容\\n\\n3）退出编辑模式\\n在编辑模式中，直接按Esc，即可从编辑模式退出到命令模式。\\n\\n##### 4.可视化模式\\n\\n1）如何进入到可视化模式\\n在命令模式中，直接按ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ← →方向键来选中需要复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴\\n\\n退出可视模式按下Esc\\n\\n2）可视化模式复制操作\\n第一步：在命令模式下，直接按小v，进入可视化模式\\n\\n第二步：使用方向键↑ ↓ ← →选择要复制的内容，然后按y键\\n\\n第三步：移动光标，停在需要粘贴的位置，按p键进行粘贴操作\\n\\n3）为配置文件添加#多行注释（!）\\n第一步：按Esc退出到命令模式，按gg切换到第1行\\n\\n第二步：然后按Ctrl+v进入到可视化区块模式（列模式）\\n\\n第三步：在行首使用上下键选择需要注释的多行\\n\\n第四步：按下键盘（大写）“I”键，进入插入模式（Shift + i）\\n\\n第五步：输入#号注释符\\n\\n第六步：输入完成后，连续按两次Esc即可完成添加多行注释的过程\\n\\n4）为配置文件去除#多行注释（!）\\n第一步：按Esc退出到命令模式，按gg切换到第1行\\n\\n第二步：然后按Ctrl+v进入可视化区块模式（列模式）\\n\\n第三步：使用键盘上的方向键的上下选中需要移除的#号注释\\n\\n第四步：直接按Delete键即可完成删除注释的操作\\n\\n# 22.chmod命令\\n\\nchmod命令由于修改文件或者目录的权限\\n\\n\\n\\n##  选项\\n\\n```shell\\n-c, --changes：当文件的权限更改时输出操作信息。\\n--no-preserve-root：不将\'/\'特殊化处理，默认选项。\\n--preserve-root：不能在根目录下递归操作。\\n-f, --silent, --quiet：抑制多数错误消息的输出。\\n-v, --verbose：无论文件是否更改了权限，一律输出操作信息。\\n--reference=RFILE：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。\\n-R, --recursive：对目录以及目录下的文件递归执行更改权限操作。\\n--help：显示帮助信息并退出。\\n--version：显示版本信息并退出。\\n```\\n\\n### 1、字母法：\\n\\nchmod  (u g o a)   (+ - =)   (r w x)   (文件名)\\n\\n以上是chmod的用法，每个括号是一个参数， 前三个括号主要放在一起使用即 chmod + 设置模式 + 文件名；下面先介绍这些参数的意义：\\n\\n[u g o a]    含义\\nu    user 表示该文件的所有者\\ng    group 表示与该文件的所有者属于同一组( group )者，即用户组\\no    other 表示其它用户组\\na    all 表示这三者皆是\\n\\n[+  -  =]    含义\\n\\n+    增加权限\\n\\n-    撤销权限\\n-    =    设定权限\\n\\n[r   w   x]    含义\\nr    read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。\\nw    write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。\\nx    excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。\\n\\n用法：chmod + 设置模式 + 文件名\\n中间的设置模式，要分别对u(user), g(group), o(other)设置权限。\\n\\nchmod u+rwx, g+rwx, o+rwx filename 改命令说明对filename文件， 赋予user、group、other均有read、write、excute的权限\\n\\n## 例子\\n\\n> 参考`man chmod`文档的`DESCRIPTION`段落得知：\\n>\\n> - `u`符号代表当前用户。\\n> - `g`符号代表和当前用户在同一个组的用户，以下简称组用户。\\n> - `o`符号代表其他用户。\\n> - `a`符号代表所有用户。\\n> - `r`符号代表读权限以及八进制数`4`。\\n> - `w`符号代表写权限以及八进制数`2`。\\n> - `x`符号代表执行权限以及八进制数`1`。\\n> - `X`符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限。\\n> - `s`符号代表设置权限suid和sgid，使用权限组合`u+s`设定文件的用户的ID位，`g+s`设置组用户ID位。\\n> - `t`符号代表只有目录或文件的所有者才可以删除目录下的文件。\\n> - `+`符号代表添加目标用户相应的权限。\\n> - `-`符号代表删除目标用户相应的权限。\\n> - `=`符号代表添加目标用户相应的权限，删除未提到的权限。\\n\\n```shell\\nlinux文件的用户权限说明：\\n\\n# 查看当前目录（包含隐藏文件）的长格式。\\nls -la\\n  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules\\n\\n# 第1位如果是d则代表目录，是-则代表普通文件。\\n# 更多详情请参阅info coreutils \'ls invocation\'（ls命令的info文档）的\'-l\'选项部分。\\n# 第2到4位代表当前用户的权限。\\n# 第5到7位代表组用户的权限。\\n# 第8到10位代表其他用户的权限。\\n\\n# 添加组用户的写权限。\\nchmod g+w ./test.log\\n# 删除其他用户的所有权限。\\nchmod o= ./test.log\\n# 使得所有用户都没有写权限。\\nchmod a-w ./test.log\\n# 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。\\nchmod u=rwx, g=rw, o=r ./test.log\\n# 等价的八进制数表示：\\nchmod 764 ./test.log\\n# 将目录以及目录下的文件都设置为所有用户拥有读写权限。\\n# 注意，使用\'-R\'选项一定要保留当前用户的执行和读取权限，否则会报错！\\nchmod -R a=rw ./testdir/\\n# 根据其他文件的权限设置文件权限。\\nchmod --reference=./1.log  ./test.log\\n```\\n\\n\\n\\n### 2、数字法\\n\\n数字法是基于字母法的表示，如果字母法懂了，数字法就好懂，并且易于使用。\\n\\n用法：chmod + 数字组合 + 文件名\\n数字组合一般包含三个数字：\\n\\nr  (read)     ---------------->   4\\n\\nw (write)    ---------------->   2\\n\\nx (excute)  ---------------->   1\\n\\n详解：\\n\\n第一个数字7：代表用户 u 的权限 rwx， 4 (r) + 2 (w) + 1 (x) =  7\\n\\n第二个数字7：代表用户 g 的权限 rwx,    4 (r) + 2 (w) + 1 (x) =  7\\n\\n第三个数字7：代表用户 o 的权限 rwx,    4 (r) + 2 (w) + 1 (x) =  7\\n\\n### 举例说明：\\n\\n数字法：chmod  755 filename    对应    字母法： chmod u+rwx, g+rx, o+rx filename\\n数字法：chmod  751 filename    对应    字母法： chmod u+rwx, g+rx, o+x  filename\\n\\n## 补充\\n\\ndrwxr-xr-x. \\t2\\t \\t\\t\\troot\\t\\t\\t\\t root\\t   98\\t   \\t\\t\\t\\tMay 1 09:57 \\tDocuments\\n\\n-rw-------. \\t1\\t \\t\\t\\t\\troot\\t \\t\\t\\troot \\t1720 \\t\\t\\t\\t\\tApr 6 01:38 \\tanaconda-ks.cfg\\n\\n文件权限     硬链接个数  创建者     创建者所在的组   字节数    最后修改日期      文件名称\\n\\n第一位 为  ‘-’ 表示为文件       \\n\\n第一位 为  ‘d’ 表示为文件夹\\n\\n第一位 为  ‘l’ 表示为链接文件       \\n\\n# 23.chown命令\\n\\n用来变更文件或目录的拥有者或所属群组\\n\\n## 补充说明\\n\\n**chown命令** 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。\\n\\n只有文件主和超级用户才可以便用该命令。\\n\\n### 语法\\n\\n```shell\\nchown(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-c或——changes：效果类似“-v”参数，但仅回报更改的部分；\\n-f或--quite或——silent：不显示错误信息；\\n-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；\\n-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\\n-v或——version：显示指令执行过程；\\n--dereference：效果和“-h”参数相同；\\n--help：在线帮助；\\n--reference=<参考文件或目录>：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；\\n--version：显示版本信息。\\n```\\n\\n### 参数\\n\\n用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者；\\n文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。\\n\\n### 实例\\n\\n将目录`name.txt`文件的文件主改成 CHY：\\n\\n```shell\\nchown CHY name.txt \\n```\\n\\n\\n\\n将目录`/usr/meng`及其下面的所有文件、子目录的文件主改成 liu：\\n\\n```shell\\nchown -R liu /usr/meng\\n```\\n\\n# 24.shell编程\\n\\n## 两种方式执行shell脚本\\n\\n第一种：给文件增加执行权限\\n\\n[root@localhost ~]$ chmod u+x test.sh\\n[root@localhost ~]$ ./test.sh  #绝对路径或相对路径执行\\n第二种（了解）：通过Bash调用执行脚本\\n\\n[root@localhost ~]$ bash test.sh\\n\\n## 变量的命名规则\\n\\n在定义变量时，有一些规则需要遵守:\\n\\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\\n等号左右两侧不能有空格，可以使用下划线“_”，变量的值如果有空格，需要使用单引号或双引号包括。如:“test=“hello world!””。其中双引号括起来的内容“$”，“(”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。\\n不能使用标点符号，不能使用bash里的关键字（可用help命令查看保留关键字）。\\n环境变量建议大写，便于区分\\n如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含\\\"$变量名\\\"或用${变量名}包含变量名。\\n[root@localhost ~]$ test=123\\n[root@localhost ~]$ test=\\\"$test\\\"456\\n[root@localhost ~]$ echo $test\\n123456\\n#叠加变量test，变量值变成了123456\\n[root@localhost ~]$ test=${test}789\\n[root@localhost ~]$ echo $test\\n123456789\\n#再叠加变量test，变量值编程了123456789\\n关于单双引号的问题：\\n双引号能够识别变量，双引号能够实现转义（类似于“\\\\*”）\\n单引号是不能识别变量，只会原样输出，单引号是不能转义的\\n\\n## shell中特殊符号\\n\\n符号\\t作用\\n’ ’\\t单引号。在单引号中所有的特殊符号，如“$”和”(反引号)都没有特殊含义。单引号括起来的都是普通字符，***会原样输出***\\n“ ”\\t双引号。在双引号中特殊符号都没有特殊含义，但是“$”，“`”（esc键下面）和“\\\\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。\\n· ·\\t反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和( ) 作 用 一 样 ， 不过推荐使用()，因为反引号非常容易看错。\\n$()\\t和反引号作用一样，用来引用系统命令。(推荐使用)\\n()\\t用于一串命令执行时，()中的命令会在子Shell中运行\\n{}\\t用于一串命令执行时，{ }中的命令会在当前Shell中执行。也可以用于变量变形与替换。\\n[ ]\\t用于变量的测试。\\n\\n在Shell脚本中，#开头的行代表注释。\\n\\n$\\t用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。\\n\\\\\\t转义符，跟在\\\\之后的特殊符号将失去特殊含义，变为普通字符。如$将输出“$”符号，而不当做是变量引用。\\n\\n## 单引号和双引号\\n\\n[root@localhost ~]$ name=sc\\n#定义变量name 的值是sc\\n[root@localhost ~]$ echo \'$name\'\\n$name\\n#如果输出时使用单引号，则$name原封不动的输出\\n[root@localhost ~]$ echo \\\"$name\\\"\\nsc\\n#如果输出时使用双引号，则会输出变量name的值 sc\\n\\n[root@localhost ~]$ echo `date`\\n2018年10月21日星期一18:16:33 CST\\n#反引号括起来的命令会正常执行\\n[root@localhost ~]$ echo \'`date`\'\\n`date`\\n#但是如果反引号命令被单引号括起来，那么这个命令不会执行，―date`会被当成普通字符输出\\n[root@localhost ~]$ echo \\\"`date\'\\\"\\n2018年10月21日星期一18:14:21 CST\\n#如果是双引号括起来，那么这个命令又会正常执行\\n反引号\\n\\n[root@localhost ~]$ echo ls\\nls\\n#如果命令不用反引号包含，命令不会执行，而是直接输出\\n[root@localhost ~]$ echo `ls`\\nanaconda-ks.cfginstall.loginstall.log.syslog sh test testfile\\n#只有用反引号包括命令，这个命令才会执行\\n[root@localhost ~]$ echo $(date)\\n2018年10月21日星期一18:25:09 CST\\n#使用$(命令)的方式也是可以的\\n\\n## 变量操作\\n\\n创建普通变量：name=“test”，组要注意的是等号两边不能有空格。\\n创建局部变量：local name=“test”，使用local修饰的变量在函数体外无法访问，只能在函数体中使用。\\n创建只读变量：name=“only_read” -> readonly name，这种变量不可以被修改。\\n使用变量：echo $name或者echo ${name}\\n删除变量：unset name，删除之后的变量无法被访问，需要注意无法删除只读变量。\\n3.1.3 字符串变量\\n3.1.3.1 字符串变量的创建\\n使用单引号创建：var=\'test\'。\\n这种方式创建的变量只能原样输出，变量无效，我们可以借用c中的“字符串常量”的定义理解这种特性。除此以外，单引号中不能出现单独的单引号，转义也是不可以的。\\n使用双引号创建：var=\\\"my name is ${name}\\\"，这种方式创建的字符串变量有效，也可以出现转义符。\\n3.1.3.2 拼接字符串\\n字面量拼接\\nstr01=\\\"1\\\"\\\"2\\\"或者str01=\\\"1\\\"\'2\'，这样就将1和2两个字符拼接在了一起。需要注意的是两个串之间不可以有空格。\\n变量拼接\\nstr03=${part01}${part02}或str04=${part01}\\\"end\\\"或str05=\\\"${part01} ${part02}\\\"这三种方式都可以拼接字符串变量。\\n命令拼接\\nstr02= date“end”，这里的date是一个shell命令，需要使用引用，具体如下 \\n\\n# 25.wc命令\\n\\n统计文件的字节数、字数、行数\\n\\n## 补充说明\\n\\n**wc命令** 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。\\n\\n### 语法\\n\\n```shell\\nwc(选项)(参数)\\nwc [选项]... [文件]...\\nwc [选项]... --files0-from=F\\n```\\n\\n### 选项\\n\\n```shell\\n-c # 统计字节数，或--bytes：显示Bytes数。\\n-l # 统计行数，或--lines：显示列数。\\n-m # 统计字符数，或--chars：显示字符数。\\n-w # 统计字数，或--words：显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。\\n-L # 打印最长行的长度，或--max-line-length。\\n-help     # 显示帮助信息。\\n--version # 显示版本信息。\\n```\\n\\n### 参数\\n\\n文件：需要统计的文件列表。\\n\\n## 例子\\n\\n```shell\\nwc -l *       # 统计当前目录下的所有文件行数及总计行数。\\nwc -l *.js    # 统计当前目录下的所有 .js 后缀的文件行数及总计行数。\\nfind  . * | xargs wc -l # 当前目录以及子目录的所有文件行数及总计行数。\\n```\\n\\n查看文件的行数、单词数、字节数\\n\\n```shell\\nwc test.txt\\n# 输出结果\\n7     8     70     test.txt\\n# 行数 单词数 字节数 文件名\\n```\\n\\n用wc命令怎么做到只打印统计数字不打印文件名\\n\\n```shell\\nwc -l < test.txt\\n# 输出结果\\n7\\n```\\n\\n用来统计当前目录下的文件数(不包含隐藏文件)\\n\\n```shell\\n# 要去除TOTAL行\\nexpr $(ls -l | wc -l) - 1\\n# 输出结果\\n```\\n\\n# 26.groupadd命令\\n\\n用于创建一个新的工作组\\n\\n## 补充说明\\n\\n**groupadd命令** 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。\\n\\n### 语法\\n\\n```shell\\ngroupadd(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-g：指定新建工作组的id；\\n-r：创建系统工作组，系统工作组的组ID小于500；\\n-K：覆盖配置文件“/ect/login.defs”；\\n-o：允许添加组ID号不唯一的工作组。\\n```\\n\\n### 参数\\n\\n组名：指定新建工作组的组名。\\n\\n### 实例\\n\\n建立一个新组，并设置组ID加入系统：\\n\\n```shell\\ngroupadd -g 344 jsdigname\\n```\\n\\n此时在`/etc/passwd`文件中产生一个组ID（GID）是344的项目。\\n\\n# 27.groupdel命令\\n\\n用于删除指定的工作组\\n\\n## 补充说明\\n\\n**groupdel命令** 用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。\\n\\n### 语法\\n\\n```shell\\ngroupdel(参数)\\n```\\n\\n### 参数\\n\\n组：要删除的工作组名。\\n\\n### 实例\\n\\n```shell\\ngroupadd damon  //创建damon工作组\\ngroupdel damon  //删除这个工作组\\n```\\n\\n# 28.useradd命令\\n\\n创建的新的系统用户\\n\\n## 补充说明\\n\\n**useradd命令** 用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在`/etc/passwd`文本文件中。\\n\\n在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd命令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中， **adduser命令** 则是useradd命令的符号连接，两者实际上是同一个指令。\\n\\n### 语法\\n\\n```shell\\nuseradd(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-c<备注>：加上备注文字。备注文字会保存在passwd的备注栏位中；\\n-d<登入目录>：指定用户登入时的启始目录；\\n-D：变更预设值；\\n-e<有效期限>：指定帐号的有效期限；\\n-f<缓冲天数>：指定在密码过期后多少天即关闭该帐号；\\n-g<群组>：指定用户所属的群组；\\n-G<群组>：指定用户所属的附加群组；\\n-m：自动建立用户的登入目录；\\n-M：不要自动建立用户的登入目录；\\n-n：取消建立以用户名称为名的群组；\\n-r：建立系统帐号；\\n-s<shell>：指定用户登入后所使用的shell；\\n-u<uid>：指定用户id。\\n```\\n\\n### 参数\\n\\n用户名：要创建的用户名。\\n\\n### 实例\\n\\n新建用户加入组：\\n\\n```shell\\nuseradd –g sales jack –G company,employees    //-g：加入主要组、-G：加入次要组\\n```\\n\\n建立一个新用户账户，并设置ID：\\n\\n```shell\\nuseradd caojh -u 544\\n```\\n\\n需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。\\n\\n# 29.userdel命令\\n\\n用于删除给定的用户以及与用户相关的文件\\n\\n## 补充说明\\n\\n**userdel命令** 用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。\\n\\n### 语法\\n\\n```shell\\nuserdel(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-f：强制删除用户，即使用户当前已登录；\\n-r：删除用户的同时，删除与用户相关的所有文件。\\n```\\n\\n### 参数\\n\\n用户名：要删除的用户名。\\n\\n### 实例\\n\\nuserdel命令很简单，比如我们现在有个用户linuxde，其家目录位于`/var`目录中，现在我们来删除这个用户：\\n\\n```shell\\nuserdel linuxde       # 删除用户linuxde，但不删除其家目录及文件；\\nuserdel -r linuxde    # 删除用户linuxde，其家目录及文件一并删除；\\n```\\n\\n请不要轻易用`-r`选项；他会删除用户的同时删除用户所有的文件和目录，切记如果用户目录下有重要的文件，在删除前请备份。\\n\\n其实也有最简单的办法，但这种办法有点不安全，也就是直接在`/etc/passwd`中删除您想要删除用户的记录；但最好不要这样做，`/etc/passwd`是极为重要的文件，可能您一不小心会操作失误。\\n\\n# 30.usermod命令\\n\\n用于修改用户的基本信息\\n\\n## 补充说明\\n\\n**usermod命令** 用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在server上更动相关的NIS设定。\\n\\n### 语法\\n\\n```shell\\nusermod(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-c<备注>：修改用户帐号的备注文字；\\n-d<登入目录>：修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用；\\n-m<移动用户家目录>:移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。\\n-e<有效期限>：修改帐号的有效期限；\\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\\n-g<群组>：修改用户所属的群组；\\n-G<群组>；修改用户所属的附加群组；\\n-l<帐号名称>：修改用户帐号名称；\\n-L：锁定用户密码，使密码无效；\\n-s<shell>：修改用户登入后所使用的shell；\\n-u<uid>：修改用户ID；\\n-U:解除密码锁定。\\n```\\n\\n### 参数\\n\\n登录名：指定要修改信息的用户登录名。\\n\\n### 实例\\n\\n将 newuser2 添加到组 staff 中：\\n\\n```shell\\nusermod -G staff newuser2\\n```\\n\\n修改newuser的用户名为newuser1：\\n\\n```shell\\nusermod -l newuser1 newuser\\n```\\n\\n锁定账号newuser1：\\n\\n```shell\\nusermod -L newuser1\\n```\\n\\n解除对newuser1的锁定：\\n\\n```shell\\nusermod -U newuser1\\n```\\n\\n增加用户到用户组中:\\n\\n```shell\\napk add shadow # 安装 shadow 包, usermod 命令包含在 usermod 中\\nusermod -aG group user # 添加用户到用户组中\\n```\\n\\n`-a` 参数表示附加，只和 `-G` 参数一同使用，表示将用户增加到组中。\\n\\n修改用户家目录：\\n\\n```\\n[root@node-1 ~]# useradd lutixiaya\\n[root@node-1 ~]# ls /home\\nlutixiaya\\n[root@node-1 ~]# usermod -md /data/new_home lutixiaya\\n[root@node-1 ~]# ls /home/\\n[root@node-1 ~]# ls /data/\\nnew_home\\n```\\n\\n# 31.getent命令\\n\\ngetent   passwd   查看系统中的用户    和   cat /etc/passwd  效果一样\\n\\n用户名：密码（X）：用户ID： 组ID：描述信息（无用）：Home目录：执行终端（默认为bash）\\n\\ngetent group   查询 系统中的组信息    和   cat /etc/group  效果一样\\n\\n组名称：组的认证（X）：组ID\\n\\n\\n\\n# 32.条件判断\\n\\n## 整数判断\\n\\n常用参数：\\n判断参数\\t含义\\n-eq ==\\t相等\\n-ne <> !=\\t不等\\n-gt\\t大于\\n-lt\\t小于\\n-ge\\t大于等于\\n-le\\t小于等于\\n\\n## 字符串判断\\n\\n常用参数：\\n判断参数\\t含义\\n-z\\t判断是否为空字符串，字符串长度为0则成立\\n-n\\t判断是否为非空字符串，字符串长度不为0则成立\\nstring1 = string2\\t判断字符串是否相等\\nstring1 != string2\\t判断字符串是否相不等\\n\\n## 文件类型判断\\n\\n常用参数：\\n判断参数\\t含义\\t说明\\n-e\\t判断文件是否存在（link文件指向的也必须存在）\\texists\\n-f\\t判断文件是否存在并且是一个普通文件\\tfile\\n-d\\t判断文件是否存在并且是一个目录\\tdirectory\\n-L\\t判断文件是否存在并且是一个软连接文件\\tsoft link\\n-b\\t判断文件是否存在并且是一个块设备文件\\tblock\\n-S\\t判断文件是否存在并且是一个套接字文件\\tsocket\\n-c\\t判断文件是否存在并且是一个字符设备文件\\tchar\\n-p\\t判断文件是否存在并且是一个命名管道文件\\tpipe\\n\\n###### ***-s\\t判断文件是否存在并且是一个非空文件（有内容）\\tis not empty***\\n\\n文件内容是否为空的判断\\n\\n## 文件权限判断\\n\\n常用参数：\\n判断参数\\t含义\\n-r\\t当前用户对其是否可读\\n-w\\t当前用户对其是否可写\\n-x\\t当前用户对其是否可执行\\n-u\\t是否有suid，高级权限冒险位\\n-g\\t是否sgid，高级权限强制位\\n-k\\t是否有t位，高级权限粘滞位 (创建者/root才能删除)\\n\\n## 文件新旧判断\\n\\n常用参数：\\n说明：这里的新旧指的是文件的修改时间。\\n判断参数\\t含义\\nfile1 -nt file2\\t比较file1是否比file2新\\nfile1 -ot file2\\t比较file1是否比file2旧\\nfile1 -ef file2\\t比较是否为同一个文件，或者用于判断硬连接，是否指向同一个inode\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/753f1e9dcba4a4e591af2c629cc8e271.jpg\",\"articleTitle\":\"linux基本命令\",\"categoryName\":\"linux\",\"isFeatured\":0,\"isTop\":0,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:14:42', NULL);
INSERT INTO `t_operation_log` VALUES (1744, '分类模块', '新增或修改', '/admin/categories', 'com.blog.controller.CategoryController.saveOrUpdateCategory', '添加或修改分类', '[{\"categoryName\":\"redis\"}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:21:54', NULL);
INSERT INTO `t_operation_log` VALUES (1745, '文章模块', '上传', '/admin/articles/images', 'com.blog.controller.ArticleController.saveArticleImages', '上传文章图片', 'file', 'POST', '{\"code\":20000,\"data\":\"http://192.168.188.128:9000/aurora/aurora/articles/4183a275d4e77860cc96a2ac14b2a03f.jpg\",\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:22:51', NULL);
INSERT INTO `t_operation_log` VALUES (1746, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"# **redis 常用命令**\\n\\n### **服务器相关命令**\\n\\nping ： 检测连接是否存活\\necho： 在命令行打印一些内容\\nquit、exit： 退出客户端\\nshutdown： 退出服务器端\\ninfo： 返回redis相关信息\\nconfig get dir/* 实时传递接收的请求\\nshowlog： 显示慢查询\\nselect n： 切换到数据库n，redis默认有16个数据库（DB 0~DB 15），默认使用的第0个\\ndbsize： 查看当前数据库大小\\nmove key n： 不同数据库之间数据是不能互通的，move移动键到指定数据库\\nflushdb： 清空当前数据库中的键值对。\\nflushall： 清空所有数据库的键值对。\\n\\n### **key相关命令**\\n\\n在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。\\n\\n常用命令：\\n\\nkeys * ：查看当前数据库中所有的key\\ndbsize： 键总数\\nexists key： 检查键是否存在\\ndel key [key …]： 删除键\\nexpire key seconds： 键过期\\nttl key： 获取键的有效时长\\npersist key： 移除键的过期时间\\ntype key： 键的数据结构类型\\nrandomkey： 随机返回数据库中一个键\\nrename key1 key2 ： 重命名\\nrenamex key1 key2 ： 当key2不存在时，key1重命名\\n\\n### **五大数据类型**\\n\\nRedis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。其通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：\\n\\n字符串类型： string\\n哈希类型： hash\\n列表类型： list\\n集合类型： set\\n有序集合类型： sortedset（zset）\\n\\n### **String(字符串)**\\n\\n字符串类型是Redis最基础的数据结构，其它的几种数据结构都是在字符串类型基础上构建的，字符串的值可以是：字符串、数字、二进制，但其值最大不能超过512M。\\n\\n使用场景： 缓存、计数器、对象存储缓存（共享session）、限速\\n\\n常用命令：\\n\\nset key value： 设置一个key的value值\\nsetnx key value： 仅当key不存在时进行set\\nsetex key seconds value： set 键值对并设置过期时间\\nmset key value [key value …]： 设置多个key value\\nmsetnx key1 value1 [key2 value2…]： 批量设置键值对，仅当参数中所有的key都不存在时执行，原子性操作，一起成功，一起失败\\nget key： 返回key的value\\nmget key [key …] ： 批量获取多个key保存的值\\nexists key [key …]： 查询一个key是否存在\\ndecr/incr key： 将指定key的value数值进行+1/-1(仅对于数字)\\nincrby/decrbyB key n： 按指定的步长对数值进行加减\\nincrbyfloat key n： 为数值加上浮点型数值\\nappend key value： 向指定的key的value后追加字符串\\nstrlen key： 返回key的string类型value的长度。\\ngetset key value： 设置一个key的value，并获取设置前的值，如果不存在则返回null\\nsetrange key offset value： 设置指定位置的字符\\ngetrange key start end： 获取存储在key上的值的一个子字符串\\n\\n### **Hash（哈希）**\\n\\n几乎所有的编程语言都提供了哈希（hash）结构，Redis中 hash 是一个string类型的field和value的映射表value={{field1,value1},{field2,value2}…}，可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。\\n\\n应用场景： 用户信息缓存\\n\\n常用命令：\\n\\nhset key field value： 将哈希表 key 中的字段 field 的值设为 value。重复设置同一个field会覆盖,返回0\\nhmset key field1 value1 [field2 value2…]： 同时将多个 field-value (域-值)对设置到哈希表 key 中。\\nhsetnx key field value： 只有在字段 field不存在时，设置哈希表字段的值。\\nhget key field value： 获取存储在哈希表中指定字段的值\\nhmget key field1 [field2…]： 获取所有给定字段的值\\nhexists key field： 查看哈希表 key 中，指定的字段是否存在。\\nhdel key field1 [field2…]： 删除哈希表key中一个/多个field字段\\nhlen key： 获取哈希表中字段的数量\\nhkeys key： 获取所有字段field\\nhvals key： 获取哈希表中所有值value\\nhgetall key： 获取在哈希表key 的所有字段和值\\nhincrby key field n： 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段\\nhincrbyfloat key field n： 为哈希表 key 中的指定字段的浮点数值加上增量 n。\\nhscan key cursor [MATCH pattern] [COUNT count]： 迭代哈希表中的键值对。\\n\\n### **List(列表)**\\n\\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），也可以获取指定范围指定下标的元素等。一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\\n\\n两个特点：\\n1.列表中的元素是有序的，可以通过索引下标获取某个元素霍某个某个范围内的元素列表\\n2.列表中的元素可以是重复的\\n\\n使用场景： 消息队列、栈、文章列表等。\\n\\n常用指令：\\n\\n添加操作\\nlpush/rpush key value1[value2…]： 从左边/右边向列表中PUSH值(一个或者多个)\\nlpushx/rpushx key value： 向已存在的列名中push值（一个或者多个），list不存在 lpushx失败\\nlinsert key before|after pivot value： 在指定列表元素的前/后 插入value\\n查找操作\\nlindex key index： 通过索引获取列表元素\\nlrange key start end： 获取list 起止元素 （索引从左往右 递增）\\nllen key： 查看列表长度\\n删除操作\\nlpop/rpop key： 从最左边/最右边移除值 并返回\\nlrem key count value： count >0：从头部开始搜索 然后删除指定的value 至多删除count个 count < 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。\\nltrim key start end： 通过下标截取指定范围内的列表\\nrpoplpush source destination： 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部\\n修改操作\\nlset key index value： 通过索引为元素设值\\n阻塞操作\\nblpop/brpop key1[key2] timout： 移出并获取列表的第一个/最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\\nbrpoplpush source destination timeout： 和rpoplpush功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\\n\\n### **Set(集合）**\\n\\nRedis的Set是string类型的无序集合，我们不能通过索引获取元素。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\\n\\n应用场景： 标签（tag）\\n\\n常用命令：\\n\\n集合内操作\\nsadd key member1[member2…]： 向集合中无序增加一个/多个成员\\nsrem key member1[member2…]： 移除集合中一个/多个成员\\nscard key： 获取集合的成员数\\nsmembers key： 返回集合中所有的成员\\nsismember key member： 查询member元素是否是集合的成员，若存在返回1，不存在返回0\\nsrandmember key [count]： 随机返回集合中count个成员，count缺省值为1\\nspop key [count]： 随机移除并返回集合中count个成员，count缺省值为1\\n集合间操作\\nsinter key1 [key2…]： 返回所有集合的交集\\nsinterstore destination key1[key2…]： 在SINTER的基础上，存储结果到集合中。覆盖\\nsunion key1 [key2…]： 返回所有集合的并集\\nsunionstore destination key1 [key2…]： 在SUNION的基础上，存储结果到及和张。覆盖\\nsdiff key1[key2…]： 返回所有集合的差集 key1- key2 - …\\nsdiffstore destination key1[key2…]： 在SDIFF的基础上，将结果保存到集合中。覆盖\\nsmove source destination member： 将source集合的成员member移动到destination集合\\nsscan key [MATCH pattern] [COUNT count]： 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分\\n\\n\\n\\n### **Zset（有序集合）**\\n\\n在有序集合中保留了不能有重复成员的特性，但其中的成员是可以排序的，每一个元素都会关联一个double类型的分数（score）作为排序依据，score相同时按字典顺序排序。redis正是通过分数来为集合中的成员进行从小到大的排序。\\n\\n应用场景： 排行榜系统，成绩单，工资表\\n\\n常用命令：\\n\\n集合内\\nzadd key score member1 [score2 member2]： 向有序集合添加一个或多个成员，或者更新已存在成员的分数\\nzcard key： 获取有序集合的成员数\\nzscore key member： 返回有序集中，成员的分数值\\nzcount key min max： 计算在有序集合中指定区间score的成员数\\nzlexcount key min max： 在有序集合中计算指定字典区间内成员数量\\nzincrby key n member： 有序集合中对指定成员的分数加上增量 n\\nzscan key cursor [MATCH pattern] [COUNT count]： 迭代有序集合中的元素（包括元素成员和元素分值）\\n范围查询\\nzrank key member： 返回有序集合中指定成员的索引\\nzrevrank key member： 返回有序集合中指定成员的索引，从大到小排序\\nzrange key start end： 通过索引区间返回有序集合成指定区间内的成员\\nzrevrange key start end： 通过索引区间返回有序集合成指定区间内的成员，分数从高到底\\nzrangebylex key min max： 通过字典区间返回有序集合的成员\\nzrevrangebylex key max min： 按字典顺序倒序返回有序集合的成员\\nzrangebyscore key min max： 返回有序集中指定分数区间内的成员 -inf 和 +inf分别表示最小最大值，只支持开区间\\nzrevrangebyscore key max min： 返回有序集中指定分数区间内的成员，分数从高到低排序\\n删除操作\\nzrem key member1 [member2…]： 移除有序集合中一个/多个成员\\nzremrangebylex key min max： 移除有序集合中给定的字典区间的所有成员\\nzremrangebyrank key start stop： 移除有序集合中给定的排名区间的所有成员\\nzremrangebyscore key min max： 移除有序集合中给定的分数区间的所有成员\\n集合间操作\\nzinterstore destination numkeyskey1 [key2 …]： 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score\\nzunionstore destination numkeys key1 [key2…]： 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/4183a275d4e77860cc96a2ac14b2a03f.jpg\",\"articleTitle\":\"redis常用命令\",\"categoryName\":\"redis\",\"isFeatured\":0,\"isTop\":0,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:22:53', NULL);
INSERT INTO `t_operation_log` VALUES (1747, '说说模块', '新增或修改', '/admin/talks', 'com.blog.controller.TalkController.saveOrUpdateTalk', '保存或修改说说', '[{\"content\":\"ES搜索太占内存嘞，已关闭(反正文章也不多)\",\"images\":\"\",\"isTop\":1,\"status\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:27:24', NULL);
INSERT INTO `t_operation_log` VALUES (1748, '说说模块', '新增或修改', '/admin/talks', 'com.blog.controller.TalkController.saveOrUpdateTalk', '保存或修改说说', '[{\"content\":\"ES搜索太占内存嘞，已关闭(反正发布的文章也不多)\",\"id\":68,\"images\":\"\",\"isTop\":1,\"status\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 18:28:14', NULL);
INSERT INTO `t_operation_log` VALUES (1749, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"# 1.目录结构\\n\\n├── bin -> usr/bin # 用于存放二进制命令\\n├── boot # 内核及引导系统程序所在的目录\\n├── dev # 所有设备文件的目录（如磁盘、光驱等）\\n├── etc # 配置文件默认路径、服务启动命令存放目录\\n├── home # 用户家目录，root用户为/root\\n├── lib -> usr/lib # 32位库文件存放目录\\n├── lib64 -> usr/lib64 # 64位库文件存放目录\\n├── media # 媒体文件存放目录\\n├── mnt # 临时挂载设备目录\\n├── opt # 自定义软件安装存放目录\\n├── proc # 进程及内核信息存放目录\\n├── root # Root用户家目录\\n├── run # 系统运行时产生临时文件，存放目录\\n├── sbin -> usr/sbin # 系统管理命令存放目录\\n├── srv # 服务启动之后需要访问的数据目录\\n├── sys # 系统使用目录\\n├── tmp # 临时文件目录\\n├── usr # 系统命令和帮助文件目录\\n└── var # 存放内容易变的文件的目录\\n\\n# 2. ls命令\\n\\nls  仅列出当前目录可见文件 \\nls -l  列出当前目录可见文件详细信息\\nls -h 列出详细信息并以可读大小显示文件大小\\nls -a 列出所有文件（包括隐藏）的详细信息 \\nls --human-readable --size -1 -S --classify # 按文件大小排序 \\ndu -sh * | sort -h # 按文件大小排序(同上)\\n\\n\\n### 通配符\\t\\n\\n含义\\n*代表任意个数个字符\\n?代表任意一个字符，至少 1 个\\n[]表示可以匹配字符组中的任一一个\\n[abc]匹配 a、b、c 中的任意一个\\n[a-f]匹配从 a 到 f 范围内的的任意一个字符\\n\\n# 3.cd命令\\n\\ncd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一\\n注意：Linux 所有的 目录 和 文件名 都是大小写敏感的\\n\\n命令\\t含义\\ncd -\\t可以在最近两次工作目录之间来回切换\\n\\ncd    # 进入用户主目录；\\ncd /  # 进入根目录\\ncd ~  # 进入用户主目录；\\ncd ..  # 返回上级目录（若当前目录为“/“，则执行完后还在“/\\\"；\\\"..\\\"为上级目录的意思）；\\ncd ../..  # 返回上两级目录；\\ncd !$  # 把上个命令的参数作为cd参数使用。\\n\\n相对路径和绝对路径\\n相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置\\n绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置\\n\\n# 4.mv 命令\\n\\n功能：mv命令是move的缩写，可以用来移动文件或者将文件改名（move(rename)files），是Linux系统下常用的命令，经常用来备份文件或者目录\\n\\n格式：mv [选项] [路径] [旧文件名] [新路径] [新文件名]\\n\\n常用选项：\\n\\n选项\\t说明\\n-f\\tforce 强制的意思，如果目标文件已经存在，不会询问而直接覆盖\\n-i\\t若目标文件 (destination) 已经存在时，就会询问是否覆盖\\n注意：\\n\\n如果只移动不改名字，新名字可以不写\\n如果移动的同时改名字，新名字一定要写\\n\\n# 5.cp 命令\\n\\n功能: 复制文件或目录\\n说明：cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息\\n\\n格式：cp [选项] [路径] [旧文件名] [新路径]\\n\\n常用选项表：\\n\\n选项\\t说明\\n-f 或 --force\\t强行复制文件或目录， 不论目的文件或目录是否已经存在\\n-i 或 --interactive\\t覆盖文件之前先询问用户\\n-r\\t递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理\\n-R 或 --recursive\\t递归处理，将指定目录下的文件及子目录一并处理\\n\\n\\n\\n-a：此参数的效果和同时指定\\\"-dpR\\\"参数相同；\\n-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；\\n-f：强行复制文件或目录，不论目标文件或目录是否已存在；\\n-i：覆盖既有文件之前先询问用户；\\n-l：对源文件建立硬连接，而非复制文件；\\n-p：保留源文件或目录的属性；\\n-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；\\n-s：对源文件建立符号连接，而非复制文件；\\n-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；\\n-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；\\n-b：覆盖已存在的文件目标前将目标文件备份；\\n-v：详细显示命令执行的操作。\\n\\n# 6.mkdir命令\\n\\n用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 \\n\\n注意：在创建文件时，不要把所有的文件都存放在主目录中，可以创建子目录，通过它们来更有效地组织文件。最好采用前后一致的命名方式来区分文件和目录。例如，目录名可以以大写字母开头，这样，在目录列表中目录名就出现在前面。\\n\\n在一个子目录中应包含类型相似或用途相近的文件。例如，应建立一个子目录，它包含所有的数据库文件，另有一个子目录应包含电子表格文件，还有一个子目录应包含文字处理文档，等等。目录也是文件，它们和普通文件一样遵循相同的命名规则，并且利用全路径可以唯一地指定一个目录。\\n\\n### 语法\\n\\n```shell\\nmkdir (选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-Z：设置安全上下文，当使用SELinux时有效；\\n-m<目标属性>或--mode<目标属性>建立目录的同时设置目录的权限；\\n-p或--parents 递归创建目录，若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\\n--version 显示版本信息。\\n```\\n\\n### 权限 \\n\\n文件或目录的权限又分为3种：只读、只写、可执行。\\n\\n权限\\t权限数值\\t二进制\\t具体作用\\nr\\t4\\t00000100\\tread，读取。当前用户可以读取文件内容，当前用户可以浏览目录。\\nw   2\\t00000010\\twrite，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。\\nx    1\\t00000001\\texecute，执行。当前用户可以执行文件，当前用户可以进入目录。\\n依照上面的表格，权限组合就是对应权限值求和，如下：\\n7 = 4 + 2 + 1 读写运行权限\\n5 = 4 + 1 读和运行权限\\n4 = 4 只读权限\\n\\n顺序为user ,group,other ,**所有者权限**，**同组用户的权限**，**其他用户的权限**\\n\\n7 = rwx = 可读，可写，可执行\\n6 = rw- = 可读，可写，不可执行\\n5 = r-x = 可读，不可写，可执行\\n4 = r--\\n3 = -wx\\n2 = -w-\\n1 = --x\\n0 = ---\\n\\n​\\t\\t\\n\\n在目录`/usr/meng`下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问\\n\\n```shell\\nmkdir -m 700 /usr/meng/test\\n```\\n\\n在当前目录中建立bin和bin下的os_1目录，权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问\\n\\n```shell\\nmkdir -p-m 750 bin/os_1\\n```\\n\\n# 7.touch命令\\n\\n创建文件或修改文件时间\\n如果文件 不存在，可以创建一个空白文件\\n如果文件 已经存在，可以修改文件的末次修改日期\\n\\n**语法：**\\n\\n```\\ntouch [选项] [参数]\\n```\\n\\n-a：或--time=atime或--time=access或--time=use  只更改存取时间；\\n-c：或--no-create  不建立任何文件；\\n-d：<时间日期> 使用指定的日期时间，而非现在的时间；\\n-f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；\\n-m：或--time=mtime或--time=modify  只更该变动时间；\\n-r：<参考文件或目录>  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；\\n-t：<日期时间>  使用指定的日期时间，而非现在的时间；\\n--help：在线帮助；\\n--version：显示版本信息。\\n\\n# 8.rm命令\\n\\n- 删除文件或目录\\n  使用 rm 命令要小心，因为文件删除后不能恢复\\n\\n| 选项            |                         含义                          |\\n| --------------- | :---------------------------------------------------: |\\n| -f              |         强制删除，忽略不存在的文件，无需提示          |\\n| -r              | 递归地删除目录下的内容，**删除文件夹 时必须加此参数** |\\n| -d              |   直接把欲删除的目录的硬连接数据删除成0，删除该目录   |\\n| -v              |                显示指令的详细执行过程                 |\\n| -i              |           删除已有文件或目录之前先询问用户            |\\n| -v              |                显示指令的详细执行过程                 |\\n| --preserve-root |                不对根目录进行递归操作                 |\\n\\n\\n\\n# 9.ln命令\\n\\n**ln命令** 用来为文件创建链接，链接类型分为硬链接和符号链接两种，默认的链接类型是硬链接。如果要创建符号链接必须使用\\\"-s\\\"选项。\\n\\n注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。\\n\\n### 语法\\n\\n```shell\\nln [参数] [源文件或目录] [目标文件或目录]\\nln [选项]... [-T] 目标 链接名\\t(第一种格式)\\n　或：ln [选项]... 目标\\t\\t(第二种格式)\\n　或：ln [选项]... 目标... 目录\\t(第三种格式)\\n　或：ln [选项]... -t 目录 目标...\\t(第四种格式)\\n```\\n\\n### 选项\\n\\n```shell\\n-s, --symbolic              # 对源文件建立符号链接，而非硬链接\\n--backup[=CONTROL]      # 为每个已存在的目标文件创建备份文件\\n-b                      # 类似--backup，但不接受任何参数\\n-d, -F, --directory         # 创建指向目录的硬链接(只适用于超级用户)\\n-f, --force                 # 强行删除任何已存在的目标文件\\n-i, --interactive           # 覆盖既有文件之前先询问用户\\n-L, --logical               # 取消引用作为符号链接的目标\\n-n, --no-dereference        # 把符号链接的目的目录视为一般文件\\n-P, --physical              # 直接将硬链接到符号链接\\n-r, --relative              # 创建相对于链接位置的符号链接\\n-S, --suffix=SUFFIX         # 用\\\"-b\\\"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它\\n-t, --target-directory=DIRECTORY # 指定要在其中创建链接的DIRECTORY\\n-T, --no-target-directory   # 将“LINK_NAME”视为常规文件\\n-v, --verbose               # 打印每个链接文件的名称\\n--help      # 显示此帮助信息并退出\\n--version   # 显示版本信息并退出\\n```\\n\\n### 参数\\n\\n- 源文件：指定链接的源文件。如果使用`-s`选项创建符号链接，则“源文件”可以是文件或者目录。创建硬链接时，则“源文件”参数只能是文件。\\n- 目标文件：指定源文件的目标链接文件。\\n\\n```shell\\nnone, off       # 不进行备份(即使使用了--backup 选项)\\nnumbered, t     # 备份文件加上数字进行排序\\nexisting, nil   # 若有数字的备份文件已经存在则使用数字，否则使用普通方式备份\\nsimple, never   # 永远使用普通方式备份\\n```\\n\\n### **实例**\\n\\n将目录`/usr/mengqc/mub1` 下的文件 m2.c 链接到目录 `/usr/liu` 下的文件 a2.c\\n\\n```shell\\ncd /usr/mengqc\\nln /mub1/m2.c /usr/liu/a2.c\\n```\\n\\n在执行ln命令之前，目录`/usr/liu`中不存在a2.c文件。执行ln之后，在`/usr/liu`目录中才有a2.c这一项，表明m2.c和a2.c链接起来（注意，二者在物理上是同一文件），利用`ls -l`命令可以看到链接数的变化。\\n\\n**创建软链接**\\n\\n在目录`/usr/liu`下建立一个符号链接文件abc，使它指向目录`/usr/mengqc/mub1`\\n\\n```shell\\nln -s /usr/mengqc/mub1 /usr/liu/abc\\n```\\n\\n执行该命令后，`/usr/mengqc/mub1`代表的路径将存放在名为`/usr/liu/abc`的文件中。\\n\\n**创建硬链接**\\n\\n给文件创建硬链接，为 `log2022.log` 创建硬链接 `ln2022`，`log2022.log` 与 `ln2022` 的各项属性相同\\n\\n```shell\\nln log2022.log ln2022\\n```\\n\\n输出：\\n\\n```\\n[root@localhost test]# ll\\nlrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -> log2022.log\\n-rw-r--r-- 1 root bin      61 11-13 06:03 log2022.log\\n[root@localhost test]# ln log2022.log ln2022\\n[root@localhost test]# ll\\nlrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -> log2022.log\\n-rw-r--r-- 2 root bin      61 11-13 06:03 ln2022\\n-rw-r--r-- 2 root bin      61 11-13 06:03 log2022.log\\n```\\n\\n## 扩展知识\\n\\nLinux具有为一个文件起多个名字的功能，称为链接。被链接的文件可以存放在相同的目录下，但是必须有不同的文件名，而不用在硬盘上为同样的数据重复备份。另外，被链接的文件也可以有相同的文件名，但是存放在不同的目录下，这样只要对一个目录下的该文件进行修改，就可以完成对所有目录下同名链接文件的修改。对于某个文件的各链接文件，我们可以给它们指定不同的存取权限，以控制对信息的共享和增强安全性。\\n\\n文件链接有两种形式，即硬链接和符号链接。\\n\\nln功能说明：是为某一个文件在另外一个位置建立一个同步的链接，当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。\\n\\n> ⚠️ ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化。\\n\\n### 符号链接(软连接)\\n\\n符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如下所示的abc文件），其中包含它提供链接的另一个文件的路径名，如虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将沿着链接方向前进来访问实际的文件。\\n\\n```shell\\n$ ls -il\\ntotal 0\\n922736 lrwxrwxrwx 1 root root 5 Jun 17 11:27 abc -> a.txt\\n922735 -rw-r--r-- 1 root root 0 Jun 17 11:27 a.txt\\n```\\n\\n1. 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\\n2. 软链接可以 跨文件系统 ，硬链接不可以\\n3. 软链接可以对一个不存在的文件名进行链接\\n4. 软链接可以对目录进行链接\\n\\n与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的索引节点号；而硬链接并没有建立新文件。\\n\\n符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。\\n\\n用`ln -s`命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。\\n\\n符号链接保持了链接与源文件或目录之间的区别：\\n\\n- 删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据。\\n- 在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是l。\\n- 符号链接的大小是其链接文件的路径名中的字节数。\\n- 当用`ls -l`命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如`lrwxrwxrwx … 14 jun 20 10:20 /etc/motd->/original_file`其中，表示“文件大小”的数字“14”恰好说明源文件名`original_file`由14个字符构成。\\n\\n### 硬链接\\n\\n建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如下所示的m2.c文件就在目录mub1和liu中都建立了目录项。\\n\\n1. 硬链接，以文件副本的形式存在。但不占用实际空间。\\n\\n2. 不允许给目录创建硬链接\\n\\n3. 硬链接只有在同一个文件系统中才能创建\\n\\n4. 创建硬链接后，己经存在的文件的索引节点号（inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为1。\\n\\n   在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。\\n\\n   对硬链接有如下限制：\\n\\n   - 不能对目录文件做硬链接。\\n   - 不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统中。\\n\\n# 10.find 命令\\n\\n功能：用来在指定目录下查找文件\\n\\n格式：find [路径] [选项] [操作]\\n\\n### 常用选项\\n\\n-a             \\t\\t\\t\\t\\t\\t\\t\\t\\tand 必须满足两个条件才显示\\n-o            \\t\\t\\t\\t\\t\\t\\t\\t\\t or 只要满足一个条件就显示\\n-name     \\t\\t\\t\\t\\t\\t\\t\\t\\t 按照文件名查找文件\\n-iname     \\t\\t\\t\\t\\t\\t\\t\\t\\t按照文件名查找文件(忽略大小写)\\n\\n-size \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t按照文件大小来查找\\n\\n-type        \\t\\t\\t\\t\\t\\t\\t\\t\\t根据文件类型进行搜索\\n-perm      \\t\\t\\t\\t\\t\\t\\t\\t\\t 按照文件权限来查找文件\\n-user       \\t\\t\\t\\t\\t\\t\\t\\t\\t 按照文件属主来查找文件。\\n-group    \\t\\t\\t\\t\\t\\t\\t\\t\\t  按照文件所属的组来查找文件。\\n-fprint      \\t\\t\\t\\t\\t\\t\\t\\t\\t 文件名：将匹配的文件输出到文件。\\n-newer file1 ! newer file2             查找更改时间比文件file1新但比文件file2旧的文件\\n\\n### 常用动作\\n\\n-print                                            默认动作，将匹配的文件输出到标准输出\\n-exec   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t对匹配的文件执行该参数所给出的命令。相应命令的形式为 \'command\' { } \\\\;，注意{ }和\\\\；之间的空格。\\n-ok     \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\\n-delete \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t将匹配到的文件删除\\n\\n### 实例\\n\\n根据文件名进行匹配\\n1.列出当前目录及子目录下所有文件和文件夹\\n命令：find .\\n\\n2.在/home目录下查找以.txt结尾的文件名\\nfind /home/ -name \\\"*.txt\\\" \\n3.同上，但忽略大小写\\nfind /home -iname \\\"*.txt\\\"\\n\\n4.查找 /home/ 下所有以.txt或.pdf结尾的文件\\n find /home/ -name \\\"*.txt\\\" -o -name \\\"*.pdf\\\"\\n\\n5.查找 /home/ 下所有以a开头和以.txt结尾的文件\\n find /home/ -name \\\"*.txt\\\" -a -name \\\"a*\\\"\\n\\n6.搜索/home目录下txt结尾的文件，并将输出到指定文件中(re.txt)\\n[root@localhost home]# find /home/ -type f -name \\\"*.txt\\\" -fprint /tmp/re.txt \\n\\n7.根据文件类型进行搜索\\n\\n[root@host-136 ~]# find /home/ -type f\\n\\n### 类型参数列\\n\\n​    f 普通文件\\n​    l 符号连接（软连接）\\n​    d 目录\\n​    b 块设备\\n​    s 套接字\\n\\n\\n\\n# 11.grep 命令\\n\\n功能：用于查找文件里符合条件的字符串\\n\\n### 格式\\n\\ngrep [选项] \'查找字符串\' 文件名\\n\\n**grep命令里的匹配模式就是你想要找的东西，可以是普通的文字符号，也可以是正则表达式**\\n\\n### 常用选项\\n\\n-i：在搜索的时候忽略大小写\\n\\n-n：显示结果所在行号\\n\\n-c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数\\n\\n-o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行\\n\\n-v：输出不带关键字的行（反向查询，反向匹配）\\n\\n-w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配\\n\\n-Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after\\n\\n-Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before\\n\\n-Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context\\n\\n-e：实现多个选项的匹配，逻辑or关系\\n\\n-q：静默模式，不输出任何信息，当我们只关心有没有匹配到，却不关心匹配到什么内容时，我们可以使用此命令，然后，使用”echo $?”查看是否匹配到，0表示匹配到，1表示没有匹配到。\\n\\n-P：表示使用兼容perl的正则引擎。\\n\\n-E：使用扩展正则表达式，而不是基本正则表达式，在使用”-E”选项时，相当于使用egrep。\\n\\n\\n\\n# 12.less命令\\n\\n分屏上下翻页浏览文件内容\\n\\n**less命令** 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。\\n\\n### 语法\\n\\n```shell\\nless(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-e：文件内容显示完毕后，自动退出；\\n-f：强制显示文件；\\n-g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；\\n-l：搜索时忽略大小写的差异；\\n-N：每一行行首显示行号；\\n-s：将连续多个空行压缩成一行显示；\\n-S：在单行显示较长的内容，而不换行显示；\\n-x<数字>：将TAB字符显示为指定个数的空格字符。\\n```\\n\\n### 参数\\n\\n文件：指定要分屏显示内容的文件。\\n\\n\\n\\n# 13.cat 命令\\n\\n> **功能**： 查看目标文件的内容\\n\\n**格式**：`cat [选项] 文件名`\\n\\n**常用选项**：\\n\\n| 选项 | 说明               |\\n| ---- | ------------------ |\\n| -b   | 对非空输出行编号   |\\n| -n   | 对输出的所有行编号 |\\n| -s   | 不输出多行空行     |\\n\\ncat (全称 concatenate) 命令是 Linux/类 Unix 操作系统中最常用的命令之一。cat 命令允许我们创建单个或多个文件、查看文件内容、连接文件和重定向终端或文件中的输出。\\n\\n在本文中，我们将了解如何方便地使用 cat 命令及其在 Linux 中的示例。\\n\\n### 1.显示文件内容\\n\\n下面的例子将显示 /etc/passwd 文件。\\n\\n​\\t\\tcat /etc/passwd\\n\\n### 2.终端查看多个文件的内容\\n\\n在下面的示例中，它将显示 rumenz 和 rumenz1 终端中的文件。\\n\\ncat rumenz rumenz1\\n\\n入门小站\\nrumenz.com\\n\\n### 3.用cat命令创建文件\\n\\n我们将创建一个名为 rumenz2 使用以下命令创建文件。\\n\\ncat > rumenz2\\n\\n### 4.等待用户输入，键入所需文本\\n\\n然后按 CTRL+D （按住 Ctrl key 并输入d） 退出。正文将写在rumenz2文件。你可以使用以下命令查看文件的内容cat 命令。\\n\\ncat rumenz2\\n\\nrumenz.com\\n\\n### 5.使用more和less参数的Cat命令\\n\\n如果有大量的内容，屏幕滚动起来非常快，我们可以使用参数more和less\\n\\ncat song.txt | more\\n\\ncat song.txt | less\\n\\n### 6.在文件中显示行号\\n\\n随着 -n 选项你可以看到一个文件的行号 song.txt 在输出端。\\n\\ncat -n song.txt\\n\\n### 7.一次显示多个文件\\n\\n在下面的例子中，我们有三个文件 rumenz, rumenz1, 和 rumenz2,并能够查看这些文件的内容，如上所示。我们需要将每个文件分开;。\\n\\ncat rumenz; cat rumenz1; cat rumenz2\\n\\nThis is a rumenz file\\nThis is the rumenz1 file.\\nThis is rumenz2 file.\\n\\n### 8.使用标准输出和重定向操作符\\n\\n我们可以将文件的标准输出重定向到一个新文件中，否则现有文件中带有 >（大于）符号。仔细，现有的内容rumenz1 将被内容覆盖 rumenz 文件。\\n\\ncat rumenz > rumenz1\\n\\n### 9.使用重定向运算符附加标准输出\\n\\n在现有文件中附加 >>（双大于）符号。这里的内容rumenz 文件将附加在文件的末尾 rumenz1 文件。\\n\\ncat rumenz >> rumenz1\\n\\n### 10.使用重定向运算符重定向标准输入\\n\\n当你将重定向与标准输入一起使用时<（小于符号），它使用文件名 rumenz2 作为命令的输入和输出将显示在终端中。\\n\\ncat < rumenz2\\n\\nThis is rumenz2 file.\\n\\n### 11.重定向包含在单个文件中的多个文件\\n\\n这将创建一个名为 rumenz3 并且所有输出都将重定向到新创建的文件中。\\n\\ncat rumenz rumenz1 rumenz2 > rumenz3\\n\\n### 12.在单个文件中对多个文件的内容进行排序\\n\\n这将创建一个文件 rumenz4 和输出 cat 命令通过管道进行排序，结果将被重定向到新创建的文件。\\n\\n# 14.echo命令\\n\\n 用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。\\n\\n### 语法\\n\\n```shell\\necho(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-e：激活转义字符。\\n```\\n\\n使用`-e`选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：\\n\\n- `\\\\a` 发出警告声；\\n- `\\\\b` 删除前一个字符；\\n- `\\\\c` 不产生进一步输出 (\\\\c 后面的字符不会输出)；\\n- `\\\\f` 换行但光标仍旧停留在原来的位置；\\n- `\\\\n` 换行且光标移至行首；\\n- `\\\\r` 光标移至行首，但不换行；\\n- `\\\\t` 插入tab；\\n- `\\\\v` 与\\\\f相同；\\n- `\\\\\\\\` 插入\\\\字符；\\n- `\\\\nnn` 插入 `nnn`（八进制）所代表的ASCII字符；\\n\\n# 15.覆盖和追加\\n\\n### 1.语法\\n\\n将列表的内容覆盖到文件中:ll >文件\\n\\n将列表的内容追加到文件尾部:ll >>文件\\n\\n将文件1的内容覆盖到文件2中:cat 文件1 > 文件2\\n\\n将文件1的内容追加到文件2的尾部:cat 文件1 >> 文件2\\n\\n将内容写入覆盖到文件中:echo “内容” > 文件\\n\\n将内容写入追加到文件的尾部: echo “内容” >> 文件\\n\\n### 2.功能\\n\\n  指令 > : 如果文件存在，将原来文件的内容覆盖；原文件不存在则创建文件，再添加信息。\\n  指令 >> : 不会覆盖原文件内容，将内容追加到文件的尾部。\\n\\n### 3.常用范例\\n\\n例一：将ls查看信息写入到文件中\\n\\n命令：ll > log.txt\\n例二：将log1.txt的内容覆盖到log4.txt中\\n\\n命令：cat log1.txt > log4.txt\\n\\n  没有log4.txt文件则会自动创建。\\n例三：在log.txt追加内容\\n\\n命令：echo Hello World2 >> log.txt\\n\\n# 16.file命令\\n\\n 用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。\\n\\n### 语法\\n\\n```shell\\nfile(选项)(参数)\\n```\\n\\n表示要确定类型的文件列表（文件或目录）。多个文件之间使用空格分开，可以使用shell通配符匹配多个文件\\n\\n### 选项\\n\\n```shell\\n-b：列出辨识结果时，不显示文件名称；\\n-c：详细显示指令执行过程，便于排错或分析程序执行的情形；\\n-f<名称文件>：指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称；\\n-L：直接显示符号连接所指向的文件类别；\\n-m<魔法数字文件>：指定魔法数字文件；\\n-v：显示版本信息；\\n-z：尝试去解读压缩文件的内容。\\n\\n```\\n\\n# 17.PS 命令\\n\\n功能：用来列出系统中当前正在运行的那些进程，类似于 windows 的任务管理器。\\n\\n格式：ps [选项]\\n\\n常用选项：\\n\\n选项\\t说明\\n-A\\t列出所有的进程 （重要）\\n-ef\\t查看全格式的全部进程 （重要）\\n-w\\t显示加宽可以显示较多的资讯\\n-au\\t显示较详细的资讯\\n-aux\\t显示所有包含其他使用者的行程\\n\\n# 18.**yum命令** \\n\\n是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\\n\\nyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\\n\\n### 语法\\n\\n```shell\\nyum(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-h：显示帮助信息；\\n-y：对所有的提问都回答“yes”；\\n-c：指定配置文件；\\n-q：安静模式；\\n-v：详细模式；\\n-d：设置调试等级（0-10）；\\n-e：设置错误等级（0-10）；\\n-R：设置yum处理一个命令的最大等待时间；\\n-C：完全从缓存中运行，而不去下载或者更新任何头文件。\\n```\\n\\n### 参数\\n\\n```shell\\ninstall：安装rpm软件包；\\nupdate：更新rpm软件包；\\ncheck-update：检查是否有可用的更新rpm软件包；\\nremove：删除指定的rpm软件包；\\nlist：显示软件包的信息；\\nsearch：检查软件包的信息；\\ninfo：显示指定的rpm软件包的描述信息和概要信息；\\nclean：清理yum过期的缓存；\\nshell：进入yum的shell提示符；\\nresolvedep：显示rpm软件包的依赖关系；\\nlocalinstall：安装本地的rpm软件包；\\nlocalupdate：显示本地rpm软件包进行更新；\\ndeplist：显示rpm软件包的所有依赖关系。\\n```\\n\\n# 19.tar命令\\n\\nTar（tape archive）是一种归档文件格式，它通常用于将多个文件打包成一个单一的文件。该文件通常以.tar扩展名结尾。Tar文件没有压缩功能，因此通常与gzip或bzip2等压缩工具一起使用，以创建压缩的归档文件。\\n\\n### 1、tar命令的打包操作\\n\\n创建tar文件的命令是tar，可以使用以下命令创建一个名为archive.tar的tar文件，其中包含目录/ home / user /和文件/home/user/file1和/home/user/file2：\\n\\ntar -cvf archive.tar /home/user/ /home/user/file1 /home/user/file2\\n-c：创建新的tar文件(create 表示建包的意思)\\n\\n-v：显示操作详细信息 （verbose 冗长的，详细，表示命令执行时会显示更多的信息）\\n\\n-f：指定要创建的tar文件的文件名（file 指定tar包的文件名）\\n\\ntar -cvf 打包文件的名字.tar 文件名字或路径\\n1\\n\\n### 2、tar命令的解包操作\\n\\n要将tar文件解压缩到当前目录，可以使用以下命令：\\n\\n***tar -xvf archive.tar***\\n\\n-x：提取文件（extract 提取 取出 表示解包的意思）\\n\\n-v：显示操作详细信息\\n\\n-f：指定要提取的tar文件的文件名\\n\\ntar -xvf 需要解包文件的名字.tar\\n1\\n\\n### 3、tar命令的建立压缩包操作\\n\\n***tar -czvf archive.tar.gz /home/user/ /home/user/file1 /home/user/file2***\\n-c：创建新的tar文件\\n\\n-z：使用gzip压缩工具进行压缩 （表示使用命令gzip进行压缩 扩展名.tar.gz或者.tgz）\\n\\n-v：显示操作详细信息\\n\\n-f：指定要创建的tar文件的文件名\\n\\n### 4、tar命令解压缩包操作\\n\\n要解压缩gzip压缩的tar文件，可以使用以下命令：\\n\\n***tar -xzvf archive.tar.gz***\\n-x：提取文件\\n\\n-z：使用gzip解压缩工具进行解压缩\\n\\n-v：显示操作详细信息\\n\\n-f：指定要提取的tar文件的文件名\\n\\ntar zxvf 解压文件.tar.gz [-C 指定解压到哪个目录]\\n\\n\\n要将tar文件与bzip2压缩工具一起使用，可以使用以下命令将tar文件压缩为bzip2压缩的tar文件：\\n\\n***tar -cjvf archive.tar.bz2 /home/user/ /home/user/file1 /home/user/file2***\\n\\n-c：创建新的tar文件\\n\\n-j：使用bzip2压缩工具进行压缩 （表示使用命令bzip2进行压缩 扩展名.tar.bz2.gz或者.tbz2）\\n\\n-v：显示操作详细信息\\n\\n-f：指定要创建的tar文件的文件名\\n\\n要解压缩gzip压缩的tar文件，可以使用以下命令：\\n\\n***tar -xjvf archive.tar.bz2***-x：提取文件\\n\\n-j：使用bzip2解压缩工具进行解压缩\\n\\n-v：显示操作详细信息\\n\\n-f：指定要提取的tar文件的文件名\\n\\ntar zxvf 解压文件.tar.gz [-C 指定解压到哪个目录]\\n\\n\\n\\n# 20.su命令\\n\\n su是swith user的缩写,在Linux中 su 命令可让用户暂时变更登入的身份,除 root 外变更时须输入所要变更的用户帐号与密码。\\n\\n### 1.语法：\\n\\nsu [参数] [-] [用户帐号]\\n\\n### 2.功能：\\n\\n  变更用户身份，若不指定用户帐号，则预设变更为root。\\n\\n### 3.参数：\\n\\n-c<指令>或--command=<指令> 　\\t\\t\\t\\t\\t\\t执行完指定的指令后，即恢复原来的身份。 \\n-f或--fast 　\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   适用于csh与tsch，使shell不用去读取启动文件。 \\n--l或--login 　\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更PATH变量。  \\n-m,-p或--preserve-environment 　\\t\\t\\t\\t\\t\\t变更身份时，不要变更环境变量。 \\n-s<shell>或--shell=<shell> 　\\t\\t\\t\\t\\t\\t指定要执行的shell（bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell。\\n\\n### 4.常用范例：\\n\\n例一：变更帐号为 root 并在执行 ls 指令后退出变回原使用者\\n\\n命令：su -c ls root\\n例二：切换用户\\n\\n命令： su root\\n\\n  testuser切换成root，相当于用户改成root但是操作的是testuser环境\\n  小权限切换大权限要求输入密码;大权限切换小权限不需要输入密码。\\n  切换用户，只能获得用户的执行权限，不能获得环境变量。\\n例三：切换用户，改变环境变量\\n\\n命令：su - root\\n\\n  testuser切换成root，相当于用户改成root，操作的是root环境。即变更帐号为 root 并改变工作目录至 root 的家目录。\\n  切换到用户并获得该用户的环境变量及执行权限。\\n\\n\\n\\n# 21.vim\\n\\n### 1.vim编辑器的四种模式\\n\\n☆ 命令模式\\n使用VIM编辑器时，默认处于命令模式。在该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作。\\n\\n☆ 编辑模式或输入模式\\n在命令模式下输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑\\n\\n☆ 末行模式\\n在命令模式下输入冒号:即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存、退出等操作\\n\\n☆ 可视化模式\\n可以做一些列选操作（通过方向键选择某些列的内容,类似于Windows鼠标刷黑）\\n可视化模式\\n\\n### 2.VIM四种模式的关系\\n\\n 编辑模式------------字母   i   或   o   或   a   ----------->命令模式\\n\\n可视化模式-----------------字母    v     ----------------->命令模式\\n\\n命令模式----------------输入    ：   或     /    ----------->末行模式\\n\\n末行模式-------输入    ：q！   或      ：wq      --------->退出vim\\n\\n### 3.VIM编辑器的使用\\n\\n1.使用vim打开文件\\n基本语法：\\n\\nvim  文件名称\\n① 如果文件已存在，则直接打开\\n\\n② 如果文件不存在，则vim编辑器会自动在内存中创建一个新文件\\n\\n案例：使用vim命令打开readme.txt文件\\n\\nvim readme.txt\\n\\n\\n\\n2.vim编辑器保存文件\\n在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号:，进入到末行模式，输入wq，代表保存并退出。\\n\\n3.vim编辑器强制退出（不保存）\\n在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号：，进入到末行模式，输入q!，代表强制退出但是不保存文件。\\n\\n##### 1.命令模式下的相关操作\\n\\n☆ 如何进入命令模式\\n答：在Linux操作系统中，当我们使用vim命令直接打开某个文件时，默认进入的就是命令模式。如果我们处于其他模式（编辑模式、可视化模式以及末行模式）可以连续按两次Esc键也可以返回命令模式\\n\\n☆ 命令模式下我们能做什么\\n① 移动光标 ② 复制 粘贴 ③ 剪切 粘贴 删除 ④ 撤销与恢复\\n\\n☆ 移动光标到首行或末行（!）\\n移动光标到首行 => gg\\n\\n移动光标到末行 => G\\n\\n☆ 翻屏\\n向上 翻屏，按键：ctrl + b （before） 或 PgUp\\n\\n向下 翻屏，按键：ctrl + f （after） 或 PgDn\\n\\n向上翻半屏，按键：ctrl + u （up）\\n\\n向下翻半屏，按键：ctrl + d （down）\\n\\n☆ 快速定位光标到指定行（!）\\n行号 + G，如150G代表快速移动光标到第150行。\\n\\n☆ 复制/粘贴（!）\\n① 复制当前行（光标所在那一行）\\n\\n按键：yy\\n\\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\\n\\n② 从当前行开始复制指定的行数，如复制5行，5yy\\n\\n粘贴：在想要粘贴的地方按下p 键【将粘贴在光标所在行的下一行】,如果想粘贴在光标所在行之前，则使用P键\\n\\n☆ 剪切/删除（!）\\n在VIM编辑器中，剪切与删除都是dd\\n\\n如果剪切了文件，但是没有使用p进行粘贴，就是删除操作\\n\\n如果剪切了文件，然后使用p进行粘贴，这就是剪切操作\\n\\n① 剪切/删除当前光标所在行\\n\\n按键：dd （删除之后下一行上移）\\n\\n粘贴：p\\n\\n注意：dd 严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。\\n\\n② 剪切/删除多行（从当前光标所在行开始计算）\\n\\n按键：数字dd\\n\\n粘贴：p\\n\\n特殊用法：\\n\\n③ 剪切/删除光标所在的当前行（光标所在位置）之后的内容，但是删除之后下一行不上移\\n\\n按键：D （删除之后当前行会变成空白行）\\n\\n☆ 撤销/恢复（!）\\n撤销：u（undo）\\n\\n恢复：ctrl + r 恢复（取消）之前的撤销操作【重做，redo】\\n\\n总结\\n① 怎么进入命令模式（vim 文件名称，在任意模式下，可以连续按两次Esc键即可返回命令模式）\\n\\n② 命令模式能做什么？移动光标、复制/粘贴、剪切/删除、撤销与恢复\\n\\n首行 => gg，末行 => G 翻屏（了解） 快速定位 行号G，如150G\\n\\nyy p 5yy p\\n\\ndd p 5dd p\\n\\nu\\n\\nctrl + r\\n\\n##### 2.末行模式下的相关操作\\n\\n☆ 如何进入末行模式\\n进入末行模式的方法只有一个，在命令模式下使用冒号：的方式进入。\\n\\n☆ 末行模式下我们能做什么\\n文件保存、退出、查找与替换、显示行号、paste模式等等\\n\\n☆ 保存/退出（!）\\n:w => 代表对当前文件进行保存操作，但是其保存完成后，并没有退出这个文件\\n\\n:q => 代表退出当前正在编辑的文件，但是一定要注意，文件必须先保存，然后才能退出\\n\\n:wq => 代表文件先保存后退出（保存并退出）\\n\\n如果一个文件在编辑时没有名字，则可以使用:wq 文件名称，代表把当前正在编辑的文件保存到指定的名称中，然后退出\\n\\n:q! => 代表强制退出但是文件未保存（不建议使用）\\n\\n###### ☆ 查找/搜索（!）\\n\\n切换到命令模式，然后输入斜杠/（也是进入末行模式的方式之一）\\n\\n进入到末行模式后，输入要查找或搜索的关键词，然后回车\\n\\n如果在一个文件中，存在多个满足条件的结果。在搜索结果中切换上/下一个结果：N/n （大写N代表上一个结果，小写n代表next）\\n\\n如果需要取消高亮，则需要在末行模式中输入:noh【no highlight】\\n\\n☆ 文件内容的替换（!）\\n第一步：首先要进入末行模式（在命令模式下输入冒号:）\\n\\n第二步：根据需求替换内容\\n\\n① 只替换光标所在这一行的第一个满足条件的结果（只能替换1次）\\n\\n:s/要替换的关键词/替换后的关键词   +  回车\\n案例：把hello rhel中的 rhel替换为 rhel8\\n\\n切换光标到hello  rhel这一行\\n:s/rhel/rhel8\\n② 替换光标所在这一行中的所有满足条件的结果（替换多次，只能替换一行）\\n\\n:s/要替换的关键词/替换后的关键词/g\\t\\tg=global全局替换\\n案例：把hello rhel中的所有rhel都替换为rhel8\\n\\n切换光标到hello rhel这一行\\n:s/rhel/rhel8/g\\n③ 针对整个文档中的所有行进行替换，只替换每一行中满足条件的第一个结果\\n\\n:%s/要替换的关键词/替换后的关键词\\n案例：把每一行中的第一个hello关键词都替换为hi\\n\\n:%s/hello/hi\\n④ 针对整个文档中的所有关键词进行替换（只要满足条件就进行替换操作）\\n\\n:%s/要替换的关键词/替换后的关键词/g\\n案例：替换整个文档中的hello关键词为hi\\n\\n:%s/hello/hi/g\\n☆ 显示行号\\n基本语法：\\n\\n:set nu\\n【nu = number】，行号\\n取消行号 => :set nonu\\n\\n☆ set paste模式\\n为什么要使用paste模式？\\n\\n问题：在终端Vim中粘贴代码时，发现插入的代码会有多余的缩进，而且会逐行累加。原因是终端把粘贴的文本存入键盘缓存（Keyboard Buffer）中，Vim则把这些内容作为用户的键盘输入来处理。导致在遇到换行符的时候，如果Vim开启了自动缩进，就会默认的把上一行缩进插入到下一行的开头，最终使代码变乱。\\n\\n在粘贴数据之前，输入下面命令开启paste模式\\n:set paste\\n\\n粘贴完毕后，输入下面命令关闭paste模式\\n:set nopaste\\n\\n总结\\n① 如何进入末行模式，必须从命令模式中使用冒号进行切换\\n\\n② 末行模式下能做什么？保存、退出、查找、替换、显示行号以及paste模式\\n\\n③ 保存 => :w\\n\\n④ 退出 => :q，先保存后退出。:wq :wq 文件名称 :q!\\n\\n⑤ 查找功能 => 命令模式输入/斜杠 + 关键词（高亮显示）=> :noh\\n\\n⑥ 替换功能\\n\\n:s/要替换的关键词/替换后的关键词\\n\\n:s/要替换的关键词/替换后的关键词/g\\n\\n:%s/要替换的关键词/替换后的关键词\\n\\n:%s/要替换的关键词/替换后的关键词/g\\n\\n⑦ 显示行号 => :set nu 取消行号 => :set nonu\\n\\n⑧ paste模式 => 将来在粘贴代码的时候为了保存原格式 => 粘贴之前 => :set paste\\n\\n##### 3.编辑模式\\n\\n1）编辑模式的作用\\n编辑模式的作用比较简单，主要是实现对文件的内容进行编辑模式。\\n\\n2）如何进入编辑模式\\n首先你需要进入到命令模式，然后使用小写字母a或小写字母i，进入编辑模式。\\n\\n命令模式 + i ： insert缩写，代表在光标之前插入内容\\n\\n命令模式 + a ： append缩写，代表在光标之后插入内容\\n\\n3）退出编辑模式\\n在编辑模式中，直接按Esc，即可从编辑模式退出到命令模式。\\n\\n##### 4.可视化模式\\n\\n1）如何进入到可视化模式\\n在命令模式中，直接按ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑ ↓ ← →方向键来选中需要复制的区块，按下y 键进行复制（不要按下yy），最后按下p 键粘贴\\n\\n退出可视模式按下Esc\\n\\n2）可视化模式复制操作\\n第一步：在命令模式下，直接按小v，进入可视化模式\\n\\n第二步：使用方向键↑ ↓ ← →选择要复制的内容，然后按y键\\n\\n第三步：移动光标，停在需要粘贴的位置，按p键进行粘贴操作\\n\\n3）为配置文件添加#多行注释（!）\\n第一步：按Esc退出到命令模式，按gg切换到第1行\\n\\n第二步：然后按Ctrl+v进入到可视化区块模式（列模式）\\n\\n第三步：在行首使用上下键选择需要注释的多行\\n\\n第四步：按下键盘（大写）“I”键，进入插入模式（Shift + i）\\n\\n第五步：输入#号注释符\\n\\n第六步：输入完成后，连续按两次Esc即可完成添加多行注释的过程\\n\\n4）为配置文件去除#多行注释（!）\\n第一步：按Esc退出到命令模式，按gg切换到第1行\\n\\n第二步：然后按Ctrl+v进入可视化区块模式（列模式）\\n\\n第三步：使用键盘上的方向键的上下选中需要移除的#号注释\\n\\n第四步：直接按Delete键即可完成删除注释的操作\\n\\n# 22.chmod命令\\n\\nchmod命令由于修改文件或者目录的权限\\n\\n\\n\\n##  选项\\n\\n```shell\\n-c, --changes：当文件的权限更改时输出操作信息。\\n--no-preserve-root：不将\'/\'特殊化处理，默认选项。\\n--preserve-root：不能在根目录下递归操作。\\n-f, --silent, --quiet：抑制多数错误消息的输出。\\n-v, --verbose：无论文件是否更改了权限，一律输出操作信息。\\n--reference=RFILE：使用参考文件或参考目录RFILE的权限来设置目标文件或目录的权限。\\n-R, --recursive：对目录以及目录下的文件递归执行更改权限操作。\\n--help：显示帮助信息并退出。\\n--version：显示版本信息并退出。\\n```\\n\\n### 1、字母法：\\n\\nchmod  (u g o a)   (+ - =)   (r w x)   (文件名)\\n\\n以上是chmod的用法，每个括号是一个参数， 前三个括号主要放在一起使用即 chmod + 设置模式 + 文件名；下面先介绍这些参数的意义：\\n\\n[u g o a]    含义\\nu    user 表示该文件的所有者\\ng    group 表示与该文件的所有者属于同一组( group )者，即用户组\\no    other 表示其它用户组\\na    all 表示这三者皆是\\n\\n[+  -  =]    含义\\n\\n+    增加权限\\n\\n-    撤销权限\\n-    =    设定权限\\n\\n[r   w   x]    含义\\nr    read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。\\nw    write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。\\nx    excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。\\n\\n用法：chmod + 设置模式 + 文件名\\n中间的设置模式，要分别对u(user), g(group), o(other)设置权限。\\n\\nchmod u+rwx, g+rwx, o+rwx filename 改命令说明对filename文件， 赋予user、group、other均有read、write、excute的权限\\n\\n## 例子\\n\\n> 参考`man chmod`文档的`DESCRIPTION`段落得知：\\n>\\n> - `u`符号代表当前用户。\\n> - `g`符号代表和当前用户在同一个组的用户，以下简称组用户。\\n> - `o`符号代表其他用户。\\n> - `a`符号代表所有用户。\\n> - `r`符号代表读权限以及八进制数`4`。\\n> - `w`符号代表写权限以及八进制数`2`。\\n> - `x`符号代表执行权限以及八进制数`1`。\\n> - `X`符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限。\\n> - `s`符号代表设置权限suid和sgid，使用权限组合`u+s`设定文件的用户的ID位，`g+s`设置组用户ID位。\\n> - `t`符号代表只有目录或文件的所有者才可以删除目录下的文件。\\n> - `+`符号代表添加目标用户相应的权限。\\n> - `-`符号代表删除目标用户相应的权限。\\n> - `=`符号代表添加目标用户相应的权限，删除未提到的权限。\\n\\n```shell\\nlinux文件的用户权限说明：\\n\\n# 查看当前目录（包含隐藏文件）的长格式。\\nls -la\\n  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules\\n\\n# 第1位如果是d则代表目录，是-则代表普通文件。\\n# 更多详情请参阅info coreutils \'ls invocation\'（ls命令的info文档）的\'-l\'选项部分。\\n# 第2到4位代表当前用户的权限。\\n# 第5到7位代表组用户的权限。\\n# 第8到10位代表其他用户的权限。\\n\\n# 添加组用户的写权限。\\nchmod g+w ./test.log\\n# 删除其他用户的所有权限。\\nchmod o= ./test.log\\n# 使得所有用户都没有写权限。\\nchmod a-w ./test.log\\n# 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。\\nchmod u=rwx, g=rw, o=r ./test.log\\n# 等价的八进制数表示：\\nchmod 764 ./test.log\\n# 将目录以及目录下的文件都设置为所有用户拥有读写权限。\\n# 注意，使用\'-R\'选项一定要保留当前用户的执行和读取权限，否则会报错！\\nchmod -R a=rw ./testdir/\\n# 根据其他文件的权限设置文件权限。\\nchmod --reference=./1.log  ./test.log\\n```\\n\\n\\n\\n### 2、数字法\\n\\n数字法是基于字母法的表示，如果字母法懂了，数字法就好懂，并且易于使用。\\n\\n用法：chmod + 数字组合 + 文件名\\n数字组合一般包含三个数字：\\n\\nr  (read)     ---------------->   4\\n\\nw (write)    ---------------->   2\\n\\nx (excute)  ---------------->   1\\n\\n详解：\\n\\n第一个数字7：代表用户 u 的权限 rwx， 4 (r) + 2 (w) + 1 (x) =  7\\n\\n第二个数字7：代表用户 g 的权限 rwx,    4 (r) + 2 (w) + 1 (x) =  7\\n\\n第三个数字7：代表用户 o 的权限 rwx,    4 (r) + 2 (w) + 1 (x) =  7\\n\\n### 举例说明：\\n\\n数字法：chmod  755 filename    对应    字母法： chmod u+rwx, g+rx, o+rx filename\\n数字法：chmod  751 filename    对应    字母法： chmod u+rwx, g+rx, o+x  filename\\n\\n## 补充\\n\\ndrwxr-xr-x. \\t2\\t \\t\\t\\troot\\t\\t\\t\\t root\\t   98\\t   \\t\\t\\t\\tMay 1 09:57 \\tDocuments\\n\\n-rw-------. \\t1\\t \\t\\t\\t\\troot\\t \\t\\t\\troot \\t1720 \\t\\t\\t\\t\\tApr 6 01:38 \\tanaconda-ks.cfg\\n\\n文件权限     硬链接个数  创建者     创建者所在的组   字节数    最后修改日期      文件名称\\n\\n第一位 为  ‘-’ 表示为文件       \\n\\n第一位 为  ‘d’ 表示为文件夹\\n\\n第一位 为  ‘l’ 表示为链接文件       \\n\\n# 23.chown命令\\n\\n用来变更文件或目录的拥有者或所属群组\\n\\n## 补充说明\\n\\n**chown命令** 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。\\n\\n只有文件主和超级用户才可以便用该命令。\\n\\n### 语法\\n\\n```shell\\nchown(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-c或——changes：效果类似“-v”参数，但仅回报更改的部分；\\n-f或--quite或——silent：不显示错误信息；\\n-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；\\n-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；\\n-v或——version：显示指令执行过程；\\n--dereference：效果和“-h”参数相同；\\n--help：在线帮助；\\n--reference=<参考文件或目录>：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；\\n--version：显示版本信息。\\n```\\n\\n### 参数\\n\\n用户：组：指定所有者和所属工作组。当省略“：组”，仅改变文件所有者；\\n文件：指定要改变所有者和工作组的文件列表。支持多个文件和目标，支持shell通配符。\\n\\n### 实例\\n\\n将目录`name.txt`文件的文件主改成 CHY：\\n\\n```shell\\nchown CHY name.txt \\n```\\n\\n\\n\\n将目录`/usr/meng`及其下面的所有文件、子目录的文件主改成 liu：\\n\\n```shell\\nchown -R liu /usr/meng\\n```\\n\\n# 24.shell编程\\n\\n## 两种方式执行shell脚本\\n\\n第一种：给文件增加执行权限\\n\\n[root@localhost ~]$ chmod u+x test.sh\\n[root@localhost ~]$ ./test.sh  #绝对路径或相对路径执行\\n第二种（了解）：通过Bash调用执行脚本\\n\\n[root@localhost ~]$ bash test.sh\\n\\n## 变量的命名规则\\n\\n在定义变量时，有一些规则需要遵守:\\n\\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\\n等号左右两侧不能有空格，可以使用下划线“_”，变量的值如果有空格，需要使用单引号或双引号包括。如:“test=“hello world!””。其中双引号括起来的内容“$”，“(”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。\\n不能使用标点符号，不能使用bash里的关键字（可用help命令查看保留关键字）。\\n环境变量建议大写，便于区分\\n如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含\\\"$变量名\\\"或用${变量名}包含变量名。\\n[root@localhost ~]$ test=123\\n[root@localhost ~]$ test=\\\"$test\\\"456\\n[root@localhost ~]$ echo $test\\n123456\\n#叠加变量test，变量值变成了123456\\n[root@localhost ~]$ test=${test}789\\n[root@localhost ~]$ echo $test\\n123456789\\n#再叠加变量test，变量值编程了123456789\\n关于单双引号的问题：\\n双引号能够识别变量，双引号能够实现转义（类似于“\\\\*”）\\n单引号是不能识别变量，只会原样输出，单引号是不能转义的\\n\\n## shell中特殊符号\\n\\n符号\\t作用\\n’ ’\\t单引号。在单引号中所有的特殊符号，如“$”和”(反引号)都没有特殊含义。单引号括起来的都是普通字符，***会原样输出***\\n“ ”\\t双引号。在双引号中特殊符号都没有特殊含义，但是“$”，“`”（esc键下面）和“\\\\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。\\n· ·\\t反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和( ) 作 用 一 样 ， 不过推荐使用()，因为反引号非常容易看错。\\n$()\\t和反引号作用一样，用来引用系统命令。(推荐使用)\\n()\\t用于一串命令执行时，()中的命令会在子Shell中运行\\n{}\\t用于一串命令执行时，{ }中的命令会在当前Shell中执行。也可以用于变量变形与替换。\\n[ ]\\t用于变量的测试。\\n\\n在Shell脚本中，#开头的行代表注释。\\n\\n$\\t用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。\\n\\\\\\t转义符，跟在\\\\之后的特殊符号将失去特殊含义，变为普通字符。如$将输出“$”符号，而不当做是变量引用。\\n\\n## 单引号和双引号\\n\\n[root@localhost ~]$ name=sc\\n#定义变量name 的值是sc\\n[root@localhost ~]$ echo \'$name\'\\n$name\\n#如果输出时使用单引号，则$name原封不动的输出\\n[root@localhost ~]$ echo \\\"$name\\\"\\nsc\\n#如果输出时使用双引号，则会输出变量name的值 sc\\n\\n[root@localhost ~]$ echo `date`\\n2018年10月21日星期一18:16:33 CST\\n#反引号括起来的命令会正常执行\\n[root@localhost ~]$ echo \'`date`\'\\n`date`\\n#但是如果反引号命令被单引号括起来，那么这个命令不会执行，―date`会被当成普通字符输出\\n[root@localhost ~]$ echo \\\"`date\'\\\"\\n2018年10月21日星期一18:14:21 CST\\n#如果是双引号括起来，那么这个命令又会正常执行\\n反引号\\n\\n[root@localhost ~]$ echo ls\\nls\\n#如果命令不用反引号包含，命令不会执行，而是直接输出\\n[root@localhost ~]$ echo `ls`\\nanaconda-ks.cfginstall.loginstall.log.syslog sh test testfile\\n#只有用反引号包括命令，这个命令才会执行\\n[root@localhost ~]$ echo $(date)\\n2018年10月21日星期一18:25:09 CST\\n#使用$(命令)的方式也是可以的\\n\\n## 变量操作\\n\\n创建普通变量：name=“test”，组要注意的是等号两边不能有空格。\\n创建局部变量：local name=“test”，使用local修饰的变量在函数体外无法访问，只能在函数体中使用。\\n创建只读变量：name=“only_read” -> readonly name，这种变量不可以被修改。\\n使用变量：echo $name或者echo ${name}\\n删除变量：unset name，删除之后的变量无法被访问，需要注意无法删除只读变量。\\n3.1.3 字符串变量\\n3.1.3.1 字符串变量的创建\\n使用单引号创建：var=\'test\'。\\n这种方式创建的变量只能原样输出，变量无效，我们可以借用c中的“字符串常量”的定义理解这种特性。除此以外，单引号中不能出现单独的单引号，转义也是不可以的。\\n使用双引号创建：var=\\\"my name is ${name}\\\"，这种方式创建的字符串变量有效，也可以出现转义符。\\n3.1.3.2 拼接字符串\\n字面量拼接\\nstr01=\\\"1\\\"\\\"2\\\"或者str01=\\\"1\\\"\'2\'，这样就将1和2两个字符拼接在了一起。需要注意的是两个串之间不可以有空格。\\n变量拼接\\nstr03=${part01}${part02}或str04=${part01}\\\"end\\\"或str05=\\\"${part01} ${part02}\\\"这三种方式都可以拼接字符串变量。\\n命令拼接\\nstr02= date“end”，这里的date是一个shell命令，需要使用引用，具体如下 \\n\\n# 25.wc命令\\n\\n统计文件的字节数、字数、行数\\n\\n## 补充说明\\n\\n**wc命令** 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。wc同时也给出所指定文件的总统计数。\\n\\n### 语法\\n\\n```shell\\nwc(选项)(参数)\\nwc [选项]... [文件]...\\nwc [选项]... --files0-from=F\\n```\\n\\n### 选项\\n\\n```shell\\n-c # 统计字节数，或--bytes：显示Bytes数。\\n-l # 统计行数，或--lines：显示列数。\\n-m # 统计字符数，或--chars：显示字符数。\\n-w # 统计字数，或--words：显示字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。\\n-L # 打印最长行的长度，或--max-line-length。\\n-help     # 显示帮助信息。\\n--version # 显示版本信息。\\n```\\n\\n### 参数\\n\\n文件：需要统计的文件列表。\\n\\n## 例子\\n\\n```shell\\nwc -l *       # 统计当前目录下的所有文件行数及总计行数。\\nwc -l *.js    # 统计当前目录下的所有 .js 后缀的文件行数及总计行数。\\nfind  . * | xargs wc -l # 当前目录以及子目录的所有文件行数及总计行数。\\n```\\n\\n查看文件的行数、单词数、字节数\\n\\n```shell\\nwc test.txt\\n# 输出结果\\n7     8     70     test.txt\\n# 行数 单词数 字节数 文件名\\n```\\n\\n用wc命令怎么做到只打印统计数字不打印文件名\\n\\n```shell\\nwc -l < test.txt\\n# 输出结果\\n7\\n```\\n\\n用来统计当前目录下的文件数(不包含隐藏文件)\\n\\n```shell\\n# 要去除TOTAL行\\nexpr $(ls -l | wc -l) - 1\\n# 输出结果\\n```\\n\\n# 26.groupadd命令\\n\\n用于创建一个新的工作组\\n\\n## 补充说明\\n\\n**groupadd命令** 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。\\n\\n### 语法\\n\\n```shell\\ngroupadd(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-g：指定新建工作组的id；\\n-r：创建系统工作组，系统工作组的组ID小于500；\\n-K：覆盖配置文件“/ect/login.defs”；\\n-o：允许添加组ID号不唯一的工作组。\\n```\\n\\n### 参数\\n\\n组名：指定新建工作组的组名。\\n\\n### 实例\\n\\n建立一个新组，并设置组ID加入系统：\\n\\n```shell\\ngroupadd -g 344 jsdigname\\n```\\n\\n此时在`/etc/passwd`文件中产生一个组ID（GID）是344的项目。\\n\\n# 27.groupdel命令\\n\\n用于删除指定的工作组\\n\\n## 补充说明\\n\\n**groupdel命令** 用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。\\n\\n### 语法\\n\\n```shell\\ngroupdel(参数)\\n```\\n\\n### 参数\\n\\n组：要删除的工作组名。\\n\\n### 实例\\n\\n```shell\\ngroupadd damon  //创建damon工作组\\ngroupdel damon  //删除这个工作组\\n```\\n\\n# 28.useradd命令\\n\\n创建的新的系统用户\\n\\n## 补充说明\\n\\n**useradd命令** 用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在`/etc/passwd`文本文件中。\\n\\n在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd命令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中， **adduser命令** 则是useradd命令的符号连接，两者实际上是同一个指令。\\n\\n### 语法\\n\\n```shell\\nuseradd(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-c<备注>：加上备注文字。备注文字会保存在passwd的备注栏位中；\\n-d<登入目录>：指定用户登入时的启始目录；\\n-D：变更预设值；\\n-e<有效期限>：指定帐号的有效期限；\\n-f<缓冲天数>：指定在密码过期后多少天即关闭该帐号；\\n-g<群组>：指定用户所属的群组；\\n-G<群组>：指定用户所属的附加群组；\\n-m：自动建立用户的登入目录；\\n-M：不要自动建立用户的登入目录；\\n-n：取消建立以用户名称为名的群组；\\n-r：建立系统帐号；\\n-s<shell>：指定用户登入后所使用的shell；\\n-u<uid>：指定用户id。\\n```\\n\\n### 参数\\n\\n用户名：要创建的用户名。\\n\\n### 实例\\n\\n新建用户加入组：\\n\\n```shell\\nuseradd –g sales jack –G company,employees    //-g：加入主要组、-G：加入次要组\\n```\\n\\n建立一个新用户账户，并设置ID：\\n\\n```shell\\nuseradd caojh -u 544\\n```\\n\\n需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。\\n\\n# 29.userdel命令\\n\\n用于删除给定的用户以及与用户相关的文件\\n\\n## 补充说明\\n\\n**userdel命令** 用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。\\n\\n### 语法\\n\\n```shell\\nuserdel(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-f：强制删除用户，即使用户当前已登录；\\n-r：删除用户的同时，删除与用户相关的所有文件。\\n```\\n\\n### 参数\\n\\n用户名：要删除的用户名。\\n\\n### 实例\\n\\nuserdel命令很简单，比如我们现在有个用户linuxde，其家目录位于`/var`目录中，现在我们来删除这个用户：\\n\\n```shell\\nuserdel linuxde       # 删除用户linuxde，但不删除其家目录及文件；\\nuserdel -r linuxde    # 删除用户linuxde，其家目录及文件一并删除；\\n```\\n\\n请不要轻易用`-r`选项；他会删除用户的同时删除用户所有的文件和目录，切记如果用户目录下有重要的文件，在删除前请备份。\\n\\n其实也有最简单的办法，但这种办法有点不安全，也就是直接在`/etc/passwd`中删除您想要删除用户的记录；但最好不要这样做，`/etc/passwd`是极为重要的文件，可能您一不小心会操作失误。\\n\\n# 30.usermod命令\\n\\n用于修改用户的基本信息\\n\\n## 补充说明\\n\\n**usermod命令** 用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在server上更动相关的NIS设定。\\n\\n### 语法\\n\\n```shell\\nusermod(选项)(参数)\\n```\\n\\n### 选项\\n\\n```shell\\n-c<备注>：修改用户帐号的备注文字；\\n-d<登入目录>：修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用；\\n-m<移动用户家目录>:移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。\\n-e<有效期限>：修改帐号的有效期限；\\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\\n-g<群组>：修改用户所属的群组；\\n-G<群组>；修改用户所属的附加群组；\\n-l<帐号名称>：修改用户帐号名称；\\n-L：锁定用户密码，使密码无效；\\n-s<shell>：修改用户登入后所使用的shell；\\n-u<uid>：修改用户ID；\\n-U:解除密码锁定。\\n```\\n\\n### 参数\\n\\n登录名：指定要修改信息的用户登录名。\\n\\n### 实例\\n\\n将 newuser2 添加到组 staff 中：\\n\\n```shell\\nusermod -G staff newuser2\\n```\\n\\n修改newuser的用户名为newuser1：\\n\\n```shell\\nusermod -l newuser1 newuser\\n```\\n\\n锁定账号newuser1：\\n\\n```shell\\nusermod -L newuser1\\n```\\n\\n解除对newuser1的锁定：\\n\\n```shell\\nusermod -U newuser1\\n```\\n\\n增加用户到用户组中:\\n\\n```shell\\napk add shadow # 安装 shadow 包, usermod 命令包含在 usermod 中\\nusermod -aG group user # 添加用户到用户组中\\n```\\n\\n`-a` 参数表示附加，只和 `-G` 参数一同使用，表示将用户增加到组中。\\n\\n修改用户家目录：\\n\\n```\\n[root@node-1 ~]# useradd lutixiaya\\n[root@node-1 ~]# ls /home\\nlutixiaya\\n[root@node-1 ~]# usermod -md /data/new_home lutixiaya\\n[root@node-1 ~]# ls /home/\\n[root@node-1 ~]# ls /data/\\nnew_home\\n```\\n\\n# 31.getent命令\\n\\ngetent   passwd   查看系统中的用户    和   cat /etc/passwd  效果一样\\n\\n用户名：密码（X）：用户ID： 组ID：描述信息（无用）：Home目录：执行终端（默认为bash）\\n\\ngetent group   查询 系统中的组信息    和   cat /etc/group  效果一样\\n\\n组名称：组的认证（X）：组ID\\n\\n\\n\\n# 32.条件判断\\n\\n## 整数判断\\n\\n常用参数：\\n判断参数\\t含义\\n-eq ==\\t相等\\n-ne <> !=\\t不等\\n-gt\\t大于\\n-lt\\t小于\\n-ge\\t大于等于\\n-le\\t小于等于\\n\\n## 字符串判断\\n\\n常用参数：\\n判断参数\\t含义\\n-z\\t判断是否为空字符串，字符串长度为0则成立\\n-n\\t判断是否为非空字符串，字符串长度不为0则成立\\nstring1 = string2\\t判断字符串是否相等\\nstring1 != string2\\t判断字符串是否相不等\\n\\n## 文件类型判断\\n\\n常用参数：\\n判断参数\\t含义\\t说明\\n-e\\t判断文件是否存在（link文件指向的也必须存在）\\texists\\n-f\\t判断文件是否存在并且是一个普通文件\\tfile\\n-d\\t判断文件是否存在并且是一个目录\\tdirectory\\n-L\\t判断文件是否存在并且是一个软连接文件\\tsoft link\\n-b\\t判断文件是否存在并且是一个块设备文件\\tblock\\n-S\\t判断文件是否存在并且是一个套接字文件\\tsocket\\n-c\\t判断文件是否存在并且是一个字符设备文件\\tchar\\n-p\\t判断文件是否存在并且是一个命名管道文件\\tpipe\\n\\n###### ***-s\\t判断文件是否存在并且是一个非空文件（有内容）\\tis not empty***\\n\\n文件内容是否为空的判断\\n\\n## 文件权限判断\\n\\n常用参数：\\n判断参数\\t含义\\n-r\\t当前用户对其是否可读\\n-w\\t当前用户对其是否可写\\n-x\\t当前用户对其是否可执行\\n-u\\t是否有suid，高级权限冒险位\\n-g\\t是否sgid，高级权限强制位\\n-k\\t是否有t位，高级权限粘滞位 (创建者/root才能删除)\\n\\n## 文件新旧判断\\n\\n常用参数：\\n说明：这里的新旧指的是文件的修改时间。\\n判断参数\\t含义\\nfile1 -nt file2\\t比较file1是否比file2新\\nfile1 -ot file2\\t比较file1是否比file2旧\\nfile1 -ef file2\\t比较是否为同一个文件，或者用于判断硬连接，是否指向同一个inode\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/753f1e9dcba4a4e591af2c629cc8e271.jpg\",\"articleTitle\":\"linux基本命令\",\"categoryName\":\"linux\",\"id\":137,\"isFeatured\":0,\"isTop\":0,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-01 19:17:03', NULL);
INSERT INTO `t_operation_log` VALUES (1750, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"## 0. 简介\\n\\n​\\t**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​\\t一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​\\t 一般Web应用的需要进行**认证**和**授权**。\\n\\n​\\t\\t**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\\n\\n​\\t\\t**授权：经过认证后判断当前用户是否有权限进行某个操作**\\n\\n​\\t而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n\\n## 1. 快速入门\\n\\n### 1.1 准备工作\\n\\n​\\t我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n~~~~xml\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n② 创建启动类\\n\\n~~~~java\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\n~~~~\\n\\n③ 创建Controller\\n\\n~~~~java\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 1.2 引入SpringSecurity\\n\\n​\\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​\\t必须登陆之后才能对接口进行访问。\\n\\n\\n\\n## 2. 认证\\n\\n### 2.1 登陆校验流程\\n\\n![image20211215094003288.png](https://static.linhaojun.top/aurora/articles/03fc208b0326f9c76804cbd4a2b8d4b8.png)\\n\\n### 2.2 原理初探\\n\\n​\\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n\\n\\n#### 2.2.1 SpringSecurity完整流程\\n\\n​\\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n![image20211214144425527.png](https://static.linhaojun.top/aurora/articles/5e68a45696fe867f79e4eb640c941526.png)\\n\\n​\\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\t\\n\\n​\\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n![image20211214145824903.png](https://static.linhaojun.top/aurora/articles/6bda42b10230521701f848266c8fdad4.png)\\n\\n\\n\\n\\n\\n#### 2.2.2 认证流程详解\\n\\n![image20211214151515385.png](https://static.linhaojun.top/aurora/articles/09386f9d52f0c8c625b5a94884a7178d.png)\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法 \\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n\\n\\n\\n\\n### 2.3 解决问题\\n\\n#### 2.3.1 思路分析\\n\\n登录\\n\\n​\\t①自定义登录接口  \\n\\n​\\t\\t\\t\\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​\\t\\t\\t\\t把用户信息存入redis中\\n\\n​\\t②自定义UserDetailsService \\n\\n​\\t\\t\\t\\t在这个实现类中去查询数据库\\n\\n校验：\\n\\n​\\t①定义Jwt认证过滤器\\n\\n​\\t\\t\\t\\t获取token\\n\\n​\\t\\t\\t\\t解析token获取其中的userid\\n\\n​\\t\\t\\t\\t从redis中获取用户信息\\n\\n​\\t\\t\\t\\t存入SecurityContextHolder\\n\\n#### 2.3.2 准备工作\\n\\n①添加依赖\\n\\n~~~~xml\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\n~~~~\\n\\n② 添加Redis相关配置\\n\\n~~~~java\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author 三更\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\n~~~~\\n\\n③ 响应类\\n\\n~~~~java\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\n~~~~\\n\\n④工具类\\n\\n~~~~java\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\n~~~~\\n\\n⑤实体类\\n\\n~~~~java\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\n~~~~\\n\\n\\n\\n#### 2.3.3 实现\\n\\n##### 2.3.3.1 数据库校验用户\\n\\n​\\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n###### 准备工作\\n\\n​\\t我们先创建一个用户表， 建表语句如下：\\n\\n~~~~mysql\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\n~~~~\\n\\n​\\t\\t引入MybatisPuls和mysql驱动的依赖\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t\\t配置数据库信息\\n\\n~~~~yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n~~~~\\n\\n​\\t\\t定义Mapper接口\\n\\n~~~~java\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\n~~~~\\n\\n​\\t\\t修改User实体类\\n\\n~~~~java\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\n~~~~\\n\\n​\\t\\t配置Mapper扫描\\n\\n~~~~java\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\n~~~~\\n\\n​\\t\\t添加junit依赖\\n\\n~~~~java\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t   测试MP是否能正常使用\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\n~~~~\\n\\n\\n\\n###### 核心代码实现\\n\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\n~~~~\\n\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n```java\\n/**\\n * @Author 三更\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n```\\n\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\\n\\n##### 2.3.3.2 密码加密存储\\n\\n​\\t实际项目中我们不会把密码明文存储在数据库中。\\n\\n​\\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​\\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​\\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​\\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\n~~~~\\n\\n##### 2.3.3.3 登陆接口\\n\\n​\\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​\\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​\\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n~~~~java\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n~~~~\\n\\n​\\t\\n\\n~~~~java\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.4 认证过滤器\\n\\n​\\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​\\t使用userid去redis中获取对应的LoginUser对象。\\n\\n​\\t然后封装Authentication对象存入SecurityContextHolder\\n\\n\\n\\n~~~~java\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.5 退出登陆\\n\\n​\\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 3. 授权\\n\\n### 3.0 权限系统的作用\\n\\n​\\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​\\t总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\\n\\n​\\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​\\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\t\\n\\n### 3.1 授权基本流程\\n\\n​\\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​\\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​\\t然后设置我们的资源所需要的权限即可。\\n\\n### 3.2 授权实现\\n\\n#### 3.2.1 限制访问资源所需权限\\n\\n​\\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​\\t但是要使用它我们需要先开启相关配置。\\n\\n~~~~java\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\n~~~~\\n\\n​\\t然后就可以使用对应的注解。@PreAuthorize\\n\\n~~~~java\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n~~~~\\n\\n#### 3.2.2 封装权限信息\\n\\n​\\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​\\t我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​\\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  \\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n~~~~\\n\\n​\\t\\tLoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\n~~~~java\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n#### 3.2.3 从数据库查询权限信息\\n\\n##### 3.2.3.1 RBAC权限模型\\n\\n​\\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n![image20211222110249727.png](https://static.linhaojun.top/aurora/articles/87839cfbe9dfb7c8ecfd20303ce3d401.png)\\n\\n##### 3.2.3.2 准备工作\\n\\n~~~~sql\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\n~~~~\\n\\n~~~~mysql\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author 三更\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\n~~~~\\n\\n\\n\\n##### 3.2.3.3 代码实现\\n\\n​\\t我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​\\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\n~~~~java\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  \\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\n~~~~\\n\\n​\\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n~~~~xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\n~~~~\\n\\n​\\t在application.yml中配置mapperXML文件的位置\\n\\n~~~~yaml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\n~~~~\\n\\n\\n\\n​\\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n~~~~java\\n/**\\n * @Author 三更 \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n## 4. 自定义失败处理\\n\\n​\\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​\\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​\\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\\n\\n​\\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\\n\\n​\\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n\\n\\n①自定义实现类\\n\\n~~~~java\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n②配置给SpringSecurity\\n\\n​\\t\\n\\n​\\t先注入对应的处理器\\n\\n~~~~java\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\n~~~~\\n\\n​\\t然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n~~~~java\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\n~~~~\\n\\n\\n\\n## 5. 跨域\\n\\n​\\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \\n\\n​\\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​\\t所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n~~~~java\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\n~~~~\\n\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 6. 遗留小问题\\n\\n### 其它权限校验方法\\n\\n​\\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​    \\n\\n​\\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​\\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​\\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n\\n\\n​\\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n### 自定义权限校验方法\\n\\n​\\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n~~~~java\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\n~~~~\\n\\n​\\t 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n~~~~java\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n### 基于配置的权限控制\\n\\n​\\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### CSRF\\n\\n​\\t[CSRF](https://blog.csdn.net/freeking101/article/details/86537087)是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​\\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​\\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n\\n\\n\\n\\n### 认证成功处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​\\t我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 认证失败处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​\\t我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\n~~~~\\n\\n\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 登出成功处理器\\n\\n~~~~java\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n~~~~\\n\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"articleTitle\":\"Spring Security\",\"categoryName\":\"spring\",\"id\":135,\"isFeatured\":0,\"isTop\":1,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-03 16:49:45', NULL);
INSERT INTO `t_operation_log` VALUES (1751, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"## 0. 简介\\n\\n​\\t**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​\\t一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​\\t 一般Web应用的需要进行**认证**和**授权**。\\n\\n​\\t\\t**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\\n\\n​\\t\\t**授权：经过认证后判断当前用户是否有权限进行某个操作**\\n\\n​\\t而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n\\n## 1. 快速入门\\n\\n### 1.1 准备工作\\n\\n​\\t我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n~~~~xml\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n\\n② 创建启动类\\n\\n~~~~java\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\n~~~~\\n\\n③ 创建Controller\\n\\n~~~~java\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 1.2 引入SpringSecurity\\n\\n​\\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​\\t必须登陆之后才能对接口进行访问。\\n\\n\\n\\n## 2. 认证\\n\\n### 2.1 登陆校验流程\\n\\n![image20211215094003288.png](https://static.linhaojun.top/aurora/articles/03fc208b0326f9c76804cbd4a2b8d4b8.png)\\n\\n### 2.2 原理初探\\n\\n​\\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n\\n\\n#### 2.2.1 SpringSecurity完整流程\\n\\n​\\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n![image20211214144425527.png](https://static.linhaojun.top/aurora/articles/5e68a45696fe867f79e4eb640c941526.png)\\n\\n​\\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\t\\n\\n​\\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n![image20211214145824903.png](https://static.linhaojun.top/aurora/articles/6bda42b10230521701f848266c8fdad4.png)\\n\\n\\n\\n\\n\\n#### 2.2.2 认证流程详解\\n\\n![image20211214151515385.png](https://static.linhaojun.top/aurora/articles/09386f9d52f0c8c625b5a94884a7178d.png)\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法 \\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n\\n\\n\\n\\n### 2.3 解决问题\\n\\n#### 2.3.1 思路分析\\n\\n登录\\n\\n​\\t①自定义登录接口  \\n\\n​\\t\\t\\t\\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​\\t\\t\\t\\t把用户信息存入redis中\\n\\n​\\t②自定义UserDetailsService \\n\\n​\\t\\t\\t\\t在这个实现类中去查询数据库\\n\\n校验：\\n\\n​\\t①定义Jwt认证过滤器\\n\\n​\\t\\t\\t\\t获取token\\n\\n​\\t\\t\\t\\t解析token获取其中的userid\\n\\n​\\t\\t\\t\\t从redis中获取用户信息\\n\\n​\\t\\t\\t\\t存入SecurityContextHolder\\n\\n#### 2.3.2 准备工作\\n\\n①添加依赖\\n\\n~~~~xml\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\n~~~~\\n\\n② 添加Redis相关配置\\n\\n~~~~java\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author 三更\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\n~~~~\\n\\n③ 响应类\\n\\n~~~~java\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\n~~~~\\n\\n④工具类\\n\\n~~~~java\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\n~~~~\\n\\n⑤实体类\\n\\n~~~~java\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\n~~~~\\n\\n\\n\\n#### 2.3.3 实现\\n\\n##### 2.3.3.1 数据库校验用户\\n\\n​\\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n###### 准备工作\\n\\n​\\t我们先创建一个用户表， 建表语句如下：\\n\\n~~~~mysql\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\n~~~~\\n\\n​\\t\\t引入MybatisPuls和mysql驱动的依赖\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t\\t配置数据库信息\\n\\n~~~~yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n~~~~\\n\\n​\\t\\t定义Mapper接口\\n\\n~~~~java\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\n~~~~\\n\\n​\\t\\t修改User实体类\\n\\n~~~~java\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\n~~~~\\n\\n​\\t\\t配置Mapper扫描\\n\\n~~~~java\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\n~~~~\\n\\n​\\t\\t添加junit依赖\\n\\n~~~~java\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t   测试MP是否能正常使用\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\n~~~~\\n\\n\\n\\n###### 核心代码实现\\n\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\n~~~~\\n\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n```java\\n/**\\n * @Author 三更\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n```\\n\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\\n\\n##### 2.3.3.2 密码加密存储\\n\\n​\\t实际项目中我们不会把密码明文存储在数据库中。\\n\\n​\\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​\\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​\\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​\\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\n~~~~\\n\\n##### 2.3.3.3 登陆接口\\n\\n​\\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​\\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​\\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n~~~~java\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n~~~~\\n\\n​\\t\\n\\n~~~~java\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.4 认证过滤器\\n\\n​\\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​\\t使用userid去redis中获取对应的LoginUser对象。\\n\\n​\\t然后封装Authentication对象存入SecurityContextHolder\\n\\n\\n\\n~~~~java\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.5 退出登陆\\n\\n​\\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 3. 授权\\n\\n### 3.0 权限系统的作用\\n\\n​\\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​\\t总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\\n\\n​\\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​\\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\t\\n\\n### 3.1 授权基本流程\\n\\n​\\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​\\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​\\t然后设置我们的资源所需要的权限即可。\\n\\n### 3.2 授权实现\\n\\n#### 3.2.1 限制访问资源所需权限\\n\\n​\\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​\\t但是要使用它我们需要先开启相关配置。\\n\\n~~~~java\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\n~~~~\\n\\n​\\t然后就可以使用对应的注解。@PreAuthorize\\n\\n~~~~java\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n~~~~\\n\\n#### 3.2.2 封装权限信息\\n\\n​\\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​\\t我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​\\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  \\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n~~~~\\n\\n​\\t\\tLoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\n~~~~java\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n#### 3.2.3 从数据库查询权限信息\\n\\n##### 3.2.3.1 RBAC权限模型\\n\\n​\\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n![image20211222110249727.png](https://static.linhaojun.top/aurora/articles/87839cfbe9dfb7c8ecfd20303ce3d401.png)\\n\\n##### 3.2.3.2 准备工作\\n\\n~~~~sql\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\n~~~~\\n\\n~~~~mysql\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author 三更\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\n~~~~\\n\\n\\n\\n##### 3.2.3.3 代码实现\\n\\n​\\t我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​\\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\n~~~~java\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  \\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\n~~~~\\n\\n​\\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n~~~~xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\n~~~~\\n\\n​\\t在application.yml中配置mapperXML文件的位置\\n\\n~~~~yaml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\n~~~~\\n\\n\\n\\n​\\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n~~~~java\\n/**\\n * @Author 三更 \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n## 4. 自定义失败处理\\n\\n​\\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​\\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​\\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\\n\\n​\\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\\n\\n​\\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n\\n\\n①自定义实现类\\n\\n~~~~java\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n②配置给SpringSecurity\\n\\n​\\t\\n\\n​\\t先注入对应的处理器\\n\\n~~~~java\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\n~~~~\\n\\n​\\t然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n~~~~java\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\n~~~~\\n\\n\\n\\n## 5. 跨域\\n\\n​\\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \\n\\n​\\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​\\t所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n~~~~java\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\n~~~~\\n\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 6. 遗留小问题\\n\\n### 其它权限校验方法\\n\\n​\\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​    \\n\\n​\\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​\\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​\\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n\\n\\n​\\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n### 自定义权限校验方法\\n\\n​\\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n~~~~java\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\n~~~~\\n\\n​\\t 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n~~~~java\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n### 基于配置的权限控制\\n\\n​\\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### CSRF\\n\\n​\\t[CSRF](https://blog.csdn.net/freeking101/article/details/86537087)是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​\\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​\\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n\\n\\n\\n\\n### 认证成功处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​\\t我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 认证失败处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​\\t我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\n~~~~\\n\\n\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 登出成功处理器\\n\\n~~~~java\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n~~~~\\n\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"articleTitle\":\"Spring Security\",\"categoryName\":\"spring\",\"id\":135,\"isFeatured\":0,\"isTop\":1,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-04 14:51:50', NULL);
INSERT INTO `t_operation_log` VALUES (1752, '文章模块', '新增或修改', '/admin/articles', 'com.blog.controller.ArticleController.saveOrUpdateArticle', '保存和修改文章', '[{\"articleAbstract\":\"\",\"articleContent\":\"## 0. 简介\\n\\n​\\t**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\\n\\n​\\t一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\\n\\n​\\t 一般Web应用的需要进行**认证**和**授权**。\\n\\n​\\t\\t**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\\n\\n​\\t\\t**授权：经过认证后判断当前用户是否有权限进行某个操作**\\n\\n​\\t而认证和授权也是SpringSecurity作为安全框架的核心功能。\\n\\n\\n\\n## 1. 快速入门\\n\\n### 1.1 准备工作\\n\\n​\\t我们先要搭建一个简单的SpringBoot工程\\n\\n① 设置父工程 添加依赖\\n\\n~~~~xml\\n    <parent>\\n        <groupId>org.springframework.boot</groupId>\\n        <artifactId>spring-boot-starter-parent</artifactId>\\n        <version>2.5.0</version>\\n    </parent>\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n        <dependency>\\n            <groupId>org.projectlombok</groupId>\\n            <artifactId>lombok</artifactId>\\n            <optional>true</optional>\\n        </dependency>\\n    </dependencies>\\n~~~~\\n\\n\\n② 创建启动类\\n\\n~~~~java\\n@SpringBootApplication\\npublic class SecurityApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(SecurityApplication.class,args);\\n    }\\n}\\n\\n~~~~\\n\\n③ 创建Controller\\n\\n~~~~java\\n\\nimport org.springframework.web.bind.annotation.RequestMapping;\\nimport org.springframework.web.bind.annotation.RestController;\\n\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 1.2 引入SpringSecurity\\n\\n​\\t在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-security</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\\n\\n​\\t必须登陆之后才能对接口进行访问。\\n\\n\\n\\n## 2. 认证\\n\\n### 2.1 登陆校验流程\\n\\n![image20211215094003288.png](https://static.linhaojun.top/aurora/articles/03fc208b0326f9c76804cbd4a2b8d4b8.png)\\n\\n### 2.2 原理初探\\n\\n​\\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\\n\\n\\n\\n#### 2.2.1 SpringSecurity完整流程\\n\\n​\\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\\n\\n![image20211214144425527.png](https://static.linhaojun.top/aurora/articles/5e68a45696fe867f79e4eb640c941526.png)\\n\\n​\\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\\n\\n**UsernamePasswordAuthenticationFilter**:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\\n\\n**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\\n\\n**FilterSecurityInterceptor：**负责权限校验的过滤器。\\n\\n​\\t\\n\\n​\\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\\n\\n![image20211214145824903.png](https://static.linhaojun.top/aurora/articles/6bda42b10230521701f848266c8fdad4.png)\\n\\n\\n\\n\\n\\n#### 2.2.2 认证流程详解\\n\\n![image20211214151515385.png](https://static.linhaojun.top/aurora/articles/09386f9d52f0c8c625b5a94884a7178d.png)\\n\\n概念速查:\\n\\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\\n\\nAuthenticationManager接口：定义了认证Authentication的方法 \\n\\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\\n\\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\\n\\n\\n\\n\\n\\n### 2.3 解决问题\\n\\n#### 2.3.1 思路分析\\n\\n登录\\n\\n​\\t①自定义登录接口  \\n\\n​\\t\\t\\t\\t调用ProviderManager的方法进行认证 如果认证通过生成jwt\\n\\n​\\t\\t\\t\\t把用户信息存入redis中\\n\\n​\\t②自定义UserDetailsService \\n\\n​\\t\\t\\t\\t在这个实现类中去查询数据库\\n\\n校验：\\n\\n​\\t①定义Jwt认证过滤器\\n\\n​\\t\\t\\t\\t获取token\\n\\n​\\t\\t\\t\\t解析token获取其中的userid\\n\\n​\\t\\t\\t\\t从redis中获取用户信息\\n\\n​\\t\\t\\t\\t存入SecurityContextHolder\\n\\n#### 2.3.2 准备工作\\n\\n①添加依赖\\n\\n~~~~xml\\n        <!--redis依赖-->\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-redis</artifactId>\\n        </dependency>\\n        <!--fastjson依赖-->\\n        <dependency>\\n            <groupId>com.alibaba</groupId>\\n            <artifactId>fastjson</artifactId>\\n            <version>1.2.33</version>\\n        </dependency>\\n        <!--jwt依赖-->\\n        <dependency>\\n            <groupId>io.jsonwebtoken</groupId>\\n            <artifactId>jjwt</artifactId>\\n            <version>0.9.0</version>\\n        </dependency>\\n~~~~\\n\\n② 添加Redis相关配置\\n\\n~~~~java\\n\\nimport com.alibaba.fastjson.JSON;\\nimport com.alibaba.fastjson.serializer.SerializerFeature;\\nimport com.fasterxml.jackson.databind.JavaType;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.type.TypeFactory;\\nimport org.springframework.data.redis.serializer.RedisSerializer;\\nimport org.springframework.data.redis.serializer.SerializationException;\\nimport com.alibaba.fastjson.parser.ParserConfig;\\nimport org.springframework.util.Assert;\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Redis使用FastJson序列化\\n * \\n * @author 三更\\n */\\npublic class FastJsonRedisSerializer<T> implements RedisSerializer<T>\\n{\\n\\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\\\"UTF-8\\\");\\n\\n    private Class<T> clazz;\\n\\n    static\\n    {\\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\\n    }\\n\\n    public FastJsonRedisSerializer(Class<T> clazz)\\n    {\\n        super();\\n        this.clazz = clazz;\\n    }\\n\\n    @Override\\n    public byte[] serialize(T t) throws SerializationException\\n    {\\n        if (t == null)\\n        {\\n            return new byte[0];\\n        }\\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\\n    }\\n\\n    @Override\\n    public T deserialize(byte[] bytes) throws SerializationException\\n    {\\n        if (bytes == null || bytes.length <= 0)\\n        {\\n            return null;\\n        }\\n        String str = new String(bytes, DEFAULT_CHARSET);\\n\\n        return JSON.parseObject(str, clazz);\\n    }\\n\\n\\n    protected JavaType getJavaType(Class<?> clazz)\\n    {\\n        return TypeFactory.defaultInstance().constructType(clazz);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\\nimport org.springframework.data.redis.core.RedisTemplate;\\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\\n\\n@Configuration\\npublic class RedisConfig {\\n\\n    @Bean\\n    @SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\\n    {\\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\\n        template.setConnectionFactory(connectionFactory);\\n\\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\\n\\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\\n        template.setKeySerializer(new StringRedisSerializer());\\n        template.setValueSerializer(serializer);\\n\\n        // Hash的key也采用StringRedisSerializer的序列化方式\\n        template.setHashKeySerializer(new StringRedisSerializer());\\n        template.setHashValueSerializer(serializer);\\n\\n        template.afterPropertiesSet();\\n        return template;\\n    }\\n}\\n~~~~\\n\\n③ 响应类\\n\\n~~~~java\\n\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\n\\n/**\\n * @Author 三更\\n */\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class ResponseResult<T> {\\n    /**\\n     * 状态码\\n     */\\n    private Integer code;\\n    /**\\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\\n     */\\n    private String msg;\\n    /**\\n     * 查询到的结果数据，\\n     */\\n    private T data;\\n\\n    public ResponseResult(Integer code, String msg) {\\n        this.code = code;\\n        this.msg = msg;\\n    }\\n\\n    public ResponseResult(Integer code, T data) {\\n        this.code = code;\\n        this.data = data;\\n    }\\n\\n    public Integer getCode() {\\n        return code;\\n    }\\n\\n    public void setCode(Integer code) {\\n        this.code = code;\\n    }\\n\\n    public String getMsg() {\\n        return msg;\\n    }\\n\\n    public void setMsg(String msg) {\\n        this.msg = msg;\\n    }\\n\\n    public T getData() {\\n        return data;\\n    }\\n\\n    public void setData(T data) {\\n        this.data = data;\\n    }\\n\\n    public ResponseResult(Integer code, String msg, T data) {\\n        this.code = code;\\n        this.msg = msg;\\n        this.data = data;\\n    }\\n}\\n~~~~\\n\\n④工具类\\n\\n~~~~java\\n\\nimport io.jsonwebtoken.Claims;\\nimport io.jsonwebtoken.JwtBuilder;\\nimport io.jsonwebtoken.Jwts;\\nimport io.jsonwebtoken.SignatureAlgorithm;\\n\\nimport javax.crypto.SecretKey;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport java.util.Base64;\\nimport java.util.Date;\\nimport java.util.UUID;\\n\\n/**\\n * JWT工具类\\n */\\npublic class JwtUtil {\\n\\n    //有效期为\\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\\n    //设置秘钥明文\\n    public static final String JWT_KEY = \\\"sangeng\\\";\\n\\n    public static String getUUID(){\\n        String token = UUID.randomUUID().toString().replaceAll(\\\"-\\\", \\\"\\\");\\n        return token;\\n    }\\n    \\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @return\\n     */\\n    public static String createJWT(String subject) {\\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    /**\\n     * 生成jtw\\n     * @param subject token中要存放的数据（json格式）\\n     * @param ttlMillis token超时时间\\n     * @return\\n     */\\n    public static String createJWT(String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {\\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\\n        SecretKey secretKey = generalKey();\\n        long nowMillis = System.currentTimeMillis();\\n        Date now = new Date(nowMillis);\\n        if(ttlMillis==null){\\n            ttlMillis=JwtUtil.JWT_TTL;\\n        }\\n        long expMillis = nowMillis + ttlMillis;\\n        Date expDate = new Date(expMillis);\\n        return Jwts.builder()\\n                .setId(uuid)              //唯一的ID\\n                .setSubject(subject)   // 主题  可以是JSON数据\\n                .setIssuer(\\\"sg\\\")     // 签发者\\n                .setIssuedAt(now)      // 签发时间\\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\\n                .setExpiration(expDate);\\n    }\\n\\n    /**\\n     * 创建token\\n     * @param id\\n     * @param subject\\n     * @param ttlMillis\\n     * @return\\n     */\\n    public static String createJWT(String id, String subject, Long ttlMillis) {\\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\\n        return builder.compact();\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        String token = \\\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\\\";\\n        Claims claims = parseJWT(token);\\n        System.out.println(claims);\\n    }\\n\\n    /**\\n     * 生成加密后的秘钥 secretKey\\n     * @return\\n     */\\n    public static SecretKey generalKey() {\\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \\\"AES\\\");\\n        return key;\\n    }\\n    \\n    /**\\n     * 解析\\n     *\\n     * @param jwt\\n     * @return\\n     * @throws Exception\\n     */\\n    public static Claims parseJWT(String jwt) throws Exception {\\n        SecretKey secretKey = generalKey();\\n        return Jwts.parser()\\n                .setSigningKey(secretKey)\\n                .parseClaimsJws(jwt)\\n                .getBody();\\n    }\\n\\n\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport java.util.*;\\nimport java.util.concurrent.TimeUnit;\\n\\n@SuppressWarnings(value = { \\\"unchecked\\\", \\\"rawtypes\\\" })\\n@Component\\npublic class RedisCache\\n{\\n    @Autowired\\n    public RedisTemplate redisTemplate;\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     */\\n    public <T> void setCacheObject(final String key, final T value)\\n    {\\n        redisTemplate.opsForValue().set(key, value);\\n    }\\n\\n    /**\\n     * 缓存基本的对象，Integer、String、实体类等\\n     *\\n     * @param key 缓存的键值\\n     * @param value 缓存的值\\n     * @param timeout 时间\\n     * @param timeUnit 时间颗粒度\\n     */\\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\\n    {\\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout)\\n    {\\n        return expire(key, timeout, TimeUnit.SECONDS);\\n    }\\n\\n    /**\\n     * 设置有效时间\\n     *\\n     * @param key Redis键\\n     * @param timeout 超时时间\\n     * @param unit 时间单位\\n     * @return true=设置成功；false=设置失败\\n     */\\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\\n    {\\n        return redisTemplate.expire(key, timeout, unit);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象。\\n     *\\n     * @param key 缓存键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> T getCacheObject(final String key)\\n    {\\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\\n        return operation.get(key);\\n    }\\n\\n    /**\\n     * 删除单个对象\\n     *\\n     * @param key\\n     */\\n    public boolean deleteObject(final String key)\\n    {\\n        return redisTemplate.delete(key);\\n    }\\n\\n    /**\\n     * 删除集合对象\\n     *\\n     * @param collection 多个对象\\n     * @return\\n     */\\n    public long deleteObject(final Collection collection)\\n    {\\n        return redisTemplate.delete(collection);\\n    }\\n\\n    /**\\n     * 缓存List数据\\n     *\\n     * @param key 缓存的键值\\n     * @param dataList 待缓存的List数据\\n     * @return 缓存的对象\\n     */\\n    public <T> long setCacheList(final String key, final List<T> dataList)\\n    {\\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\\n        return count == null ? 0 : count;\\n    }\\n\\n    /**\\n     * 获得缓存的list对象\\n     *\\n     * @param key 缓存的键值\\n     * @return 缓存键值对应的数据\\n     */\\n    public <T> List<T> getCacheList(final String key)\\n    {\\n        return redisTemplate.opsForList().range(key, 0, -1);\\n    }\\n\\n    /**\\n     * 缓存Set\\n     *\\n     * @param key 缓存键值\\n     * @param dataSet 缓存的数据\\n     * @return 缓存数据的对象\\n     */\\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\\n    {\\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\\n        Iterator<T> it = dataSet.iterator();\\n        while (it.hasNext())\\n        {\\n            setOperation.add(it.next());\\n        }\\n        return setOperation;\\n    }\\n\\n    /**\\n     * 获得缓存的set\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Set<T> getCacheSet(final String key)\\n    {\\n        return redisTemplate.opsForSet().members(key);\\n    }\\n\\n    /**\\n     * 缓存Map\\n     *\\n     * @param key\\n     * @param dataMap\\n     */\\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\\n    {\\n        if (dataMap != null) {\\n            redisTemplate.opsForHash().putAll(key, dataMap);\\n        }\\n    }\\n\\n    /**\\n     * 获得缓存的Map\\n     *\\n     * @param key\\n     * @return\\n     */\\n    public <T> Map<String, T> getCacheMap(final String key)\\n    {\\n        return redisTemplate.opsForHash().entries(key);\\n    }\\n\\n    /**\\n     * 往Hash中存入数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @param value 值\\n     */\\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\\n    {\\n        redisTemplate.opsForHash().put(key, hKey, value);\\n    }\\n\\n    /**\\n     * 获取Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKey Hash键\\n     * @return Hash中的对象\\n     */\\n    public <T> T getCacheMapValue(final String key, final String hKey)\\n    {\\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\\n        return opsForHash.get(key, hKey);\\n    }\\n\\n    /**\\n     * 删除Hash中的数据\\n     * \\n     * @param key\\n     * @param hkey\\n     */\\n    public void delCacheMapValue(final String key, final String hkey)\\n    {\\n        HashOperations hashOperations = redisTemplate.opsForHash();\\n        hashOperations.delete(key, hkey);\\n    }\\n\\n    /**\\n     * 获取多个Hash中的数据\\n     *\\n     * @param key Redis键\\n     * @param hKeys Hash键集合\\n     * @return Hash对象集合\\n     */\\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\\n    {\\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\\n    }\\n\\n    /**\\n     * 获得缓存的基本对象列表\\n     *\\n     * @param pattern 字符串前缀\\n     * @return 对象列表\\n     */\\n    public Collection<String> keys(final String pattern)\\n    {\\n        return redisTemplate.keys(pattern);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n\\nimport javax.servlet.http.HttpServletResponse;\\nimport java.io.IOException;\\n\\npublic class WebUtils\\n{\\n    /**\\n     * 将字符串渲染到客户端\\n     * \\n     * @param response 渲染对象\\n     * @param string 待渲染的字符串\\n     * @return null\\n     */\\n    public static String renderString(HttpServletResponse response, String string) {\\n        try\\n        {\\n            response.setStatus(200);\\n            response.setContentType(\\\"application/json\\\");\\n            response.setCharacterEncoding(\\\"utf-8\\\");\\n            response.getWriter().print(string);\\n        }\\n        catch (IOException e)\\n        {\\n            e.printStackTrace();\\n        }\\n        return null;\\n    }\\n}\\n~~~~\\n\\n⑤实体类\\n\\n~~~~java\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n\\n/**\\n * 用户表(User)实体类\\n *\\n * @author 三更\\n */\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\npublic class User implements Serializable {\\n    private static final long serialVersionUID = -40356785423868312L;\\n    \\n    /**\\n    * 主键\\n    */\\n    private Long id;\\n    /**\\n    * 用户名\\n    */\\n    private String userName;\\n    /**\\n    * 昵称\\n    */\\n    private String nickName;\\n    /**\\n    * 密码\\n    */\\n    private String password;\\n    /**\\n    * 账号状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 邮箱\\n    */\\n    private String email;\\n    /**\\n    * 手机号\\n    */\\n    private String phonenumber;\\n    /**\\n    * 用户性别（0男，1女，2未知）\\n    */\\n    private String sex;\\n    /**\\n    * 头像\\n    */\\n    private String avatar;\\n    /**\\n    * 用户类型（0管理员，1普通用户）\\n    */\\n    private String userType;\\n    /**\\n    * 创建人的用户id\\n    */\\n    private Long createBy;\\n    /**\\n    * 创建时间\\n    */\\n    private Date createTime;\\n    /**\\n    * 更新人\\n    */\\n    private Long updateBy;\\n    /**\\n    * 更新时间\\n    */\\n    private Date updateTime;\\n    /**\\n    * 删除标志（0代表未删除，1代表已删除）\\n    */\\n    private Integer delFlag;\\n}\\n~~~~\\n\\n\\n\\n#### 2.3.3 实现\\n\\n##### 2.3.3.1 数据库校验用户\\n\\n​\\t从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\\n\\n###### 准备工作\\n\\n​\\t我们先创建一个用户表， 建表语句如下：\\n\\n~~~~mysql\\nCREATE TABLE `sys_user` (\\n  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` VARCHAR(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` CHAR(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` VARCHAR(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` CHAR(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` VARCHAR(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` CHAR(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` BIGINT(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` DATETIME DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` BIGINT(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` DATETIME DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` INT(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\'\\n~~~~\\n\\n​\\t\\t引入MybatisPuls和mysql驱动的依赖\\n\\n~~~~xml\\n        <dependency>\\n            <groupId>com.baomidou</groupId>\\n            <artifactId>mybatis-plus-boot-starter</artifactId>\\n            <version>3.4.3</version>\\n        </dependency>\\n        <dependency>\\n            <groupId>mysql</groupId>\\n            <artifactId>mysql-connector-java</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t\\t配置数据库信息\\n\\n~~~~yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n~~~~\\n\\n​\\t\\t定义Mapper接口\\n\\n~~~~java\\npublic interface UserMapper extends BaseMapper<User> {\\n}\\n~~~~\\n\\n​\\t\\t修改User实体类\\n\\n~~~~java\\n类名上加@TableName(value = \\\"sys_user\\\") ,id字段上加 @TableId\\n~~~~\\n\\n​\\t\\t配置Mapper扫描\\n\\n~~~~java\\n@SpringBootApplication\\n@MapperScan(\\\"com.sangeng.mapper\\\")\\npublic class SimpleSecurityApplication {\\n    public static void main(String[] args) {\\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\\n        System.out.println(run);\\n    }\\n}\\n~~~~\\n\\n​\\t\\t添加junit依赖\\n\\n~~~~java\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n        </dependency>\\n~~~~\\n\\n​\\t   测试MP是否能正常使用\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@SpringBootTest\\npublic class MapperTest {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Test\\n    public void testUserMapper(){\\n        List<User> users = userMapper.selectList(null);\\n        System.out.println(users);\\n    }\\n}\\n~~~~\\n\\n\\n\\n###### 核心代码实现\\n\\n创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        //根据用户名查询用户信息\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        //如果查询不到数据就通过抛出异常来给出提示\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        \\n        //封装成UserDetails对象返回 \\n        return new LoginUser(user);\\n    }\\n}\\n~~~~\\n\\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\\n\\n```java\\n/**\\n * @Author 三更\\n */\\n@Data\\n@NoArgsConstructor\\n@AllArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n\\n\\n    @Override\\n    public Collection<? extends GrantedAuthority> getAuthorities() {\\n        return null;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n```\\n\\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。\\n\\n##### 2.3.3.2 密码加密存储\\n\\n​\\t实际项目中我们不会把密码明文存储在数据库中。\\n\\n​\\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\\n\\n​\\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\\n\\n​\\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\\n\\n​\\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n}\\n~~~~\\n\\n##### 2.3.3.3 登陆接口\\n\\n​\\t接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\\n\\n​\\t在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\\n\\n​\\t认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\\n\\n~~~~java\\n@RestController\\npublic class LoginController {\\n\\n    @Autowired\\n    private LoginServcie loginServcie;\\n\\n    @PostMapping(\\\"/user/login\\\")\\n    public ResponseResult login(@RequestBody User user){\\n        return loginServcie.login(user);\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n~~~~\\n\\n​\\t\\n\\n~~~~java\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.4 认证过滤器\\n\\n​\\t我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\\n\\n​\\t使用userid去redis中获取对应的LoginUser对象。\\n\\n​\\t然后封装Authentication对象存入SecurityContextHolder\\n\\n\\n\\n~~~~java\\n@Component\\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\\n\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\\n        //获取token\\n        String token = request.getHeader(\\\"token\\\");\\n        if (!StringUtils.hasText(token)) {\\n            //放行\\n            filterChain.doFilter(request, response);\\n            return;\\n        }\\n        //解析token\\n        String userid;\\n        try {\\n            Claims claims = JwtUtil.parseJWT(token);\\n            userid = claims.getSubject();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new RuntimeException(\\\"token非法\\\");\\n        }\\n        //从redis中获取用户信息\\n        String redisKey = \\\"login:\\\" + userid;\\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\\n        if(Objects.isNull(loginUser)){\\n            throw new RuntimeException(\\\"用户未登录\\\");\\n        }\\n        //存入SecurityContextHolder\\n        //TODO 获取权限信息封装到Authentication中\\n        UsernamePasswordAuthenticationToken authenticationToken =\\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\\n        //放行\\n        filterChain.doFilter(request, response);\\n    }\\n}\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更\\n */\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n\\n    @Bean\\n    public PasswordEncoder passwordEncoder(){\\n        return new BCryptPasswordEncoder();\\n    }\\n\\n\\n    @Autowired\\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //把token校验过滤器添加到过滤器链中\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n    }\\n\\n    @Bean\\n    @Override\\n    public AuthenticationManager authenticationManagerBean() throws Exception {\\n        return super.authenticationManagerBean();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n##### 2.3.3.5 退出登陆\\n\\n​\\t我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class LoginServiceImpl implements LoginServcie {\\n\\n    @Autowired\\n    private AuthenticationManager authenticationManager;\\n    @Autowired\\n    private RedisCache redisCache;\\n\\n    @Override\\n    public ResponseResult login(User user) {\\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\\n        if(Objects.isNull(authenticate)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //使用userid生成token\\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\\n        String userId = loginUser.getUser().getId().toString();\\n        String jwt = JwtUtil.createJWT(userId);\\n        //authenticate存入redis\\n        redisCache.setCacheObject(\\\"login:\\\"+userId,loginUser);\\n        //把token响应给前端\\n        HashMap<String,String> map = new HashMap<>();\\n        map.put(\\\"token\\\",jwt);\\n        return new ResponseResult(200,\\\"登陆成功\\\",map);\\n    }\\n\\n    @Override\\n    public ResponseResult logout() {\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        Long userid = loginUser.getUser().getId();\\n        redisCache.deleteObject(\\\"login:\\\"+userid);\\n        return new ResponseResult(200,\\\"退出成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 3. 授权\\n\\n### 3.0 权限系统的作用\\n\\n​\\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\\n\\n​\\t总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\\n\\n​\\t我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\\n\\n​\\t所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\\n\\n​\\t\\n\\n### 3.1 授权基本流程\\n\\n​\\t在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\\n\\n​\\t所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\\n\\n​\\t然后设置我们的资源所需要的权限即可。\\n\\n### 3.2 授权实现\\n\\n#### 3.2.1 限制访问资源所需权限\\n\\n​\\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\\n\\n​\\t但是要使用它我们需要先开启相关配置。\\n\\n~~~~java\\n@EnableGlobalMethodSecurity(prePostEnabled = true)\\n~~~~\\n\\n​\\t然后就可以使用对应的注解。@PreAuthorize\\n\\n~~~~java\\n@RestController\\npublic class HelloController {\\n\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"hasAuthority(\'test\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n}\\n~~~~\\n\\n#### 3.2.2 封装权限信息\\n\\n​\\t我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\\n\\n​\\t我们先直接把权限信息写死封装到UserDetails中进行测试。\\n\\n​\\t我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.alibaba.fastjson.annotation.JSONField;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\nimport org.springframework.security.core.GrantedAuthority;\\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\\nimport org.springframework.security.core.userdetails.UserDetails;\\n\\nimport java.util.Collection;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\n\\n/**\\n * @Author 三更  \\n */\\n@Data\\n@NoArgsConstructor\\npublic class LoginUser implements UserDetails {\\n\\n    private User user;\\n        \\n    //存储权限信息\\n    private List<String> permissions;\\n    \\n    \\n    public LoginUser(User user,List<String> permissions) {\\n        this.user = user;\\n        this.permissions = permissions;\\n    }\\n\\n\\n    //存储SpringSecurity所需要的权限信息的集合\\n    @JSONField(serialize = false)\\n    private List<GrantedAuthority> authorities;\\n\\n    @Override\\n    public  Collection<? extends GrantedAuthority> getAuthorities() {\\n        if(authorities!=null){\\n            return authorities;\\n        }\\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\\n        authorities = permissions.stream().\\n                map(SimpleGrantedAuthority::new)\\n                .collect(Collectors.toList());\\n        return authorities;\\n    }\\n\\n    @Override\\n    public String getPassword() {\\n        return user.getPassword();\\n    }\\n\\n    @Override\\n    public String getUsername() {\\n        return user.getUserName();\\n    }\\n\\n    @Override\\n    public boolean isAccountNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isAccountNonLocked() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isCredentialsNonExpired() {\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean isEnabled() {\\n        return true;\\n    }\\n}\\n\\n~~~~\\n\\n​\\t\\tLoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\\n\\n~~~~java\\npackage com.sangeng.service.impl;\\n\\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\\nimport com.sangeng.domain.LoginUser;\\nimport com.sangeng.domain.User;\\nimport com.sangeng.mapper.UserMapper;\\nimport org.springframework.beans.factory.annotation.Autowired;\\nimport org.springframework.security.core.userdetails.UserDetails;\\nimport org.springframework.security.core.userdetails.UserDetailsService;\\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\\nimport org.springframework.stereotype.Service;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * @Author 三更  \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        //TODO 根据用户查询权限信息 添加到LoginUser中\\n        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,list);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n#### 3.2.3 从数据库查询权限信息\\n\\n##### 3.2.3.1 RBAC权限模型\\n\\n​\\tRBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\\n\\n![image20211222110249727.png](https://static.linhaojun.top/aurora/articles/87839cfbe9dfb7c8ecfd20303ce3d401.png)\\n\\n##### 3.2.3.2 准备工作\\n\\n~~~~sql\\n\\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\\n\\nUSE `sg_security`;\\n\\n/*Table structure for table `sys_menu` */\\n\\nDROP TABLE IF EXISTS `sys_menu`;\\n\\nCREATE TABLE `sys_menu` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `menu_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'菜单名\',\\n  `path` varchar(200) DEFAULT NULL COMMENT \'路由地址\',\\n  `component` varchar(255) DEFAULT NULL COMMENT \'组件路径\',\\n  `visible` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0显示 1隐藏）\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'菜单状态（0正常 1停用）\',\\n  `perms` varchar(100) DEFAULT NULL COMMENT \'权限标识\',\\n  `icon` varchar(100) DEFAULT \'#\' COMMENT \'菜单图标\',\\n  `create_by` bigint(20) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(20) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'是否删除（0未删除 1已删除）\',\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\'菜单表\';\\n\\n/*Table structure for table `sys_role` */\\n\\nDROP TABLE IF EXISTS `sys_role`;\\n\\nCREATE TABLE `sys_role` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `name` varchar(128) DEFAULT NULL,\\n  `role_key` varchar(100) DEFAULT NULL COMMENT \'角色权限字符串\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'角色状态（0正常 1停用）\',\\n  `del_flag` int(1) DEFAULT \'0\' COMMENT \'del_flag\',\\n  `create_by` bigint(200) DEFAULT NULL,\\n  `create_time` datetime DEFAULT NULL,\\n  `update_by` bigint(200) DEFAULT NULL,\\n  `update_time` datetime DEFAULT NULL,\\n  `remark` varchar(500) DEFAULT NULL COMMENT \'备注\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'角色表\';\\n\\n/*Table structure for table `sys_role_menu` */\\n\\nDROP TABLE IF EXISTS `sys_role_menu`;\\n\\nCREATE TABLE `sys_role_menu` (\\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'角色ID\',\\n  `menu_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'菜单id\',\\n  PRIMARY KEY (`role_id`,`menu_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\\n\\n/*Table structure for table `sys_user` */\\n\\nDROP TABLE IF EXISTS `sys_user`;\\n\\nCREATE TABLE `sys_user` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\\n  `user_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'用户名\',\\n  `nick_name` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'昵称\',\\n  `password` varchar(64) NOT NULL DEFAULT \'NULL\' COMMENT \'密码\',\\n  `status` char(1) DEFAULT \'0\' COMMENT \'账号状态（0正常 1停用）\',\\n  `email` varchar(64) DEFAULT NULL COMMENT \'邮箱\',\\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT \'手机号\',\\n  `sex` char(1) DEFAULT NULL COMMENT \'用户性别（0男，1女，2未知）\',\\n  `avatar` varchar(128) DEFAULT NULL COMMENT \'头像\',\\n  `user_type` char(1) NOT NULL DEFAULT \'1\' COMMENT \'用户类型（0管理员，1普通用户）\',\\n  `create_by` bigint(20) DEFAULT NULL COMMENT \'创建人的用户id\',\\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\\n  `update_by` bigint(20) DEFAULT NULL COMMENT \'更新人\',\\n  `update_time` datetime DEFAULT NULL COMMENT \'更新时间\',\\n  `del_flag` int(11) DEFAULT \'0\' COMMENT \'删除标志（0代表未删除，1代表已删除）\',\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=\'用户表\';\\n\\n/*Table structure for table `sys_user_role` */\\n\\nDROP TABLE IF EXISTS `sys_user_role`;\\n\\nCREATE TABLE `sys_user_role` (\\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT \'用户id\',\\n  `role_id` bigint(200) NOT NULL DEFAULT \'0\' COMMENT \'角色id\',\\n  PRIMARY KEY (`user_id`,`role_id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\n~~~~\\n\\n~~~~mysql\\nSELECT \\n\\tDISTINCT m.`perms`\\nFROM\\n\\tsys_user_role ur\\n\\tLEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n\\tLEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n\\tLEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\nWHERE\\n\\tuser_id = 2\\n\\tAND r.`status` = 0\\n\\tAND m.`status` = 0\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n~~~~java\\npackage com.sangeng.domain;\\n\\nimport com.baomidou.mybatisplus.annotation.TableId;\\nimport com.baomidou.mybatisplus.annotation.TableName;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Data;\\nimport lombok.NoArgsConstructor;\\n\\nimport java.io.Serializable;\\nimport java.util.Date;\\n\\n/**\\n * 菜单表(Menu)实体类\\n *\\n * @author 三更\\n * @since 2021-11-24 15:30:08\\n */\\n@TableName(value=\\\"sys_menu\\\")\\n@Data\\n@AllArgsConstructor\\n@NoArgsConstructor\\n@JsonInclude(JsonInclude.Include.NON_NULL)\\npublic class Menu implements Serializable {\\n    private static final long serialVersionUID = -54979041104113736L;\\n    \\n        @TableId\\n    private Long id;\\n    /**\\n    * 菜单名\\n    */\\n    private String menuName;\\n    /**\\n    * 路由地址\\n    */\\n    private String path;\\n    /**\\n    * 组件路径\\n    */\\n    private String component;\\n    /**\\n    * 菜单状态（0显示 1隐藏）\\n    */\\n    private String visible;\\n    /**\\n    * 菜单状态（0正常 1停用）\\n    */\\n    private String status;\\n    /**\\n    * 权限标识\\n    */\\n    private String perms;\\n    /**\\n    * 菜单图标\\n    */\\n    private String icon;\\n    \\n    private Long createBy;\\n    \\n    private Date createTime;\\n    \\n    private Long updateBy;\\n    \\n    private Date updateTime;\\n    /**\\n    * 是否删除（0未删除 1已删除）\\n    */\\n    private Integer delFlag;\\n    /**\\n    * 备注\\n    */\\n    private String remark;\\n}\\n~~~~\\n\\n\\n\\n##### 3.2.3.3 代码实现\\n\\n​\\t我们只需要根据用户id去查询到其所对应的权限信息即可。\\n\\n​\\t所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\\n\\n~~~~java\\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\\nimport com.sangeng.domain.Menu;\\n\\nimport java.util.List;\\n\\n/**\\n * @Author 三更  \\n */\\npublic interface MenuMapper extends BaseMapper<Menu> {\\n    List<String> selectPermsByUserId(Long id);\\n}\\n~~~~\\n\\n​\\t尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\\n\\n~~~~xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\" >\\n<mapper namespace=\\\"com.sangeng.mapper.MenuMapper\\\">\\n\\n\\n    <select id=\\\"selectPermsByUserId\\\" resultType=\\\"java.lang.String\\\">\\n        SELECT\\n            DISTINCT m.`perms`\\n        FROM\\n            sys_user_role ur\\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\\n        WHERE\\n            user_id = #{userid}\\n            AND r.`status` = 0\\n            AND m.`status` = 0\\n    </select>\\n</mapper>\\n~~~~\\n\\n​\\t在application.yml中配置mapperXML文件的位置\\n\\n~~~~yaml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&serverTimezone=UTC\\n    username: root\\n    password: root\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n  redis:\\n    host: localhost\\n    port: 6379\\nmybatis-plus:\\n  mapper-locations: classpath*:/mapper/**/*.xml \\n\\n~~~~\\n\\n\\n\\n​\\t然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\\n\\n~~~~java\\n/**\\n * @Author 三更 \\n */\\n@Service\\npublic class UserDetailsServiceImpl implements UserDetailsService {\\n\\n    @Autowired\\n    private UserMapper userMapper;\\n\\n    @Autowired\\n    private MenuMapper menuMapper;\\n\\n    @Override\\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\\n        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();\\n        wrapper.eq(User::getUserName,username);\\n        User user = userMapper.selectOne(wrapper);\\n        if(Objects.isNull(user)){\\n            throw new RuntimeException(\\\"用户名或密码错误\\\");\\n        }\\n        List<String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\\n//        //测试写法\\n//        List<String> list = new ArrayList<>(Arrays.asList(\\\"test\\\"));\\n        return new LoginUser(user,permissionKeyList);\\n    }\\n}\\n~~~~\\n\\n\\n\\n\\n\\n## 4. 自定义失败处理\\n\\n​\\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\\n\\n​\\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\\n\\n​\\t如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\\n\\n​\\t如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\\n\\n​\\t所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\\n\\n\\n\\n①自定义实现类\\n\\n~~~~java\\n@Component\\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler {\\n    @Override\\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \\\"权限不足\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n/**\\n * @Author 三更  \\n */\\n@Component\\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {\\n    @Override\\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \\\"认证失败请重新登录\\\");\\n        String json = JSON.toJSONString(result);\\n        WebUtils.renderString(response,json);\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n\\n\\n②配置给SpringSecurity\\n\\n​\\t\\n\\n​\\t先注入对应的处理器\\n\\n~~~~java\\n    @Autowired\\n    private AuthenticationEntryPoint authenticationEntryPoint;\\n\\n    @Autowired\\n    private AccessDeniedHandler accessDeniedHandler;\\n~~~~\\n\\n​\\t然后我们可以使用HttpSecurity对象的方法去配置。\\n\\n~~~~java\\n        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\\n                accessDeniedHandler(accessDeniedHandler);\\n~~~~\\n\\n\\n\\n## 5. 跨域\\n\\n​\\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 \\n\\n​\\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\\n\\n​\\t所以我们就要处理一下，让前端能进行跨域请求。\\n\\n①先对SpringBoot配置，运行跨域请求\\n\\n~~~~java\\n@Configuration\\npublic class CorsConfig implements WebMvcConfigurer {\\n\\n    @Override\\n    public void addCorsMappings(CorsRegistry registry) {\\n      // 设置允许跨域的路径\\n        registry.addMapping(\\\"/**\\\")\\n                // 设置允许跨域请求的域名\\n                .allowedOriginPatterns(\\\"*\\\")\\n                // 是否允许cookie\\n                .allowCredentials(true)\\n                // 设置允许的请求方式\\n                .allowedMethods(\\\"GET\\\", \\\"POST\\\", \\\"DELETE\\\", \\\"PUT\\\")\\n                // 设置允许的header属性\\n                .allowedHeaders(\\\"*\\\")\\n                // 跨域允许时间\\n                .maxAge(3600);\\n    }\\n}\\n~~~~\\n\\n②开启SpringSecurity的跨域访问\\n\\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n\\n~~~~\\n\\n\\n\\n\\n\\n## 6. 遗留小问题\\n\\n### 其它权限校验方法\\n\\n​\\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\\n\\n​    \\n\\n​\\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\\n\\n​\\thasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\\n\\n​\\t它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\\n\\n\\n\\n​\\thasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyAuthority(\'admin\',\'test\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasRole(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n​\\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\\n\\n~~~~java\\n    @PreAuthorize(\\\"hasAnyRole(\'admin\',\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n### 自定义权限校验方法\\n\\n​\\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\\n\\n~~~~java\\n@Component(\\\"ex\\\")\\npublic class SGExpressionRoot {\\n\\n    public boolean hasAuthority(String authority){\\n        //获取当前用户的权限\\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\\n        List<String> permissions = loginUser.getPermissions();\\n        //判断用户权限集合中是否存在authority\\n        return permissions.contains(authority);\\n    }\\n}\\n~~~~\\n\\n​\\t 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\\n\\n~~~~java\\n    @RequestMapping(\\\"/hello\\\")\\n    @PreAuthorize(\\\"@ex.hasAuthority(\'system:dept:list\')\\\")\\n    public String hello(){\\n        return \\\"hello\\\";\\n    }\\n~~~~\\n\\n\\n\\n### 基于配置的权限控制\\n\\n​\\t我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\\n\\n~~~~java\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n                //关闭csrf\\n                .csrf().disable()\\n                //不通过Session获取SecurityContext\\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\\n                .and()\\n                .authorizeRequests()\\n                // 对于登录接口 允许匿名访问\\n                .antMatchers(\\\"/user/login\\\").anonymous()\\n                .antMatchers(\\\"/testCors\\\").hasAuthority(\\\"system:dept:list222\\\")\\n                // 除上面外的所有请求全部需要鉴权认证\\n                .anyRequest().authenticated();\\n\\n        //添加过滤器\\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\\n\\n        //配置异常处理器\\n        http.exceptionHandling()\\n                //配置认证失败处理器\\n                .authenticationEntryPoint(authenticationEntryPoint)\\n                .accessDeniedHandler(accessDeniedHandler);\\n\\n        //允许跨域\\n        http.cors();\\n    }\\n~~~~\\n\\n\\n\\n\\n\\n\\n\\n### CSRF\\n\\n​\\t[CSRF](https://blog.csdn.net/freeking101/article/details/86537087)是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\\n\\n​\\tSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\\n\\n​\\t我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\\n\\n\\n\\n\\n\\n### 认证成功处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\\n\\n​\\t我们也可以自己去自定义成功处理器进行成功后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGSuccessHandler implements AuthenticationSuccessHandler {\\n\\n    @Override\\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"认证成功了\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin().successHandler(successHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 认证失败处理器\\n\\n​\\t实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\\n\\n​\\t我们也可以自己去自定义失败处理器进行失败后的相应处理。\\n\\n~~~~java\\n@Component\\npublic class SGFailureHandler implements AuthenticationFailureHandler {\\n    @Override\\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\\n        System.out.println(\\\"认证失败了\\\");\\n    }\\n}\\n~~~~\\n\\n\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n\\n~~~~\\n\\n\\n\\n### 登出成功处理器\\n\\n~~~~java\\n@Component\\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler {\\n    @Override\\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\\n        System.out.println(\\\"注销成功\\\");\\n    }\\n}\\n\\n~~~~\\n\\n~~~~java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Autowired\\n    private AuthenticationSuccessHandler successHandler;\\n\\n    @Autowired\\n    private AuthenticationFailureHandler failureHandler;\\n\\n    @Autowired\\n    private LogoutSuccessHandler logoutSuccessHandler;\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http.formLogin()\\n//                配置认证成功处理器\\n                .successHandler(successHandler)\\n//                配置认证失败处理器\\n                .failureHandler(failureHandler);\\n\\n        http.logout()\\n                //配置注销成功处理器\\n                .logoutSuccessHandler(logoutSuccessHandler);\\n\\n        http.authorizeRequests().anyRequest().authenticated();\\n    }\\n}\\n~~~~\\n\",\"articleCover\":\"http://192.168.188.128:9000/aurora/aurora/articles/02ee236f3ae87d8ce606a7424e7546c9.jpg\",\"articleTitle\":\"Spring Security\",\"categoryName\":\"spring\",\"id\":135,\"isFeatured\":0,\"isTop\":1,\"status\":1,\"tagNames\":[],\"type\":1}]', 'POST', '{\"code\":20000,\"flag\":true,\"message\":\"操作成功\"}', 1014, '长乐予安', '127.0.0.1', '内网IP|内网IP', '2023-11-04 15:15:34', NULL);

-- ----------------------------
-- Table structure for t_photo
-- ----------------------------
DROP TABLE IF EXISTS `t_photo`;
CREATE TABLE `t_photo`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_id` int NOT NULL COMMENT '相册id',
  `photo_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片名',
  `photo_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '照片描述',
  `photo_src` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '照片地址',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 68 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '照片' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_photo
-- ----------------------------

-- ----------------------------
-- Table structure for t_photo_album
-- ----------------------------
DROP TABLE IF EXISTS `t_photo_album`;
CREATE TABLE `t_photo_album`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `album_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册名',
  `album_desc` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册描述',
  `album_cover` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '相册封面',
  `is_delete` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否删除',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态值 1公开 2私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '相册' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_photo_album
-- ----------------------------

-- ----------------------------
-- Table structure for t_resource
-- ----------------------------
DROP TABLE IF EXISTS `t_resource`;
CREATE TABLE `t_resource`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `resource_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '资源名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '权限路径',
  `request_method` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '请求方式',
  `parent_id` int NULL DEFAULT NULL COMMENT '父模块id',
  `is_anonymous` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否匿名访问 0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1189 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_resource
-- ----------------------------
INSERT INTO `t_resource` VALUES (1050, 'aurora信息', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1051, '分类模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1052, '友链模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1053, '定时任务日志模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1054, '定时任务模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1055, '异常处理模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1056, '操作日志模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1057, '文章模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1058, '标签模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1059, '照片模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1060, '用户信息模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1061, '用户账号模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1062, '相册模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1063, '菜单模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1064, '角色模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1065, '评论模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1066, '说说模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1067, '资源模块', NULL, NULL, NULL, 0, '2022-08-19 22:26:21', NULL);
INSERT INTO `t_resource` VALUES (1068, '获取系统信息', '/', 'GET', 1050, 1, '2022-08-19 22:26:22', '2022-08-19 22:26:55');
INSERT INTO `t_resource` VALUES (1069, '查看关于我信息', '/about', 'GET', 1050, 1, '2022-08-19 22:26:22', '2022-08-19 22:26:57');
INSERT INTO `t_resource` VALUES (1070, '获取系统后台信息', '/admin', 'GET', 1050, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1071, '修改关于我信息', '/admin/about', 'PUT', 1050, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1072, '获取后台文章', '/admin/articles', 'GET', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1073, '保存和修改文章', '/admin/articles', 'POST', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1074, '删除或者恢复文章', '/admin/articles', 'PUT', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1075, '物理删除文章', '/admin/articles/delete', 'DELETE', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1076, '导出文章', '/admin/articles/export', 'POST', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1077, '上传文章图片', '/admin/articles/images', 'POST', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1078, '导入文章', '/admin/articles/import', 'POST', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1079, '修改文章是否置顶和推荐', '/admin/articles/topAndFeatured', 'PUT', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1080, '根据id查看后台文章', '/admin/articles/*', 'GET', 1057, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1081, '查看后台分类列表', '/admin/categories', 'GET', 1051, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1082, '添加或修改分类', '/admin/categories', 'POST', 1051, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1083, '删除分类', '/admin/categories', 'DELETE', 1051, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1084, '搜索文章分类', '/admin/categories/search', 'GET', 1051, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1085, '查询后台评论', '/admin/comments', 'GET', 1065, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1086, '删除评论', '/admin/comments', 'DELETE', 1065, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1087, '审核评论', '/admin/comments/review', 'PUT', 1065, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1088, '上传博客配置图片', '/admin/config/images', 'POST', 1050, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1089, '获取定时任务的日志列表', '/admin/jobLogs', 'GET', 1053, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1090, '删除定时任务的日志', '/admin/jobLogs', 'DELETE', 1053, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1091, '清除定时任务的日志', '/admin/jobLogs/clean', 'DELETE', 1053, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1092, '获取定时任务日志的所有组名', '/admin/jobLogs/jobGroups', 'GET', 1053, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1093, '获取任务列表', '/admin/jobs', 'GET', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1094, '添加定时任务', '/admin/jobs', 'POST', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1095, '修改定时任务', '/admin/jobs', 'PUT', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1096, '删除定时任务', '/admin/jobs', 'DELETE', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1097, '获取所有job分组', '/admin/jobs/jobGroups', 'GET', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1098, '执行某个任务', '/admin/jobs/run', 'PUT', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1099, '更改任务的状态', '/admin/jobs/status', 'PUT', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1100, '根据id获取任务', '/admin/jobs/*', 'GET', 1054, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1101, '查看后台友链列表', '/admin/links', 'GET', 1052, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1102, '保存或修改友链', '/admin/links', 'POST', 1052, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1103, '删除友链', '/admin/links', 'DELETE', 1052, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1104, '查看菜单列表', '/admin/menus', 'GET', 1063, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1105, '新增或修改菜单', '/admin/menus', 'POST', 1063, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1106, '修改目录是否隐藏', '/admin/menus/isHidden', 'PUT', 1063, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1107, '删除菜单', '/admin/menus/*', 'DELETE', 1063, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1108, '查看操作日志', '/admin/operation/logs', 'GET', 1056, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1109, '删除操作日志', '/admin/operation/logs', 'DELETE', 1056, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1110, '根据相册id获取照片列表', '/admin/photos', 'GET', 1059, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1111, '保存照片', '/admin/photos', 'POST', 1059, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1112, '更新照片信息', '/admin/photos', 'PUT', 1059, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1113, '删除照片', '/admin/photos', 'DELETE', 1059, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1114, '移动照片相册', '/admin/photos/album', 'PUT', 1059, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1115, '查看后台相册列表', '/admin/photos/albums', 'GET', 1062, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1116, '保存或更新相册', '/admin/photos/albums', 'POST', 1062, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1117, '上传相册封面', '/admin/photos/albums/cover', 'POST', 1062, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1118, '获取后台相册列表信息', '/admin/photos/albums/info', 'GET', 1062, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1119, '根据id删除相册', '/admin/photos/albums/*', 'DELETE', 1062, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1120, '根据id获取后台相册信息', '/admin/photos/albums/*/info', 'GET', 1062, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1121, '更新照片删除状态', '/admin/photos/delete', 'PUT', 1059, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1122, '查看资源列表', '/admin/resources', 'GET', 1067, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1123, '新增或修改资源', '/admin/resources', 'POST', 1067, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1124, '删除资源', '/admin/resources/*', 'DELETE', 1067, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1125, '保存或更新角色', '/admin/role', 'POST', 1064, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1126, '查看角色菜单选项', '/admin/role/menus', 'GET', 1063, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1127, '查看角色资源选项', '/admin/role/resources', 'GET', 1067, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1128, '查询角色列表', '/admin/roles', 'GET', 1064, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1129, '删除角色', '/admin/roles', 'DELETE', 1064, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1130, '查询后台标签列表', '/admin/tags', 'GET', 1058, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1131, '添加或修改标签', '/admin/tags', 'POST', 1058, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1132, '删除标签', '/admin/tags', 'DELETE', 1058, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1133, '搜索文章标签', '/admin/tags/search', 'GET', 1058, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1134, '查看后台说说', '/admin/talks', 'GET', 1066, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1135, '保存或修改说说', '/admin/talks', 'POST', 1066, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1136, '删除说说', '/admin/talks', 'DELETE', 1066, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1137, '上传说说图片', '/admin/talks/images', 'POST', 1066, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1138, '根据id查看后台说说', '/admin/talks/*', 'GET', 1066, 1, '2022-08-19 22:26:22', '2022-08-19 22:33:52');
INSERT INTO `t_resource` VALUES (1139, '查看当前用户菜单', '/admin/user/menus', 'GET', 1063, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1140, '查询后台用户列表', '/admin/users', 'GET', 1061, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1141, '获取用户区域分布', '/admin/users/area', 'GET', 1061, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1142, '修改用户禁用状态', '/admin/users/disable', 'PUT', 1060, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1143, '查看在线用户', '/admin/users/online', 'GET', 1060, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1144, '修改管理员密码', '/admin/users/password', 'PUT', 1061, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1145, '查询用户角色选项', '/admin/users/role', 'GET', 1064, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1146, '修改用户角色', '/admin/users/role', 'PUT', 1060, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1147, '下线用户', '/admin/users/*/online', 'DELETE', 1060, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1148, '获取网站配置', '/admin/website/config', 'GET', 1050, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1149, '更新网站配置', '/admin/website/config', 'PUT', 1050, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1150, '根据相册id查看照片列表', '/albums/*/photos', 'GET', 1059, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:54');
INSERT INTO `t_resource` VALUES (1151, '获取所有文章归档', '/archives/all', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:35');
INSERT INTO `t_resource` VALUES (1152, '获取所有文章', '/articles/all', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:37');
INSERT INTO `t_resource` VALUES (1153, '根据分类id获取文章', '/articles/categoryId', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:38');
INSERT INTO `t_resource` VALUES (1154, '搜索文章', '/articles/search', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:40');
INSERT INTO `t_resource` VALUES (1155, '根据标签id获取文章', '/articles/tagId', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:40');
INSERT INTO `t_resource` VALUES (1156, '获取置顶和推荐文章', '/articles/topAndFeatured', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:41');
INSERT INTO `t_resource` VALUES (1157, '根据id获取文章', '/articles/*', 'GET', 1057, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:42');
INSERT INTO `t_resource` VALUES (1158, '/处理BizException', '/bizException', 'GET', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1159, '/处理BizException', '/bizException', 'HEAD', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1160, '/处理BizException', '/bizException', 'POST', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1161, '/处理BizException', '/bizException', 'PUT', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1162, '/处理BizException', '/bizException', 'DELETE', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1163, '/处理BizException', '/bizException', 'OPTIONS', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1164, '/处理BizException', '/bizException', 'PATCH', 1055, 0, '2022-08-19 22:26:22', NULL);
INSERT INTO `t_resource` VALUES (1165, '获取所有分类', '/categories/all', 'GET', 1051, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:05');
INSERT INTO `t_resource` VALUES (1166, '获取评论', '/comments', 'GET', 1065, 1, '2022-08-19 22:26:22', '2022-08-19 22:33:50');
INSERT INTO `t_resource` VALUES (1167, '添加评论', '/comments/save', 'POST', 1065, 0, '2022-08-19 22:26:22', '2022-08-19 22:33:47');
INSERT INTO `t_resource` VALUES (1168, '获取前七个评论', '/comments/topSeven', 'GET', 1065, 1, '2022-08-19 22:26:22', '2022-08-19 22:33:44');
INSERT INTO `t_resource` VALUES (1169, '查看友链列表', '/links', 'GET', 1052, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:13');
INSERT INTO `t_resource` VALUES (1170, '获取相册列表', '/photos/albums', 'GET', 1062, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:25');
INSERT INTO `t_resource` VALUES (1171, 'report', '/report', 'POST', 1050, 1, '2022-08-19 22:26:22', '2022-08-19 22:27:00');
INSERT INTO `t_resource` VALUES (1172, '获取所有标签', '/tags/all', 'GET', 1058, 1, '2022-08-19 22:26:22', '2022-08-19 22:31:23');
INSERT INTO `t_resource` VALUES (1173, '获取前十个标签', '/tags/topTen', 'GET', 1058, 1, '2022-08-19 22:26:22', '2022-08-19 22:31:27');
INSERT INTO `t_resource` VALUES (1174, '查看说说列表', '/talks', 'GET', 1066, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:38');
INSERT INTO `t_resource` VALUES (1175, '根据id查看说说', '/talks/*', 'GET', 1066, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:38');
INSERT INTO `t_resource` VALUES (1176, '更新用户头像', '/users/avatar', 'POST', 1060, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:05');
INSERT INTO `t_resource` VALUES (1177, '发送邮箱验证码', '/users/code', 'GET', 1061, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:15');
INSERT INTO `t_resource` VALUES (1178, '绑定用户邮箱', '/users/email', 'PUT', 1060, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:06');
INSERT INTO `t_resource` VALUES (1179, '更新用户信息', '/users/info', 'PUT', 1060, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:07');
INSERT INTO `t_resource` VALUES (1180, '根据id获取用户信息', '/users/info/*', 'GET', 1060, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:07');
INSERT INTO `t_resource` VALUES (1181, '用户登出', '/users/logout', 'POST', 1061, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:15');
INSERT INTO `t_resource` VALUES (1182, 'qq登录', '/users/oauth/qq', 'POST', 1061, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:16');
INSERT INTO `t_resource` VALUES (1183, '修改密码', '/users/password', 'PUT', 1061, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:18');
INSERT INTO `t_resource` VALUES (1184, '用户注册', '/users/register', 'POST', 1061, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:17');
INSERT INTO `t_resource` VALUES (1185, '修改用户的订阅状态', '/users/subscribe', 'PUT', 1060, 1, '2022-08-19 22:26:22', '2022-08-19 22:28:08');
INSERT INTO `t_resource` VALUES (1186, '异常日志模块', NULL, NULL, NULL, 0, '2022-08-25 15:13:40', NULL);
INSERT INTO `t_resource` VALUES (1187, '获取异常日志', '/admin/exception/logs', 'GET', 1186, 0, '2022-08-25 15:14:27', NULL);
INSERT INTO `t_resource` VALUES (1188, '删除异常日志', '/admin/exception/logs', 'DELETE', 1186, 0, '2022-08-25 15:14:59', NULL);

-- ----------------------------
-- Table structure for t_role
-- ----------------------------
DROP TABLE IF EXISTS `t_role`;
CREATE TABLE `t_role`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `role_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '角色名',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用  0否 1是',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role
-- ----------------------------
INSERT INTO `t_role` VALUES (1, 'admin', 0, '2022-07-20 13:25:19', '2022-08-16 16:07:49');
INSERT INTO `t_role` VALUES (2, 'admin', 0, '2022-07-20 13:25:40', '2022-08-19 22:55:26');
INSERT INTO `t_role` VALUES (14, 'test', 0, '2022-08-19 21:48:14', '2022-08-19 22:38:15');

-- ----------------------------
-- Table structure for t_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `t_role_menu`;
CREATE TABLE `t_role_menu`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `menu_id` int NULL DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2886 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role_menu
-- ----------------------------
INSERT INTO `t_role_menu` VALUES (2784, 1, 1);
INSERT INTO `t_role_menu` VALUES (2785, 1, 2);
INSERT INTO `t_role_menu` VALUES (2786, 1, 6);
INSERT INTO `t_role_menu` VALUES (2787, 1, 7);
INSERT INTO `t_role_menu` VALUES (2788, 1, 8);
INSERT INTO `t_role_menu` VALUES (2789, 1, 9);
INSERT INTO `t_role_menu` VALUES (2790, 1, 10);
INSERT INTO `t_role_menu` VALUES (2791, 1, 3);
INSERT INTO `t_role_menu` VALUES (2792, 1, 11);
INSERT INTO `t_role_menu` VALUES (2793, 1, 221);
INSERT INTO `t_role_menu` VALUES (2794, 1, 222);
INSERT INTO `t_role_menu` VALUES (2795, 1, 223);
INSERT INTO `t_role_menu` VALUES (2796, 1, 224);
INSERT INTO `t_role_menu` VALUES (2797, 1, 202);
INSERT INTO `t_role_menu` VALUES (2798, 1, 13);
INSERT INTO `t_role_menu` VALUES (2799, 1, 201);
INSERT INTO `t_role_menu` VALUES (2800, 1, 213);
INSERT INTO `t_role_menu` VALUES (2801, 1, 14);
INSERT INTO `t_role_menu` VALUES (2802, 1, 15);
INSERT INTO `t_role_menu` VALUES (2803, 1, 16);
INSERT INTO `t_role_menu` VALUES (2804, 1, 4);
INSERT INTO `t_role_menu` VALUES (2805, 1, 214);
INSERT INTO `t_role_menu` VALUES (2806, 1, 209);
INSERT INTO `t_role_menu` VALUES (2807, 1, 17);
INSERT INTO `t_role_menu` VALUES (2808, 1, 18);
INSERT INTO `t_role_menu` VALUES (2809, 1, 205);
INSERT INTO `t_role_menu` VALUES (2810, 1, 206);
INSERT INTO `t_role_menu` VALUES (2811, 1, 208);
INSERT INTO `t_role_menu` VALUES (2812, 1, 210);
INSERT INTO `t_role_menu` VALUES (2813, 1, 19);
INSERT INTO `t_role_menu` VALUES (2814, 1, 20);
INSERT INTO `t_role_menu` VALUES (2815, 1, 225);
INSERT INTO `t_role_menu` VALUES (2816, 1, 220);
INSERT INTO `t_role_menu` VALUES (2817, 1, 5);
INSERT INTO `t_role_menu` VALUES (2852, 14, 1);
INSERT INTO `t_role_menu` VALUES (2853, 14, 2);
INSERT INTO `t_role_menu` VALUES (2854, 14, 6);
INSERT INTO `t_role_menu` VALUES (2855, 14, 7);
INSERT INTO `t_role_menu` VALUES (2856, 14, 8);
INSERT INTO `t_role_menu` VALUES (2857, 14, 9);
INSERT INTO `t_role_menu` VALUES (2858, 14, 10);
INSERT INTO `t_role_menu` VALUES (2859, 14, 3);
INSERT INTO `t_role_menu` VALUES (2860, 14, 11);
INSERT INTO `t_role_menu` VALUES (2861, 14, 221);
INSERT INTO `t_role_menu` VALUES (2862, 14, 222);
INSERT INTO `t_role_menu` VALUES (2863, 14, 223);
INSERT INTO `t_role_menu` VALUES (2864, 14, 224);
INSERT INTO `t_role_menu` VALUES (2865, 14, 202);
INSERT INTO `t_role_menu` VALUES (2866, 14, 13);
INSERT INTO `t_role_menu` VALUES (2867, 14, 201);
INSERT INTO `t_role_menu` VALUES (2868, 14, 213);
INSERT INTO `t_role_menu` VALUES (2869, 14, 14);
INSERT INTO `t_role_menu` VALUES (2870, 14, 15);
INSERT INTO `t_role_menu` VALUES (2871, 14, 16);
INSERT INTO `t_role_menu` VALUES (2872, 14, 4);
INSERT INTO `t_role_menu` VALUES (2873, 14, 214);
INSERT INTO `t_role_menu` VALUES (2874, 14, 209);
INSERT INTO `t_role_menu` VALUES (2875, 14, 17);
INSERT INTO `t_role_menu` VALUES (2876, 14, 18);
INSERT INTO `t_role_menu` VALUES (2877, 14, 205);
INSERT INTO `t_role_menu` VALUES (2878, 14, 206);
INSERT INTO `t_role_menu` VALUES (2879, 14, 208);
INSERT INTO `t_role_menu` VALUES (2880, 14, 210);
INSERT INTO `t_role_menu` VALUES (2881, 14, 19);
INSERT INTO `t_role_menu` VALUES (2882, 14, 20);
INSERT INTO `t_role_menu` VALUES (2883, 14, 225);
INSERT INTO `t_role_menu` VALUES (2884, 14, 220);
INSERT INTO `t_role_menu` VALUES (2885, 14, 5);

-- ----------------------------
-- Table structure for t_role_resource
-- ----------------------------
DROP TABLE IF EXISTS `t_role_resource`;
CREATE TABLE `t_role_resource`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  `resource_id` int NULL DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5547 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_role_resource
-- ----------------------------
INSERT INTO `t_role_resource` VALUES (5406, 2, 1146);
INSERT INTO `t_role_resource` VALUES (5407, 2, 1167);
INSERT INTO `t_role_resource` VALUES (5408, 1, 1050);
INSERT INTO `t_role_resource` VALUES (5409, 1, 1070);
INSERT INTO `t_role_resource` VALUES (5410, 1, 1071);
INSERT INTO `t_role_resource` VALUES (5411, 1, 1088);
INSERT INTO `t_role_resource` VALUES (5412, 1, 1148);
INSERT INTO `t_role_resource` VALUES (5413, 1, 1149);
INSERT INTO `t_role_resource` VALUES (5414, 1, 1051);
INSERT INTO `t_role_resource` VALUES (5415, 1, 1081);
INSERT INTO `t_role_resource` VALUES (5416, 1, 1082);
INSERT INTO `t_role_resource` VALUES (5417, 1, 1083);
INSERT INTO `t_role_resource` VALUES (5418, 1, 1084);
INSERT INTO `t_role_resource` VALUES (5419, 1, 1052);
INSERT INTO `t_role_resource` VALUES (5420, 1, 1101);
INSERT INTO `t_role_resource` VALUES (5421, 1, 1102);
INSERT INTO `t_role_resource` VALUES (5422, 1, 1103);
INSERT INTO `t_role_resource` VALUES (5423, 1, 1053);
INSERT INTO `t_role_resource` VALUES (5424, 1, 1089);
INSERT INTO `t_role_resource` VALUES (5425, 1, 1090);
INSERT INTO `t_role_resource` VALUES (5426, 1, 1091);
INSERT INTO `t_role_resource` VALUES (5427, 1, 1092);
INSERT INTO `t_role_resource` VALUES (5428, 1, 1054);
INSERT INTO `t_role_resource` VALUES (5429, 1, 1093);
INSERT INTO `t_role_resource` VALUES (5430, 1, 1094);
INSERT INTO `t_role_resource` VALUES (5431, 1, 1095);
INSERT INTO `t_role_resource` VALUES (5432, 1, 1096);
INSERT INTO `t_role_resource` VALUES (5433, 1, 1097);
INSERT INTO `t_role_resource` VALUES (5434, 1, 1098);
INSERT INTO `t_role_resource` VALUES (5435, 1, 1099);
INSERT INTO `t_role_resource` VALUES (5436, 1, 1100);
INSERT INTO `t_role_resource` VALUES (5437, 1, 1055);
INSERT INTO `t_role_resource` VALUES (5438, 1, 1158);
INSERT INTO `t_role_resource` VALUES (5439, 1, 1159);
INSERT INTO `t_role_resource` VALUES (5440, 1, 1160);
INSERT INTO `t_role_resource` VALUES (5441, 1, 1161);
INSERT INTO `t_role_resource` VALUES (5442, 1, 1162);
INSERT INTO `t_role_resource` VALUES (5443, 1, 1163);
INSERT INTO `t_role_resource` VALUES (5444, 1, 1164);
INSERT INTO `t_role_resource` VALUES (5445, 1, 1056);
INSERT INTO `t_role_resource` VALUES (5446, 1, 1108);
INSERT INTO `t_role_resource` VALUES (5447, 1, 1109);
INSERT INTO `t_role_resource` VALUES (5448, 1, 1057);
INSERT INTO `t_role_resource` VALUES (5449, 1, 1072);
INSERT INTO `t_role_resource` VALUES (5450, 1, 1073);
INSERT INTO `t_role_resource` VALUES (5451, 1, 1074);
INSERT INTO `t_role_resource` VALUES (5452, 1, 1075);
INSERT INTO `t_role_resource` VALUES (5453, 1, 1076);
INSERT INTO `t_role_resource` VALUES (5454, 1, 1077);
INSERT INTO `t_role_resource` VALUES (5455, 1, 1078);
INSERT INTO `t_role_resource` VALUES (5456, 1, 1079);
INSERT INTO `t_role_resource` VALUES (5457, 1, 1080);
INSERT INTO `t_role_resource` VALUES (5458, 1, 1058);
INSERT INTO `t_role_resource` VALUES (5459, 1, 1130);
INSERT INTO `t_role_resource` VALUES (5460, 1, 1131);
INSERT INTO `t_role_resource` VALUES (5461, 1, 1132);
INSERT INTO `t_role_resource` VALUES (5462, 1, 1133);
INSERT INTO `t_role_resource` VALUES (5463, 1, 1059);
INSERT INTO `t_role_resource` VALUES (5464, 1, 1110);
INSERT INTO `t_role_resource` VALUES (5465, 1, 1111);
INSERT INTO `t_role_resource` VALUES (5466, 1, 1112);
INSERT INTO `t_role_resource` VALUES (5467, 1, 1113);
INSERT INTO `t_role_resource` VALUES (5468, 1, 1114);
INSERT INTO `t_role_resource` VALUES (5469, 1, 1121);
INSERT INTO `t_role_resource` VALUES (5470, 1, 1060);
INSERT INTO `t_role_resource` VALUES (5471, 1, 1142);
INSERT INTO `t_role_resource` VALUES (5472, 1, 1143);
INSERT INTO `t_role_resource` VALUES (5473, 1, 1146);
INSERT INTO `t_role_resource` VALUES (5474, 1, 1147);
INSERT INTO `t_role_resource` VALUES (5475, 1, 1061);
INSERT INTO `t_role_resource` VALUES (5476, 1, 1140);
INSERT INTO `t_role_resource` VALUES (5477, 1, 1141);
INSERT INTO `t_role_resource` VALUES (5478, 1, 1144);
INSERT INTO `t_role_resource` VALUES (5479, 1, 1062);
INSERT INTO `t_role_resource` VALUES (5480, 1, 1115);
INSERT INTO `t_role_resource` VALUES (5481, 1, 1116);
INSERT INTO `t_role_resource` VALUES (5482, 1, 1117);
INSERT INTO `t_role_resource` VALUES (5483, 1, 1118);
INSERT INTO `t_role_resource` VALUES (5484, 1, 1119);
INSERT INTO `t_role_resource` VALUES (5485, 1, 1120);
INSERT INTO `t_role_resource` VALUES (5486, 1, 1063);
INSERT INTO `t_role_resource` VALUES (5487, 1, 1104);
INSERT INTO `t_role_resource` VALUES (5488, 1, 1105);
INSERT INTO `t_role_resource` VALUES (5489, 1, 1106);
INSERT INTO `t_role_resource` VALUES (5490, 1, 1107);
INSERT INTO `t_role_resource` VALUES (5491, 1, 1126);
INSERT INTO `t_role_resource` VALUES (5492, 1, 1139);
INSERT INTO `t_role_resource` VALUES (5493, 1, 1064);
INSERT INTO `t_role_resource` VALUES (5494, 1, 1125);
INSERT INTO `t_role_resource` VALUES (5495, 1, 1128);
INSERT INTO `t_role_resource` VALUES (5496, 1, 1129);
INSERT INTO `t_role_resource` VALUES (5497, 1, 1145);
INSERT INTO `t_role_resource` VALUES (5498, 1, 1065);
INSERT INTO `t_role_resource` VALUES (5499, 1, 1085);
INSERT INTO `t_role_resource` VALUES (5500, 1, 1086);
INSERT INTO `t_role_resource` VALUES (5501, 1, 1087);
INSERT INTO `t_role_resource` VALUES (5502, 1, 1167);
INSERT INTO `t_role_resource` VALUES (5503, 1, 1066);
INSERT INTO `t_role_resource` VALUES (5504, 1, 1134);
INSERT INTO `t_role_resource` VALUES (5505, 1, 1135);
INSERT INTO `t_role_resource` VALUES (5506, 1, 1136);
INSERT INTO `t_role_resource` VALUES (5507, 1, 1137);
INSERT INTO `t_role_resource` VALUES (5508, 1, 1067);
INSERT INTO `t_role_resource` VALUES (5509, 1, 1122);
INSERT INTO `t_role_resource` VALUES (5510, 1, 1123);
INSERT INTO `t_role_resource` VALUES (5511, 1, 1124);
INSERT INTO `t_role_resource` VALUES (5512, 1, 1127);
INSERT INTO `t_role_resource` VALUES (5513, 1, 1186);
INSERT INTO `t_role_resource` VALUES (5514, 1, 1187);
INSERT INTO `t_role_resource` VALUES (5515, 1, 1188);
INSERT INTO `t_role_resource` VALUES (5516, 14, 1070);
INSERT INTO `t_role_resource` VALUES (5517, 14, 1148);
INSERT INTO `t_role_resource` VALUES (5518, 14, 1081);
INSERT INTO `t_role_resource` VALUES (5519, 14, 1084);
INSERT INTO `t_role_resource` VALUES (5520, 14, 1101);
INSERT INTO `t_role_resource` VALUES (5521, 14, 1089);
INSERT INTO `t_role_resource` VALUES (5522, 14, 1092);
INSERT INTO `t_role_resource` VALUES (5523, 14, 1093);
INSERT INTO `t_role_resource` VALUES (5524, 14, 1097);
INSERT INTO `t_role_resource` VALUES (5525, 14, 1100);
INSERT INTO `t_role_resource` VALUES (5526, 14, 1108);
INSERT INTO `t_role_resource` VALUES (5527, 14, 1072);
INSERT INTO `t_role_resource` VALUES (5528, 14, 1080);
INSERT INTO `t_role_resource` VALUES (5529, 14, 1130);
INSERT INTO `t_role_resource` VALUES (5530, 14, 1133);
INSERT INTO `t_role_resource` VALUES (5531, 14, 1110);
INSERT INTO `t_role_resource` VALUES (5532, 14, 1143);
INSERT INTO `t_role_resource` VALUES (5533, 14, 1140);
INSERT INTO `t_role_resource` VALUES (5534, 14, 1141);
INSERT INTO `t_role_resource` VALUES (5535, 14, 1115);
INSERT INTO `t_role_resource` VALUES (5536, 14, 1118);
INSERT INTO `t_role_resource` VALUES (5537, 14, 1104);
INSERT INTO `t_role_resource` VALUES (5538, 14, 1126);
INSERT INTO `t_role_resource` VALUES (5539, 14, 1139);
INSERT INTO `t_role_resource` VALUES (5540, 14, 1128);
INSERT INTO `t_role_resource` VALUES (5541, 14, 1145);
INSERT INTO `t_role_resource` VALUES (5542, 14, 1085);
INSERT INTO `t_role_resource` VALUES (5543, 14, 1134);
INSERT INTO `t_role_resource` VALUES (5544, 14, 1122);
INSERT INTO `t_role_resource` VALUES (5545, 14, 1127);
INSERT INTO `t_role_resource` VALUES (5546, 14, 1187);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标签名',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 43 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (41, 'java', '2023-11-01 18:00:19', NULL);
INSERT INTO `t_tag` VALUES (42, 'linux', '2023-11-01 18:12:49', NULL);

-- ----------------------------
-- Table structure for t_talk
-- ----------------------------
DROP TABLE IF EXISTS `t_talk`;
CREATE TABLE `t_talk`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '说说id',
  `user_id` int NOT NULL COMMENT '用户id',
  `content` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '说说内容',
  `images` varchar(2500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图片',
  `is_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶',
  `status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '状态 1.公开 2.私密',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 69 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_talk
-- ----------------------------
INSERT INTO `t_talk` VALUES (68, 1024, 'ES搜索太占内存嘞，已关闭(反正发布的文章也不多)', '', 1, 1, '2023-11-01 18:27:24', '2023-11-01 18:28:14');

-- ----------------------------
-- Table structure for t_unique_view
-- ----------------------------
DROP TABLE IF EXISTS `t_unique_view`;
CREATE TABLE `t_unique_view`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `views_count` int NOT NULL COMMENT '访问量',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1539 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_unique_view
-- ----------------------------

-- ----------------------------
-- Table structure for t_user_auth
-- ----------------------------
DROP TABLE IF EXISTS `t_user_auth`;
CREATE TABLE `t_user_auth`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_info_id` int NOT NULL COMMENT '用户信息id',
  `username` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码',
  `login_type` tinyint(1) NOT NULL COMMENT '登录类型',
  `ip_address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户登录ip',
  `ip_source` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1016 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_auth
-- ----------------------------
INSERT INTO `t_user_auth` VALUES (1, 1, 'admin@163.com', '$2a$10$/Z90STxVyGOIfNhTfvzbEuJ9t1yHjrkN6pBMRAqd5g5SdNIrdt5Da', 1, '127.0.0.1', '内网IP|内网IP', '2022-08-19 21:43:46', '2023-11-01 17:42:36', '2023-11-01 17:42:36');
INSERT INTO `t_user_auth` VALUES (1014, 1024, '3319023171@qq.com', '$2a$10$lRFzoUzPAjFRvHkGYMDjDOEI99emcUBU/rFBWBd3M8eFcGLFmVSp2', 1, '127.0.0.1', '内网IP|内网IP', '2023-10-24 20:09:08', '2023-11-04 14:51:28', '2023-11-04 14:51:28');
INSERT INTO `t_user_auth` VALUES (1015, 1026, 'test@163.com', '$2a$10$hiEPTsL.3jndBB3AgMu2P.h6ax8/iLmqXFdlCZcyleSUnmUcaAgRC', 1, '127.0.0.1', '内网IP|内网IP', '2023-11-01 17:27:21', '2023-11-01 17:27:24', '2023-11-01 17:27:24');

-- ----------------------------
-- Table structure for t_user_info
-- ----------------------------
DROP TABLE IF EXISTS `t_user_info`;
CREATE TABLE `t_user_info`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱号',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '用户头像',
  `intro` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户简介',
  `website` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人网站',
  `is_subscribe` tinyint(1) NULL DEFAULT NULL COMMENT '是否订阅',
  `is_disable` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否禁用',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1027 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_info
-- ----------------------------
INSERT INTO `t_user_info` VALUES (1, 'admin@163.com', '演示账号', 'http://192.168.188.128:9000/aurora/aurora/avatar/34a0eb1ce0b80388d9eed2c476abfd66.webp', '演示账号的用户简介', 'https://www.linhaojun.top', 0, 0, '2022-08-19 21:42:04', '2023-11-01 17:43:32');
INSERT INTO `t_user_info` VALUES (1024, '3319023171@qq.com', '长乐予安', 'http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg', NULL, 'http://192.168.188.128:9000', NULL, 0, '2023-10-24 20:09:08', '2023-11-01 17:04:16');
INSERT INTO `t_user_info` VALUES (1026, 'test@163.com', '测试账号', 'http://192.168.188.128:9000/aurora/aurora/avatar/b924493f20b1256bf78391110a440bdc.jpeg', '测试账号', NULL, NULL, 0, '2023-11-01 17:27:21', '2023-11-01 17:28:07');

-- ----------------------------
-- Table structure for t_user_role
-- ----------------------------
DROP TABLE IF EXISTS `t_user_role`;
CREATE TABLE `t_user_role`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NULL DEFAULT NULL COMMENT '用户id',
  `role_id` int NULL DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1034 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_role
-- ----------------------------
INSERT INTO `t_user_role` VALUES (1, 1, 1);
INSERT INTO `t_user_role` VALUES (1032, 1024, 1);
INSERT INTO `t_user_role` VALUES (1033, 1026, 2);

-- ----------------------------
-- Table structure for t_website_config
-- ----------------------------
DROP TABLE IF EXISTS `t_website_config`;
CREATE TABLE `t_website_config`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `config` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '配置信息',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_website_config
-- ----------------------------
INSERT INTO `t_website_config` VALUES (1, '{\"alipayQRCode\":\"\",\"author\":\"长乐予安\",\"authorAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"authorIntro\":\"正青春被编程削去了头发\",\"beianNumber\":\"\",\"csdn\":\"\",\"englishName\":\"changleyuan\",\"gitee\":\"\",\"github\":\"\",\"isCommentReview\":0,\"isEmailNotice\":1,\"isReward\":0,\"juejin\":\"\",\"logo\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"multiLanguage\":1,\"name\":\"长乐予安\",\"notice\":\"\",\"qq\":\"3319023171\",\"qqLogin\":0,\"stackoverflow\":\"\",\"touristAvatar\":\"http://192.168.188.128:9000/aurora/aurora/avatar/b070712de81da3c39ae7d6335823ba28.jpeg\",\"twitter\":\"\",\"userAvatar\":\"http://192.168.188.128:9000/aurora/aurora/config/dd22a649ac2f2220257f323e58574a9f.webp\",\"weChat\":\"\",\"websiteCreateTime\":\"2023-10-20\",\"weiXinQRCode\":\"\",\"weibo\":\"\",\"zhihu\":\"\"}', '2022-07-24 12:05:33', '2023-11-01 18:10:43');

SET FOREIGN_KEY_CHECKS = 1;
